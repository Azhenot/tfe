




































untitled


Flow Ambiguity: A Path Towards Classically Driven Blind Quantum Computation

Atul Mantri,1,2 Tommaso F. Demarie,1,2,† Nicolas C. Menicucci,3,4,* and Joseph F. Fitzsimons1,2,‡
1Singapore University of Technology and Design, 8 Somapah Road, Singapore 487372

2Centre for Quantum Technologies, National University of Singapore,
Block S15, 3 Science Drive 2, Singapore 117543

3Centre for Quantum Computation and Communication Technology, School of Science,
RMIT University, Melbourne, Victoria 3001, Australia

4School of Physics, The University of Sydney, Sydney, New South Wales 2006, Australia
(Received 1 September 2016; revised manuscript received 4 April 2017; published 11 July 2017)

Blind quantum computation protocols allow a user to delegate a computation to a remote quantum computer
in such a way that the privacy of their computation is preserved, even from the device implementing the
computation. To date, such protocols are only known for settings involving at least two quantum devices: either
a user with some quantum capabilities and a remote quantum server or two or more entangled but
noncommunicating servers. In this work, we take the first step towards the construction of a blind quantum
computing protocol with a completely classical client and single quantum server. Specifically, we show how a
classical client can exploit the ambiguity in the flow of information inmeasurement-based quantum computing
to construct a protocol for hiding critical aspects of a computation delegated to a remote quantum computer.
This ambiguity arises due to the fact that, for a fixed graph, there exist multiple choices of the input and output
vertex sets that result in deterministic measurement patterns consistent with the same fixed total ordering of
vertices. This allows a classical user, computing only measurement angles, to drive a measurement-based
computation performed on a remote device while hiding critical aspects of the computation.

DOI: 10.1103/PhysRevX.7.031004 Subject Areas: Quantum Information

I. INTRODUCTION

Large-scale quantum computers offer the promise of
quite extreme computational advantages over conventional
computing technologies for a range of problems spanning
cryptanalysis [1], simulation of physical systems [2], and
machine learning [3]. Recently, however, a new application
has emerged for quantum computers: secure delegated
computation [4].
Consider a user wishing to have a computation performed

on a remote server. Two main security concerns arising for
the user relate to the privacy and the correctness of the
computation. The privacy concern is that the description of
their computation, both the program and any input data,
remains hidden even from the server. The correctness
concern is that a malicious server might tamper with their
computation, sending them a misleading result; hence,
ideally such behavior would be detectable. Quantum proto-
cols have been proposed that can mitigate both of these
concerns. In the literature, protocols that allow for program
and data privacy are known as blind quantum computing
protocols, while protocols that allow for correctness to be

ensured with high probability are known as verifiable
quantum computing protocols [5].
The first blind quantum computing protocol was proposed

by Childs [6]. While functional, this scheme put a rather
heavy burden on the client’s side in terms of resources, with
the client required to control a quantum memory and to
perform SWAP gates. A subsequent protocol, from Arrighi
and Salvail [7], introduced mechanisms for both verification
and blindness for a limited range of functions and can be
seen as the start of an intimate link between blindness
and verifiability. This link was further established with the
discovery of the universal blind quantum computing
(UBQC) protocol [8], which allows a client, equipped only
with the ability to produce single-qubit states, to delegate an
arbitrary quantumcomputation to a universal quantum server
while making it blind with unconditional security.
This schemehasbeenmodified andextended several times

in the last few years, with works investigating robustness
[9–11], optimality [12–14], and issues related to physical
implementations [15,16]. Importantly, the blind computation
protocols have proven a powerful tool in the construction of
verifiable quantum computing protocols, with a number of
protocols emerging in recent years based on the UBQC
protocol [17–19] and on an alternative blind protocol from
Morimae and Fujii [20] in which the client performs single-
qubit measurements rather than state preparations [21–23].
The relatively low overhead in such schemes has made it
possible to implement both blind and verifiable quantum
computing protocols in quantum optics [24–26].

*ncmenicucci@gmail.com
†tommaso_demarie@sutd.edu.sg
‡joseph_fitzsimons@sutd.edu.sg

Published by the American Physical Society under the terms of
the Creative Commons Attribution 3.0 License. Further distri-
bution of this work must maintain attribution to the author(s) and
the published article’s title, journal citation, and DOI.

PHYSICAL REVIEW X 7, 031004 (2017)

2160-3308=17=7(3)=031004(15) 031004-1 Published by the American Physical Society

https://doi.org/10.1103/PhysRevX.7.031004
https://doi.org/10.1103/PhysRevX.7.031004
https://doi.org/10.1103/PhysRevX.7.031004
https://doi.org/10.1103/PhysRevX.7.031004
http://creativecommons.org/licenses/by/3.0/
http://creativecommons.org/licenses/by/3.0/


The question of verifiability, directly rather than as a
consequence of blindness, has also attracted attention. This
problem was first studied by Aharonov et al. [27], who
considered the use of a constant-sized quantum computer to
verify a larger device. Subsequent work by Broadbent [28]
reduced the requirements on the prover to mirror those
used in the UBQC protocol. An entirely distinct route to
verification has also emerged, which considers a classical
user but requires multiple entangled but noncommuni-
cating servers [29,30]. Surprisingly, perhaps, many of these
schemes are also blind, though often this was not the aim
of the paper. In fact, only a few examples of verifiable com-
puting schemes exist that are not naturally blind [31,32],
and it is tempting to conjecture a fundamental link between
blindness and verifiability.
The verification methods discussed above provide a very

strong form of certification, amounting to interactive proofs
for correctness, which do not rely on any assumptions
about the functioning of the device to be tested. From an
experimental point of view, the first nonclassically simu-
lable evolution of quantum systems will most likely be
implemented by means of nonuniversal quantum simula-
tors rather than fully universal quantum computers. Here,
too, the problem arises of certifying the correct functioning
of a device [33] that cannot be efficiently simulated.
However, in this regime, interactive proofs have proven
more difficult to construct. Nonetheless, progress has been
made in developing a range of certification techniques for
various physical systems. These include feasible quantum
state tomography of matrix product states [34], certification
of the experimental preparation of resources for photonic
quantum technologies [35], certification of simulators of
frustration-free Hamiltonians [36], and derivation of a
statistical benchmark for boson sampling experiments [37].
A common feature among all blind quantum computing

protocols and interactive proofs of correctness for quantum
computation is that they require that at least two parties
possess quantum capabilities. Removing this requirement
and allowing a purely classical user to interact with a single
quantum server would greatly expand the practicality of
delegated quantumcomputation since itwould remove large-
scale quantum networks as a prerequisite for verifiability. In
the present work, we focus specifically on the question of
blind computation with a completely classical client, but
given the historic links between progress in blindness and
verification, it is natural to expect that progress in either
direction will likely be reflected in the other.
While it is presently unknown if such a protocol

can exist, a negative result in this context is a scheme-
dependent impossibility proof presented in Ref. [38].
There, the author considered a scenario where a classical
user and a quantum server exchange classical information
in a two-step process. First, the classical client encodes her
description of the computation using an affine encryption
scheme and then sends all the classical encrypted data to the

server. The server then performs a quantum computation
using the received data and returns the classical output to
the client, who decrypts the result using her encryption key.
For this setting, it was shown that secure blind quantum
computing cannot be achieved unless BPP ¼ BQP (i.e.,
unless a classical computer can efficiently simulate a
quantum computer). While this is an interesting result, it
imposes strong assumptions on the operational method of
blind quantum computation with a classical client and
therefore does not seem to limit further studies in this
direction. Additionally, Aaronson et al. [39] have recently
suggested that information-theoretically blind quantum
computing with a classical client is not likely to be possible
because the existence of such a scheme implies unlikely
containments between complexity classes. Additional
implications that the development of a classical-client
blind-computation protocol would have in complexity
theory are discussed in Ref. [40].
Here, we provide evidence in the opposite direction. We

introduce a form of delegated quantum computation using
measurement-based quantum computing (MBQC) as the
underlying framework. This allows us to introduce a
model-specific protocol that achieves a satisfying degree
of security by directly exploiting the structure of MBQC.
We show that the classical communication received by the
party performing quantum operations is insufficient to
reconstruct a description of the computation. This insuffi-
ciency remains even when the server is required only to
identify the computation up to pre- and post-processing by
polynomial-sized classical computation, under plausible
complexity-theoretic assumptions. We call our scheme
classically driven blind quantum computing (CDBQC).
The paper is structured as follows: In Sec. II, we present

a short introduction to MBQC. In Sec. III, we describe the
steps of the CDBQC protocol. In Sec. IV, we use mutual
information to analyze the degree of blindness for a single
round of the CDBQC protocol. In Sec. V, we introduce the
concept of flow ambiguity, and we show how this is used by
the client to hide information from the quantum server. Our
conclusions are presented in Sec. VI.

II. MEASUREMENT-BASED
QUANTUM COMPUTATION

In MBQC, a computation is performed by means of
single-qubit projective measurements that drive the quan-
tum information across a highly entangled resource state.
The most general resources for MBQC are graph states
[41]. A graph state is defined by a simple and undirected
graph, i.e., a mathematical object G ¼ ðV; EÞ composed of
a vertex set V and an edge set E, with cardinality jVj and
jEj, respectively. The vertices of the graph represent the
qubits, while their interactions are symbolized by the edges.
A graph state jGi is an N-qubit state, where N ¼ jVj. Each
qubit is initialized in the state jþi ¼ 1ffiffi

2
p ðj0i þ j1iÞ and

then entangled with its neighbors by controlled-Z gates,

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-2



ĈZi;j ¼ j0ih0ji ⊗ Îj þ j1ih1ji ⊗ Ẑj, where Î and Ẑ are
the single-qubit identity and Pauli-Z gate, respectively.
Explicitly, jGi ¼ Qði;jÞ∈EĈZi;jjþi⊗N . Equivalently, a graph
state jGi can be defined by the stabilizer relations
K̂vjGi ¼ jGi, with stabilizers [41]

K̂v ¼ X̂v
Y

w∈N ðvÞ
Ẑw; ∀ v ∈ V; ð1Þ

where N ðvÞ denotes the neighborhood of v in G. Without
loss of generality, the vertices in G can be labeled ð1;…; NÞ
in the order that the corresponding qubits are to be
measured. We take this ordering to be implicit in the
definition of the graph, for example, as the order in which
the vertices appear in the adjacency matrix for G. It is also
useful to define a specific type of graph state that will be
used later. An N-qubit cluster state jCSin;m is the graph
state corresponding to an n ×m regular square-lattice graph
Gn;m. For such a graph, N ¼ nm.
In the MBQC framework, given a resource state with

graph G, the standard procedure to perform a computation
is to first identify two sets of qubits fI; Og on G. This
procedure defines an open graph GðI; OÞ, such that I,O⊆V
for a given G. The set I corresponds to the input set, while
O denotes the output set. In general, 0 < jIj ≤ jOj ≤ jVj.
Note that the input and output sets can overlap. The
complement of I is written Ic, and similarly, the comple-
ment of O is Oc. We also denote by PðIcÞ the power set of
all the subsets of elements in Ic, and we define

OddðKÞ ≔ fi∶jN ðiÞ ∩ Kj ¼ 1 mod 2g ð2Þ
as the odd neighborhood of a set of vertices K ⊆ V. In
this work, we are only interested in MBQC protocols
that implement unitary embeddings. Hence, for us,
jIj ¼ jOj ≤ N. Intuitively, the state of the qubits in the
input set corresponds to the input state of a computation.
Similarly, the qubits in the output set will contain the
quantum information corresponding to the result of the
computation once all the qubits in Oc have been measured.
In the process, the quantum information is transformed by
the same principle that governs the generalized one-bit
teleportation scheme [42,43].
For our purposes, we restrict the measurements to be

projectivemeasurements in theXY-plane of theBloch sphere,
denoted M

αj
j ¼fj�αih�αjjg for qubit j, where j�αi ¼

1ffiffi
2

p ðj0i � eiαj1iÞ. As a convention, we use bj ¼ 0 for the
measured qubit collapsing to jþαij and bj ¼ 1 for collapsing
to j−αij. The computation tobeperformed is specifiedbothby
the choice of open graphGðI; OÞ and by a vectorα specifying
the measurement basis αi for each qubit i. Note that these are
the measurements that would be made directly on the cluster
state if all themeasurement outcomeswere zero for nonoutput
qubits—i.e., if one were to implement the positive branch of
the MBQC computation. Importantly, by convention, the

positive branch corresponds to the target computation. In
general, however, these bases need to be updated based on
outcomes of earlier measurements in order to ensure the
correct computation is performed. The description of the
resource state, theorder ofmeasurements, and thedependency
of themeasurementbases onpreviousmeasurement outcomes
are collectively known as a measurement pattern.
Projective measurements are inherently random in quan-

tum mechanics, and one needs a procedure to correct for
this randomness. We show that this need for adaptation of
future measurements based on previous outcomes is what
prevents Bob from knowing the protocol perfectly. Not
incidentally, it is also what circumvents the no-go result
from Ref. [38]. This is because only Alice knows how she
is choosing to adapt future measurement bases dependent
on previous measurement outcomes: Our observation is
that different choices of adaptation strategy correspond to
different computations in general.
The structure that determines how to recover determin-

istic evolution from a MBQCmeasurement pattern is called
g-flow [44], from “generalized quantum-information flow.”
Rigorously, given some resource state jGi and a measure-
ment pattern on it, if the associated open graph GðI; OÞ
satisfies certain g-flow conditions (to be described later),
then the pattern is runnable, and it is also uniformly,
strongly, and stepwise deterministic. This means that each
branch of the pattern can be made equal to the positive
branch after each measurement by application of local
corrections, independently of the measurement angles. We
use “deterministic” without ambiguity to indicate all these
attributes. Note also that satisfying the g-flow conditions is
a necessary and sufficient condition for determinism.
In practice, the g-flow assigns a set of local Pauli

corrections to a subset of unmeasured qubits after a
measurement. See Ref. [45] for the fine details regarding
the practicalities of g-flow. For simplicity, in the definition
of g-flow below adapted from Ref. [44], we assume all
qubits are measured in the XY-plane of the Bloch sphere.
The idea behind g-flow is to determine whether one can
find a correction operator (related to a correcting set on the
graph) that, in the case of a nonzero measurement outcome,
can revert the quantum state onto the projection corre-
sponding to the zero outcome. This is done by applying
stabilizer operators on the state. The g-flow conditions
determine whether the geometrical structure of an open
graph allows for these corrections after each measurement.

Definition 1. [g-flow] For an open graph GðI; OÞ, there
exists a g-flow ðg;≻Þ if one can define a function g∶Oc →
PðIcÞ and a partial order ≻ on V such that ∀i ∈ Oc all of
the following conditions hold:

(G1) if j ∈ gðiÞ and j ≠ i, then j ≻ i;
(G2) if j ⊁ i and i ≠ j, then j ∉ Odd(gðiÞ); and
(G3) i ∉ gðiÞ and i ∈ Odd(gðiÞ).

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-3



The successor function gðiÞ indicates what measurements
will be affected by the outcome of the measurement of qubit
i, while the partial order≻ should be thought of as the causal
order of measurements. The condition (G1) says that if a
vertex j is in the correcting set of the vertex i, then j should
be measured after the vertex i. In other words, a correction
should happen after the assigned measurement. Condition
(G2) makes sure that if the correcting set of a vertex i is
connected to a vertex j, and j ismeasured before the vertex i,
then the vertex j should have an even number of con-
nections with the correcting set of vertex i. Then, vertex j
receives an even number of equal Pauli corrections, which
is equivalent to receiving none; hence, no correction can
affect earlier corrections. Finally, condition (G3) ensures
that each vertex i has an odd number of connections with its
correcting set, such that a correction is indeed performed on
i [45]. In this sense, the g-flow conditions are understood in
terms of geometrical conditions on the open graph.
Guided by these conditions, for cluster states, here and in

the following, we always adopt the same choice of vertex
labeling on the graph as shown in Fig. 1. This choice is
motivated by our later goal of counting how many choices
of open graphs satisfy the g-flow conditions on a given
cluster state. Since a vertex labeling corresponds to a total
order of measurement, it is easy to check that, in order to
satisfy the g-flow conditions, for any vertex i, the quantum
information can only move towards the right, move towards
the bottom, or stay on that vertex. Furthermore, condition
(G3) imposes that the information from a vertex cannot
move simultaneously towards the right and towards the
bottom. In order to further simplify the process of counting
flows, we introduce an additional criterion, which is not
strictly required by g-flow:

(G4) If k ∈ N ðiÞ ∪ N ðjÞ, and if k ∈ gðiÞ, then k ∉ gðjÞ.
For Gn;m, as we shall see later, it will prove easier to
count flows satisfying (G1)–(G4) than those satisfying

(G1)–(G3). This process of course only provides a lower
bound on the number of flows rather than the exact number,
but it will be sufficient for our purposes.
With these four criteria in place, we can define a g-flow

graph path, in this restricted version of g-flow, as an
ordered set of adjacent edges of the graph, starting from
an element of the input set and ending on an element of the
output set, such that for each edge ij of the path, we have
j ∈ gðiÞ, with j ≻ i. Then, it follows that (G4) does not
allow the g-flow graph paths to cross. To help the under-
standing of MBQC, one could think of a g-flow graph path
as a representation of a wire in the quantum circuit picture.
This intuition will be used later in this work to count how
many ways one could define an open graph with g-flow for
our choice of total ordering, which in turn provides a link to
the idea that different open graphs with g-flow lead to
different quantum computations.

III. CLASSICALLY DRIVEN BLIND
QUANTUM COMPUTATION

We start from the situation where Alice, the client, wants
to obtain the result of a particular quantum computation.
Having no quantum devices of her own, the quantum
computation must have a classical output. We allow Alice
to control a probabilistic polynomial-time universal Turing
machine (i.e., a classical computer with access to random-
ness). Alice has classical communication lines to and from
Bob, the server. Bob has access to a universal (and
noiseless) quantum computer. Bob could help Alice, but
she does not trust him. Alice wishes to ask Bob to perform a
quantum computation for her in a way that Bob obtains as
little information as possible about her choice of compu-
tation. Without loss of generality, we assume that the
quantum systems used in the protocol are qubits (two-level
quantum systems [46]). In general, here and in the
following, we denote by

ΔA ¼ fρI; ÛA;Mg ð3Þ

the classical description of Alice’s computation, where ρI is
the n-qubit input state of the computation, ÛA is the unitary
embedding that maps ρI to the output state ρO ¼ ÛAρIÛ†A,
and M is the final set of measurements on ρO required to
extract the classical output. Note that we are implying that
the input state can be efficiently described classically. For
instance, it could be a standard choice of input such as the
n-qubit computational basis ρI ¼ j0ih0j⊗n. We also (rather
pedantically) assume that the number of computational
steps is at most polynomial in the input size. Making the
process abstract, Alice’s desired task becomes equal to
sampling the string

p ¼ fpig ¼ πðΔAÞ ≔ MðÛAρIÛ†AÞ; ð4Þ
FIG. 1. Total order of the measurements for a generic n ×m
cluster state used as a resource state in Protocol 1.

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-4



where π is a map that describes the blind operation
performed by the protocol, which outputs the correct
probability distribution fpig on the joint measurement
outcomes given ΔA as Alice’s delegated target computa-
tion. An outline of the protocol is presented in Protocol 1.
Let us now introduce the relevant definitions for the

variables used in the protocol and describe the steps
thoroughly. The initial step of the protocol is for Bob to
prepare the resource state jGi that will be used to implement
the MBQC. Once the graph state jGi is prepared by Bob, the
interactive part of the protocol starts with Alice communicat-
ing to Bob the angles to bemeasured, one by one. Because of
the randomness introduced by the results of the projective
measurements, there exists the possibility that these angles
must be corrected based on the outcomes

b ≔ ðb1;…; bNÞ ∈ ZN2 ð5Þ

of Alice’s would-be measurements. Nonetheless, Alice can
pick a canonical set of angles

α ≔ ðα1;…;αNÞ ∈ AN ð6Þ

corresponding to the positive branch case where b ¼ 0. As
discussed earlier, it is possible that the angle for qubit jmust
be modified based on the outcomes of the preceding j − 1
measurements, which we denote

b<j ≔ ðb1;…; bj−1Þ: ð7Þ

We account for this adaptation in dependency sets

sx ≔ ðsx1;…; sxNÞ ∈ ZN2 ; ð8Þ

sz ≔ ðsz1;…; szNÞ ∈ ZN2 ; ð9Þ

which depend on theb<j and also on theg-flow construction,
here represented by a bit string

f ≔ ðf1;…; fMÞ ∈ ZM2 ð10Þ

of lengthM called the flow control bits (or just “flow bits”).
At this point, we still have to quantify the value ofM. Note,
though, that it represents the number of bits needed to
enumerate all the possible combinations of input and output
that satisfy the g-flow conditions [44,47]. Hence, for a fixed
total order of the measurements, it is a function of N.
Explicitly, the X and Z corrections associated with the
measurement angle of each qubit j are determined by the
dependency sets:

sxj∶ D½b<j� ×D½f� → Z2; ð11Þ

szj∶ D½b<j� ×D½f� → Z2; ð12Þ

where the function D denotes the domain of the argument.
Without loss of generality,we choose sz1 ¼ sx1 ¼ 0 since there
are no previous outcomes onwhich these could depend. For a
fixed open graph GðI; OÞ, the form of the dependency sets is
uniquely defined by the g-flow [4]. Analogously, the flow bits
f fully specify the dependency sets (as functions of b). As
such, the quantum circuit that Alice intends to implement is
specified by the information

ðα; fÞ ∈ AN × ZM2 ; ð13Þ

consisting of N measurement angles and M flow bits for
a given graph with fixed total order of measurement.
Consequently, once the graph G is known, there exists a
one-to-one correspondence GðI; OÞn;m ↔ f, and we can
accordingly denote the corresponding MBQC measure-
ment pattern as follows:

Protocol 1 CDBQC ðG;AÞ: Classically Driven Blind Quantum
Computation.

Protocol parameters:
(i) A graph G with an implicit total ordering of vertices.
(ii) A set of angles A satisfying Eq. (19).

Alice’s input:
(i) A target computation ΔA implemented using MBQC as

ΔMA ¼ fG;α; fg;

representing a measurement pattern on G compatible with
the total ordering of measurements implicit in G, which
describes a unitary embedding ÛA. The set α represents a
sequence of N measurement angles over the graph G, with
each angle chosen from a set A, which is also taken to be a
parameter of the protocol and is known to both parties. The
g-flow construction f fully determines the input state ρin,
through the location of the input and output qubit sets on
the graph (I and O, respectively) and the dependency sets
ðsx; szÞ.

Steps of the protocol:
1. State preparation

(a) Bob prepares the graph state jGi.
2. Measurements

For i ¼ 1;…; N, repeat the following:
(a) Alice picks a binary digit ri ∈ Z2 uniformly at random.

Then, using ri, sx, sz, and the function in Eq. (18), she
computes the angle α0i. Alice transmits α

0
i to Bob.

(b) Bob measures the ith qubit in the basis fj�α0iig and
transmits to Alice the measurement outcome b0i ∈ Z2.

(c) Alice records bi ¼ b0i ⊕ ri in b and then updates the
dependency sets ðsx; szÞ. If i ∈ O, then she also records
bi in pCB .

3. Post-processing of the output
(a) Alice implements the final round of corrections on the

output string by calculating p ¼ pC ⊕ sZO, with sZO
the set of Z corrections on the output at the end of the
protocol.

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-5



ΔMA ¼ ðGn;m;α; fÞ: ð14Þ

Explicitly, note that by choosing f, Alice is defining a
unique choice of the input and output on the graph state
before the protocol begins. In line with the computation
description from Eq. (3), we call ρI the input state on G.
We now turn our attention to what kind of information

Bob receives when Alice asks him to perform the mea-
surements on her behalf. The interactive part of the protocol
consists of N steps. At each step i, Alice requests Bob to
measure, in the XY-plane of the Bloch sphere, the ith qubit,
according to the total order implied by G, and he sends back
a bit for each measurement. We identify the measurement
instructions Bob receives as a list of angles

α0 ≔ ðα01;…; α0NÞ ∈ AN; ð15Þ

and we label the string of bits Alice receives from Bob as

b0 ≔ ðb01;…; b0NÞ ∈ ZN2 ; ð16Þ

while remembering that they are communicated alternately
(α01 to Bob, b

0
1 to Alice, α

0
2 to Bob, b

0
2 to Alice, etc.). Note

that in the case of a dishonest Bob, the string b0 does not
need to correspond to real measurement outcomes but
could have been generated by Bob through some alternative
process.
Realizing thatmeasuring α can just as easily be effected by

asking Bob to measure αþ π and then flipping the returned
outcome bit, we introduce a uniformly random N-bit string

r ≔ ðr1;…; rNÞ ∈ ZN2 ð17Þ

that Alice will use to pad the angles in an attempt to conceal
the measurement outcomes. All that remains is to specify
how α0 depends on α. This is specified by the following
functional dependence [17,47,48]:

α0 ¼ ð−1Þsxαþ ðsz þ rÞπ mod 2π; ð18Þ

which follows from the g-flow construction and shows how
corrections change subsequent measurement angles. Here,
we have used multi-index notation to present the result
concisely as a vector. Note that the dependency sets ðsx; szÞ
are updated by Alice after each measurement. To make the
analysis of the protocol meaningful, we construct a domain
forα such that the domain of all validα0 is the same. Thus, in
general,

A ¼ fð−1Þxθ þ zπjθ ∈ A; x ∈ Z2; z ∈ Z2g: ð19Þ

Also note that now

b0 ¼ b ⊕ r; ð20Þ

where ⊕ indicates addition modulo 2 for each bit. We
can identify the data that Bob receives during the interactive
part of the protocol (some from Alice, some from his own
measurements) as

ðdata Bob receivesÞ ≔ ðb0;α0Þ ∈ ZN2 ×AN: ð21Þ

The interactive part of the protocol ends when all the
qubits have been measured and Alice holds the binary
register b, derived from b0 to account for the one-time pad
r. Since Alice knows the output set O, whenever the ith
qubit belongs to the set of output qubits, Alice saves bi into
a second binary sequence of length jOj:

pCB ≔ ðp1;…; pjOjÞ ∈ ZjOj2 ; ð22Þ

where pi ¼ bi, ∀i ∈ O. If Bob is honest, then pCB is
equivalent to pC. At the end of the protocol, this string
contains the classical result of the computation, up to
classical post-processing. This is accounted for by calcu-
lating p ¼ pC ⊕ sZO, where sZO is used to represent the final
set of Z corrections on the output qubits. Clearly, the
classical nature of the client allows us to consider only
quantum computations with classical output.
In order for the protocol to have any utility, we require

that the output p satisfies Eq. (4), a property known as
correctness. The correctness of this protocol can be proved
straightforwardly. Note that the positive branch of the
MBQC pattern ΔMA [that is, where all the measurement
outcomes happen to be equal to zero (b ¼ 0)] implements
Alice’s target computation ΔA by definition. In the circuit
model, this corresponds to a quantum circuit that imple-
ments the unitary ÛA over the correct input state ρI and a
final round of measurements whose output is the binary
string p [49]. Below, we give a proof of the correctness of
the CDBQC protocol.
Theorem 1. [correctness] For honest Alice and Bob, the

outcome of Protocol 1 is correct.
Proof.—There are only two differences between Protocol

1 and a conventional MBQC implementation of ΔMA .
The first is the use of r to hide measurement outcomes.
The effect of r is to add an additional π to the measurement
angle on certain qubits, resulting in a bit flip on the
corresponding measurement result b0i. However, since this
is immediately undone, it has no effect on the statistics of
the measurement results obtained after decoding b.
The other difference is that the g-flow construction, and

hence the dependency sets, is only known to Alice and not to
Bob. However, this does not affect the input state, which is
equivalent to the usual case if Alice is honest (i.e., if she
correctly performs her role in implementing the protocol).
Furthermore, if Alice updates the measurement angles
correctly using the dependency sets as dictated by the
g-flow, and Bob measures them accordingly, every branch

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-6



of ΔMA is equivalent to the positive branch. Then, the
measurement pattern correctly implements the unitary trans-
formation ρout ¼ ÛAρinÛ†A. The protocol also allows Alice to
identify the elements of the output string pC in b since she
knows thepositionof theoutputon thegraph.Hence,whenboth
Alice and Bob follow the protocol, the output stringp ¼ pC ⊕
sZO is the desired probability distribution that follows from the
joint measurement of the correct quantum output. □

IV. BLINDNESS ANALYSIS

We now look at the degree of blindness for a single round
of Protocol 1. In this setting, we consider a cheating Bob
with unbounded computational power, able to deviate from
the protocol and follow any strategy allowed by the laws of
physics. Our aim, however, is not to verify that Bob is
indeed performing the correct quantum computation as
requested. Instead, we want to quantify the amount of
information that Bob can access when Protocol 1 is run
only once (stand-alone) and compare it against the total
amount of information needed to describe the computation.
To completely identify Alice’s computation, Bob needs to
know the description ΔMA .
We identify variables with uppercase letters and particular

instances of such variables with lowercase letters. The
probability of a given instance x of a random variable X is
denoted PrðxÞ, and averaging over X is denoted h·iX or h·i
when there is no ambiguity. Given a random variable X, we
callNX the number of possible outcomes for the variable and
nX ≔ log2NX the number of bits required to enumerate them.
We denote the Shannon entropy [50] of a random

variable X by HðXÞ ≔ h− log2 PrðxÞiX ≤ nX, with equal-
ity if and only if X is uniformly random. For two ran-
dom variables X and Y, their joint entropy is written
HðX;YÞ ≔ h−log2 Prðx; yÞiX;Y , and the conditional en-
tropy of X given Y is HðXjYÞ ≔ h−log2 PrðxjyÞiX;Y .
These satisfy

HðXjYÞ ¼ HðX;YÞ −HðYÞ: ð23Þ

The mutual information of X and Y is

IðX;YÞ ≔ HðXÞ þHðYÞ −HðX;YÞ
¼ HðXÞ −HðXjYÞ
¼ HðYÞ −HðYjXÞ; ð24Þ

which will be our main tool of analysis. Intuitively, IðX;YÞ
measures how much information Y has about X. More
precisely, it quantifies how much the entropy of X is
reduced, on average, when the value of Y is known.
Because of the symmetry of the definition, these statements
also hold when the roles of X and Y are swapped.
Let us call the angles variable A and the flow variable F.

Specifying ΔMA , in general, therefore requires nA þ nF bits.

In addition, we use B for the eventual measurement
outcomes and R for the (uniformly random) string of
π-shift bits that is known only to Alice. In any given run of
the protocol, A and F are drawn from a joint prior
probability Prðα; fÞ, which is known to Bob. Thus,
HðA;FÞ ≤ nA þ nF bits, with equality if and only if the
prior is uniform over F and A. Note that we do not make
any assumptions about this prior in what follows.
We have seen before that a single instance of the data

Bob receives at the end of Protocol 1 is equal to ðG;b0;α0Þ.
In a stand-alone setting, this is the only data available to
Bob from which he might be able to gain some information
about the circuit chosen by Alice. If this protocol were to be
used as a subroutine or in parallel with another protocol,
then one must analyze the security in a composable
framework. Such an analysis is beyond the scope of the
present work and is left as an open problem. Note that the
graph is considered a parameter of the protocol and not part
of Alice’s secret. Bob’s useful information at the end of a
single run of Protocol 1 is then equal to the mutual infor-
mation IðB0;A0;A;FÞ between the variables associated
with the circuit ðA;FÞ and Bob’s data ðB0;A0Þ.
In other words, we are modeling the leakage of

information as an unintentional classical channel between
Alice and Bob, where ðA;FÞ is the input of the channel
and ðB0;A0Þ is the output at Bob’s side. Then, the mutual
information tells us how many bits of the original mes-
sage Bob receives on average, when averaged over many
uses of the channel. Importantly, one cannot recover, from
mutual information, what bits of the original message are
passed to Bob. For our protocol, the mutual information
satisfies the following bound, which does not rely on any
computational assumption but is entirely derived from
information theory.
Theorem 2. [blindness] In a single instance of Protocol

1, the mutual information between the client’s secret input
fα; fg and the information received by the server is
bounded by

IðB0;A0;A;FÞ ≤ HðA0Þ: ð25Þ

Proof.—From the definition of mutual information, we
have

IðB0;A0;A;FÞ ¼ HðB0;A0Þ −HðB0;A0jA;FÞ:
Applying the inequality HðX;YÞ ≤ HðXÞ þHðYÞ,
together with the fact that HðB0Þ ≤ nB0 ¼ N, to the above
equation yields

IðB0;A0;A;FÞ ≤ HðA0Þ þ N −HðB0;A0jA;FÞ: ð26Þ
What remains to be shown is that HðB0;A0jA;FÞ ≥ N.
This result is proved as Lemma 4 in the Appendix by
bounding Prðb0;α0jα; fÞ ≤ 2−N based on the full joint
probability for the protocol. With this bound in place,
Eq. (25) directly follows. □

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-7



The conditional entropy HðA;FjB0;A0Þ quantifies the
amount of information that, on average, remains unknown
to Bob about Alice’s computation at the end of Protocol 1.
As mentioned previously, in the case where Alice chooses
the measurement angles A uniformly randomly from a
finite set, one Aj for each qubit, and she chooses the flow F
uniformly randomly from the set of all flows compatible
with the total order implicit in G, then

HðA;FÞ ¼ nA þ nF: ð27Þ
In this case, by calculating the conditional entropy

HðA;FjB0;A0Þ ¼ HðA;FÞ − IðB0;A0;A;FÞ; ð28Þ
we have HðA;FjB0;A0Þ ≥ nF because of Theorem 2. Note
that Theorem 2 guarantees zero mutual information for a
single run of Protocol 1 only if nA ¼ 0, which means only
one choice of measurement angle for each qubit. However,
the structure of the domain of α and α0 [see Eq. (19)]
forbids such a choice. A minimal choice of angles that is
not classically simulable (via the Gottesman-Knill theorem
[51]) is given by

A ¼
�
π

4
;
3π

4
;
5π

4
;
7π

4

�
: ð29Þ

In this case, for each angle αj, one has nαj ¼2, so nA¼2N.
Since HðA0Þ ≤ nA0 ¼ nA, Bob gains at most two bits of
information per qubit measured, with this information
being a nontrivial function of both α and f.

V. APPLICATION TO CLUSTER STATES

To conclude the security analysis of the stand-alone
scenario, it is necessary to calculate the exact value of NF,
which in turn gives us the value of nF and hence the lower
bound of the conditional entropy for the case of uniform
variables A, F as explained above. Clearly, this depends on
the choice of G. Here, we consider the case of cluster states,
where G is taken to be Gn;m with implicit total ordering of
vertices as illustrated in Fig. 1. Note that M, the length of
the bit string f, is equal to log2NF. When condition (G4) is
included, the g-flows we consider correspond to focused
g-flows [52]. Hence, there is a one-to-one correspondence
between an instance of a g-flow f of F and a choice of input
and output sets on the graph [52]. Here, we place a lower
bound on M by counting flows that satisfy conditions
(G1)–(G4). The use of the additional constraint (G4), which
is not implicit in the definition of g-flow, implies that we are
undercounting the total number of flows; hence,

NF ≥ #GðI; OÞn;m; ð30Þ
where #GðI; OÞn;m corresponds to the number of possible
ways one can define an open graph that satisfies conditions
(G1)–(G4). We now show that this quantity can grow

exponentially in the dimensions of the cluster state such
that nF ∝ N.
Theorem 3. For a cluster state corresponding to Gn;m

with fixed total order as depicted in Fig. 1, the number
of different open graphs GðI; OÞ satisfying conditions
(G1)–(G4) is given by

#GðI; OÞn;m ¼ Fjn−mj2minðn;mÞþ1
Yminðn;mÞ
μ¼2

F22μ; ð31Þ

where Fi is the ith Fibonacci number.
Proof.—The proof of this theorem is somewhat involved.

We begin by considering a set of diagonal cuts acrossGn;m, as
depicted in Fig. 2(a). As we are considering only those flows
that satisfy condition (G4), there is a straightforward con-
straint on the information flow,which can be seen by isolating
a single cut and thevertices linked byedges that the cut passes
through [see Fig. 2(b)]. In the following discussion, we
consider only the vertices connected by edges through which
a particular cut passes. Because of the total ordering imposed
on the vertices of Gn;m, conditions (G1)–(G3) ensure that
information can only pass through a cut from the left side to
the right side and not in the reverse direction. Condition (G4)
then allows exactly the set of flows where for any vertex k on
the right side of the cut, information flows to k from at

(a)

(b)

FIG. 2. (a) A cluster-state graph Gn;m with diagonal cuts
imposed. The flow across each cut is independent, and the
number of possible flows across each cut is indicated. (b) Several
cuts with their neighboring vertices isolated.

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-8



most one of its neighbors on the left side of the cut. So,
if i, j ∈ N ðkÞ, then k ∉ gðiÞ ∩ gðjÞ.
We divide the cuts into three types: (i) those having one

less neighboring vertex on the left side of the cut than on
the right, (ii) those having one more neighboring vertex on
the left side of the cut than on the right, and (iii) those
having an equal number of neighboring vertices on both
sides of the cut. We label the total number of flows for each
type as Aμ, Bμ, and Cμ, respectively, where μ indicates the
number of neighboring vertices on the left side of the cut, as
shown in Fig. 2(b).
In order to quantify these, we begin by noting that

Aμ ¼ A→μ þ A→μ , where A→μ denotes the number of flows
with the restriction that information flows from the upper-
most neighboring vertex on the left side of the cut to the
uppermost neighboring vertex on the right side of the cut,
and A→μ denotes the number of flows where this constraint
is not satisfied. These quantities can be calculated using a
simple recursion relation, as follows.
Here, A→μ allows precisely one possibility for flow

between the uppermost vertices of the cut, precluding
flow from the uppermost vertex on the left side of the
cut to lower vertices on the right side. Hence, the remaining
μ − 1 vertices on the left side and μ − 1 on the right side will
be isolated and identical to the situation where the cut
partitions one fewer vertex on each side. Thus,A→μ ¼ Aμ−1 ¼
A→μ−1 þ A→μ−1.
Calculating A→μ is a little more involved, as there are two

possibilities to consider. The first is that no information
flows from the uppermost vertex on the left side of the cut
across the cut (in which case, it is an output). In this case,
isolation of the lower vertices occurs as in the analysis ofA→μ ;
hence, there are A→μ−1 þ A→μ−1 possible flows. In the second
case, no information can flow into the second uppermost
vertex on the right side of the cut; hence, onlyA→μ−1 flows are
possible. Thus, A→μ ¼ A→μ−1 þ 2A→μ−1 ¼ A→μ þ A→μ−1. These
correspondences are depicted in Fig. 3.
Note that A→μ and A→μ satisfy the same recursion relation

as the Fibonacci sequence when ordered as ðA→1 ; A→1 ;
A→2 ; A

→
2 ;…Þ and starting with A→1 ¼ 1 ¼ F2 and A→1 ¼

2 ¼ F3. It follows that Aμ ¼ F2μþ2. By similar arguments,
we have Bμ ¼ F2μ and Cμ ¼ F2μþ1.
It remains only to be noted that the configuration of the

information flow across one cut is independent of the
information flow across other cuts; hence, the total number
of possible flows is given by the product of the possible
flows across each cut. Therefore,

#GðI; OÞn;m

¼
� Yminðn;mÞ−1

μ¼1
F2μþ2

�
Fjn−mj
2minðn;mÞþ1

� Yminðn;mÞ
ν¼2

F2ν

�
; ð32Þ

which simplifies to Eq. (31) as required. □

The Fibonacci numbers can bewritten exactly in terms of
the golden ratio ϕ ¼ 1

2
ð1þ ffiffiffi5p Þ as

Fk ¼
ϕk − ð−ϕÞ−kffiffiffi

5
p : ð33Þ

For large cluster states (n, m ≫ 1), the number of possible
flows is given by

#GðI; OÞn;m ≈ 5−jn−mj=2ϕð2λþ1Þjn−mj
Yλ
ν¼2

ϕ4ν

5
ð34Þ

¼ 5−ðnþm−2Þ=2ϕ2mnþmþn−4; ð35Þ
where λ ¼ minðn;mÞ. The above approximation is
obtained by noting that Fk ≈ ϕk=

ffiffiffi
5

p
, since jð−ϕÞ−kj≪1

for large k, and using this to approximate Eq. (31).
Taking N ¼ nm and assuming m grows polynomially in

n, then m ¼ polyðnÞ, and

#GðI; OÞn;m ¼ 22N log2 ϕþOðNϵÞ ð36Þ

for some ϵ < 1. In such a case, using Eq. (30) and
evaluating to leading order,

nF ≥ log2#GðI; OÞn;m ≈ 1.388N: ð37Þ

This result implies that the conditional entropy
HðA;FjB0;A0Þ ≥ 1.388N. For the case of a computation
chosen uniformly at random by Alice, the total number
of bits required to entirely describe her computation is
approximately equal to 3.388N. However, Bob only
receives exactly 2N bits of information from Alice (the
angles α0). From Theorem 2.1 in Ref. [53], it is easy to
verify that Bob cannot decode Alice’s computation entirely
with unit probability. Additionally, Theorem 2.4 in
Ref. [54] shows that Bob cannot guess Alice’s computation
with probability greater than 2−1.388N .
To make sense of this result, one should remember

that a particular deterministic MBQC computation is

FIG. 3. A→μ and A→μ can be constructed recursively, as shown
above. Here, arrows indicate information flow, while edges
indicate the possibility of information flow.

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-9



characterized by identifying an input and output set on the
underlying graph of the resource state, together with an
information flow construction. This structure determines
how the quantum information is deterministically trans-
ferred via projective measurements from the physical
location of the input to the output. Furthermore, once
the input and output systems are fixed on the graph, the
flow, if it can be constructed, is unique. Hence, in the
canonical approach to MBQC, the usual procedure is to fix
the input and the output and assign a partial order of
measurements that guarantees determinism under a specific
set of rules. Consequently, the flow construction imposes a
total order of measurements, which must respect the
partial one.
Here, we have reversed this point of view. As such,

Theorem 3 is based on the nontrivial observation that, for a
given MBQC resource state with a fixed total order of
measurements, choices of g-flow, i.e., choices of input and
output vertices on the graph that correspond to different
deterministic quantum computations, are generally not
unique. Nonetheless, Alice’s choice of input and output
enforces a unique computation among all the possible
choices. This choice of g-flow is not communicated to the
server and is kept hidden by Alice, who uses it to update
the classical instructions sent to Bob. This observation
makes it possible for a client to conceal the flow of
quantum information from a quantum server classically
instructed on what operations to perform. In particular,
since a large number of other computations are still
compatible with the information Bob receives, the
achieved blindness follows from the ambiguity about
the flow of information on the graph. Furthermore, our
protocol circumvents the scheme-dependent no-go theo-
rem for classical blind quantum computing stated in
Ref. [38]. Here, we do not make use of any affine
encryption on the client’s side, but as mentioned above,
we use flow ambiguity to encode a part of the client’s
computation. As a consequence of this encoding, Protocol
1 requires multiple rounds of communication between the
client and server. This requirement is in direct contrast with
the assumptions of Ref. [38], where only one round of
communication is allowed.
We can additionally make two important observations.

The first is that the circuits implementable on Gn;m are not
classically simulable unless BPP ¼ BQP. This stems from
the fact that the cluster state is universal with only XY-plane
measurements, as has recently been proven in Ref. [55].
The above bound provides an exponential lower bound on
the number of consistent flows for all cluster states. The
second observation is that the computations corresponding
to different choices of flow are not equivalent, even when
classical post-processing is allowed. This can most easily
be seen by considering an example. We consider the
simplest case of the 2 × 2 plaquette jCSi2;2. In Fig. 4,
we show an example of two different choices of open

FIG. 5. List of the nine possible GðI; OÞ2;2 combinations
(and associated patterns) with g-flow for the cluster state
jCSi2;2. The arrows indicate the direction of the quantum
information flow. Note that overlapping input and output sets
are allowed. All the patterns implement unitary embeddings on
the input state.

FIG. 4. A 2 × 2 cluster state with measurement angles
fα; β; γ; δg. In this example, we show how to encode two
different computations using a fixed total order of measure-
ments f1; 2; 3; 4g. The difference follows from the choice of
the GðI; OÞ. In diagram (a), the input set is f1; 3g, and the
output set is f2; 4g, with g-flow function gð1Þ ¼ f2g and
gð3Þ ¼ f4g. The equivalent circuit associated with the positive
branch of this MBQC pattern is shown below. Note that any
final round of corrections is pushed into the classical post-
processing of the output. In diagram (b), the input set is
f1; 2g, the output set is f3; 4g, gð1Þ ¼ f3g, and gð2Þ ¼ f4g.
Similarly to (a), we show the circuit of the positive branch of
the MBQC pattern, and the final round of corrections is
classically post-processed.

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-10



graphs compatible with the underlying total order of
measurements. Both choices satisfy the g-flow conditions,
and as a result, they correspond to two deterministic
MBQC patterns, i.e., two different and well-defined

computations. Since in this particular case the input state
(ĈZjþþi) is equivalent, the difference is dictated by the
unitary transformation (specified by the measurement
angles) that acts on it. As can be seen from Fig. 4, the
corresponding circuits are different and perform different
unitaries. Because of the flow ambiguity and the obfusca-
tion due to the one-time pad, a quantum server that was to
perform the measurements following Protocol 1, at the end
of the procedure, would not have enough information to
exactly identify Alice’s choice of open graph. For G2;2,
there are nine possible flow configurations as expected
from Eq. (31), which are depicted in Fig. 5. Given any fixed
transcript of the protocol, for each flow there exists a choice
of α such that it is consistent with the transcript. An
example run of Protocol 1 is presented in Fig. 6 for the
G2;2 case.
As a final comment, it is clear that there exist cases

where, for a fixed graph and choice of angles, different
choices of flows will correspond to the same computation.
For instance, referring to Fig. 5, measuring all qubits with
the same angle would give a two-to-one correspondence for
some of the computations. However, it is reasonable to
conjecture that when the angles are chosen from sets of
large cardinality, the mapping will be close to one to one.
The full characterization of the mapping is left as an open
problem.

VI. DISCUSSION AND CONCLUSIONS

Our overall motivation in this work has been to explore
the possibility of classically driven blind quantum com-
putation. While this may seem an impossible task, the fact
that multiple nonequivalent computations in the MBQC
model can yield the same transcript of measurement
angles and results, even when the resource state and
order of measurements are fixed, allows the tantalizing
possibility that it may be possible for a classical user to
hide a computation from a quantum server. Protocol 1
makes use of this flow ambiguity to provide some
measure of hiding for quantum computations chosen
from certain restricted sets. Our intention in introducing
this protocol is not to provide a practical cryptographic
protocol but rather to demonstrate that it is indeed
possible to hide nonequivalent quantum computations
using this flow ambiguity. As such, we concentrate on
showing that in a single run of the protocol, the amount of
information obtained by the server is bounded, rather than
introducing a composable security definition, which is
nontrivial given the dependence of the leaked information
on the responses of the server.
Our results provoke a couple of questions. The first and

most obvious is whether the flow ambiguity effect can be
exploited to hide a universal set of computations even after
the measurement angles have been communicated to the
server. A second and perhaps even more important question
is whether this phenomenon can be used as a building block

FIG. 6. Illustration of an exemplary run of Protocol 1. At the start
of the protocol, Alice’s computation is expressed as a measurement
pattern on a graph, in this case, G2;2. This is communicated to Bob,
who prepares the initial state. The computation then proceeds in
rounds with Alice computing the relevant entries of sx and sz and,
using these together with ri, the measurement angle α0i. The
measurement angle α0i is communicated to Bob, who performs
the measurement and returns the result to Alice as b0i. From this,
Alice computesbi asb0i ⊕ ri. This process is repeated until all qubits
have been measured. At the end of the protocol, for any fixed
transcript of the communication (composedofα0 andb0), it is always
possible to find a choice for α consistent with the transcript for any
choice of f. In other words, for any of the possible g-flow
configurations shown in Fig. 5, Bob can find an α that would have
led to the transcript he recorded, whichmeans any of those g-flows is
possible. This ambiguity is responsible for partially hiding Alice’s
computation from Bob.

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-11



for verification of quantum computers by completely
classical users.

ACKNOWLEDGMENTS

The authors thank Rafael Alexander, Niel de Beaudrap,
Michal Hajdušek, Elham Kashefi, Simon Perdrix, and
Carlos Pérez-Delgado for interesting discussions and
valuable insights. T. F. D. thanks Yingkai Ouyang for
carefully reading an early version of this manuscript
and for his helpful comments. J. F. F. acknowledges
support from the Air Force Office of Scientific Research
under Grant No. FA2386-15-1-4082. N. C. M. is supported
by the Australian Research Council under Grant
No. DE120102204, by the Australian Research Council
Centre of Excellence for Quantum Computation and
Communication Technology (Project No. CE170100012),
and by the U.S. Defense Advanced Research Projects
Agency (DARPA) Quiness program under Grant
No.W31P4Q-15-1-0004. This material is based on research
funded by the Singapore National Research Foundation
under NRF Award No. NRF-NRFF2013-01.

A. M. and T. F. D. contributed equally to this work.

APPENDIX: FULL JOINT PROBABILITY FOR
THE PROTOCOL AND CONDITIONAL

ENTROPY BOUND

Lemma 4. HðB0;A0jA;FÞ ≥ N regardless of Bob’s
strategy.
Proof.—We construct the full joint probability for all of

the variables in Protocol 1 and use it to explicitly derive
the desired result. Direct dependencies in the joint
probability will be limited by causality and the assump-
tions that Alice’s and Bob’s laboratories are secure and
free of each others’ espionage. These limitations are as
follows:

(i) The flow bits F and ideal measurement angles A
directly depend on no other variables. They are
inputs to the problem chosen by Alice and can be
correlated.

(ii) Each π-shift bit Rj in R is chosen by flipping a fair
coin; thus, it directly depends on no other variables.

(iii) Alice assigns A0j based directly on the current Aj, all
flow bits F, the current Rj, and any prior decoded
bits B<j.

(iv) Each decoded bit Bj directly depends only on Rj
(the π-shift bit) and the bit B0j received from Bob.

(v) Each bit B0j that Bob returns to Alice directly
depends only on the information Bob has on hand
at the time (specifically,B0<j andA

0
≤j), as well as any

(classical or quantum) stochastic strategy he wishes
to employ.

With these direct-dependency limitations, we can
immediately write down the form of the full joint
probability for the entire protocol:

Prðb0;α0;α; f;b; rÞ

¼ Prðα; fÞ
YN
j¼1

Prðb0jjb0<j;α0≤jÞ Prðα0jjαj; f;b<j; rjÞ

× Prðbjjb0j; rjÞ PrðrjÞ: ðA1Þ

Furthermore, we can explicitly write several of these
probabilities:

Prðbjjb0j; rjÞ ¼ δbjb0j⊕rj ; ðA2Þ

Prðα0jjαj; f;b<j; rjÞ ¼ δ
α0j
Gjðαj;f;b<j;rjÞ; ðA3Þ

PrðrjÞ ¼
1

2
; ðA4Þ

with the deterministic function

Gjðαj; f;b<j; rjÞ
≔ ð−1Þsxj ðf;b<jÞαj þ πszjðf;b<jÞ þ πrj mod 2π ðA5Þ

obtained from Eq. (18). These hold for all j. At this point,
we have the most general form of the full joint probability
consistent with the protocol:

Prðb0;α0;α; f;b; rÞ

¼ Prðα; fÞ
2N

δbb0⊕r
YN
j¼1

Prðb0jjb0<j;α0≤jÞδ
α0j
Gjðαj;f;b<j;rjÞ; ðA6Þ

where we have left Bob’s strategy arbitrary but consistent
with the direct-dependency restrictions given above.
Marginalizing over B gives

Prðb0;α0;α; f; rÞ
¼

X
b

Prðb0;α0;α; f;b; rÞ ðA7Þ

¼ Prðα; fÞ
2N

YN
j¼1

Prðb0jjb0<j;α0≤jÞδ
α0j
Gjðαj;f;b0<j⊕r<j;rjÞ: ðA8Þ

From this joint probability distribution, we can
compute

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-12



Prðb0;α0jα; fÞ ¼
X
r

Prðb0;α0;α; f; rÞ
Prðα; fÞ ðA9Þ

¼ 1
2N

X
r1

…
X
rN−2

X
rN−1

X
rN

YN
j¼1

Prðb0jjb0<j;α0≤jÞδ
α0j
Gjðαj;f;b0<j⊕r<j;rjÞ ðA10Þ

¼ 1
2N

�YN
j¼1

Prðb0jjb0<j;α0≤jÞ
�X

r1

…
X
rN−2

X
rN−1

�YN−1
j¼1

δ
α0j
Gjðαj;f;b0<j⊕r<j;rjÞ

�

× ðδα0NGjðαN;f;b0<N⊕r<N;0Þ þ δ
α0N
GjðαN;f;b0<N⊕r<N;1ÞÞ|fflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflffl{zfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflffl}

at most one term is nonzero

ðA11Þ

≤
1

2N

�YN
j¼1

Prðb0jjb0<j;α0≤jÞ
�X

r1

…
X
rN−2

X
rN−1

YN−1
j¼1

δ
α0j
Gjðαj;f;b0<j⊕r<j;rjÞ ðA12Þ

≤
1

2N

�YN
j¼1

Prðb0jjb0<j;α0≤jÞ
�X

r1

…
X
rN−2

YN−2
j¼1

δ
α0j
Gjðαj;f;b0<j⊕r<j;rjÞ ðA13Þ

..

.

≤
1

2N

�YN
j¼1

Prðb0jjb0<j;α0≤jÞ
�X

r1

δ
α0
1

G1ðα1;f;r1Þ ðA14Þ

≤
1

2N

YN
j¼1

Prðb0jjb0<j;α0≤jÞ ðA15Þ

≤
1

2N
: ðA16Þ

In the above, we have repeatedly used the fact that Gj has
at most one rj that makes it equal to α0j for any given
ðαj; f;b<jÞ. Therefore, substituting the above bound into
the conditional entropy formula gives

HðB0;A0jA;FÞ ¼
X
α;f

Prðα; fÞHðB0;A0jA ¼ α;F ¼ fÞ

≥
X
α;f

Prðα; fÞN ¼ N: ðA17Þ
□

[1] P. W. Shor, Polynomial-Time Algorithms for Prime
Factorization and Discrete Logarithms on a Quantum
Computer, SIAM Rev. 41, 303 (1999).

[2] S. Lloyd, Universal Quantum Simulators, Science 273,
1073 (1996).

[3] S. Lloyd, M. Mohseni, and P. Rebentrost, Quantum Algo-
rithms for Supervised and Unsupervised Machine Learning,
arXiv:1307.0411 [Phys. Rev. X (to be published)].

[4] V. Dunjko, J. Fitzsimons, C. Portmann, and R. Renner,
Advances in Cryptology—ASIACRYPT 2014 (Springer,
Berlin, Heidelberg, 2014).

[5] Formal definitions of blindness and verifiability can be
found in [4].

[6] A. Childs, Secure Assisted QuantumComputation, Quantum
Inf. Comput. 5, 456 (2005).

[7] P. Arrighi and L. Salvail, Blind Quantum Computation, Int.
J. Quantum. Inform. 04, 883 (2006).

[8] A. Broadbent, J. Fitzsimons, and E. Kashefi, Universal
Blind Quantum Computation, in Proceedings of the 50th
Annual IEEE Symposium on Foundations of Computer
Science (FOCS) (IEEE, Atlanta, 2009), pp. 517–526.

[9] T. Morimae and K. Fujii, Blind Topological Measurement-
Based Quantum Computation, Nat. Commun. 3, 1036
(2012).

[10] T. Sueki, T. Koshiba, and T. Morimae, Ancilla-Driven
Universal Blind Quantum Computation, Phys. Rev. A 87,
060301 (2013).

[11] C.-H. Chien, R. V. Meter, and S.-Y. Kuo, Fault-Tolerant
Operations for Universal Blind Quantum Computation,
J. Emerg. Technol. Comput. Syst. 12, 26 (2015).

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-13

https://doi.org/10.1137/S0036144598347011
https://doi.org/10.1126/science.273.5278.1073
https://doi.org/10.1126/science.273.5278.1073
http://arXiv.org/abs/1307.0411
https://doi.org/10.1142/S0219749906002171
https://doi.org/10.1142/S0219749906002171
https://doi.org/10.1038/ncomms2043
https://doi.org/10.1038/ncomms2043
https://doi.org/10.1103/PhysRevA.87.060301
https://doi.org/10.1103/PhysRevA.87.060301
https://doi.org/10.1145/2700248


[12] A. Mantri, C. Perez-Delgado, and J. Fitzsimons, Optimal
Blind Quantum Computation, Phys. Rev. Lett. 111, 230502
(2013).

[13] V. Giovannetti, L. Maccone, T. Morimae, and T. Rudolph,
Efficient Universal Blind Quantum Computation, Phys.
Rev. Lett. 111, 230501 (2013).

[14] C. Perez-Delgado and J. Fitzsimons, Iterated Gate
Teleportation and Blind Quantum Computation, Phys.
Rev. Lett. 114, 220502 (2015).

[15] T. Morimae, Continuous-Variable Blind Quantum Compu-
tation, Phys. Rev. Lett. 109, 230502 (2012).

[16] V. Dunjko, E. Kashefi, and A. Leverrier, Blind Quantum
Computing with Weak Coherent Pulses, Phys. Rev. Lett.
108, 200502 (2012).

[17] J. Fitzsimons and E. Kashefi, Unconditionally Verifiable
Blind Computation, arXiv:1203.5217 [Phys. Rev. X (to be
published)].

[18] M. Hajdušek, C. Perez-Delgado, and J. Fitzsimons, Device-
Independent Verifiable Blind Quantum Computation,
arXiv:1502.02563v1 [Phys. Rev. X (to be published)].

[19] A. Gheorghiu, E. Kashefi, and P. Wallden, Robustness and
Device Independence of Verifiable Blind Quantum Comput-
ing, New J. Phys. 17, 083040 (2015).

[20] T. Morimae and K. Fujii, Blind Quantum Computation
Protocol in which Alice Only Makes Measurements, Phys.
Rev. A 87, 050301 (2013).

[21] T. Morimae, Verification for Measurement-Only Blind
Quantum Computing, Phys. Rev. A 89, 060302 (2014).

[22] M. Hayashi and T. Morimae, Verifiable Measurement-Only
Blind Quantum Computing with Stabilizer Testing, Phys.
Rev. Lett. 115, 220502 (2015).

[23] M.Hayashi andM.Hajdusek,Self-GuaranteedMeasurement-
Based Quantum Computation, arXiv:1603.02195 [Phys.
Rev. X (to be published)].

[24] S. Barz, E. Kashefi, A. Broadbent, J. Fitzsimons, A.
Zeilinger, and P. Walther, Demonstration of Blind Quantum
Computing, Science 335, 303 (2012).

[25] S. Barz, J. Fitzsimons, E. Kashefi, and P. Walther, Exper-
imental Verification of Quantum Computation, Nat. Phys. 9,
727 (2013).

[26] C. Greganti, M.-C. Roehsner, S. Barz, T. Morimae, and P.
Walther, Demonstration of Measurement-Only Blind
Quantum Computing, New J. Phys. 18, 013020 (2016).

[27] D. Aharonov, M. Ben-Or, and E. Eban, in Proceedings of
Innovations in Computer Science (Tsinghua University
Press, Beijing, 2010).

[28] A. Broadbent, How to Verify a Quantum Computation,
arXiv:1509.09180.

[29] B. Reichardt, F. Unger, and U. Vazirani, Classical Com-
mand of Quantum Systems, Nature (London) 496, 456
(2013).

[30] M. McKague, Interactive Proofs for BQP via Self-Tested
Graph States, Theo. Comput. 12, 1 (2016).

[31] J. F. Fitzsimons and M. Hajdušek, Post Hoc Verification of
Quantum Computation, arXiv:1512.04375 [Phys. Rev. Lett.
(to be published)].

[32] T. Morimae and J. F. Fitzsimons, Post Hoc Verification with
a Single Prover, arXiv:1603.06046 [Phys. Rev. Lett. (to be
published)].

[33] P. Hauke, F. M. Cucchietti, L. Tagliacozzo, I. Deutsch, and
M. Lewenstein, Can One Trust Quantum Simulators?, Rep.
Prog. Phys. 75, 082401 (2012).

[34] M. Cramer, M. B. Plenio, S. T. Flammia, R. Somma,
D. Gross, S. D. Bartlett, O. Landon-Cardinal, D. Poulin,
and Y.-K. Liu, Efficient Quantum State Tomography, Nat.
Commun. 1, 149 (2010).

[35] L. Aolita, C. Gogolin, M. Kliesch, and J. Eisert, Reliable
Quantum Certification of Photonic State Preparations, Nat.
Commun. 6, 8498 (2015).

[36] D. Hangleiter, M. Kliesch, M. Schwarz, and J. Eisert, Direct
Certification of a Class of Quantum Simulations, Quantum
Science Technology 2, 015004 (2017).

[37] M. Walschaers, J. Kuipers, J.-D. Urbina, K. Mayer, M. C.
Tichy, K. Richter, and A. Buchleitner, Statistical Benchmark
for Boson Sampling, New J. Phys. 18, 032001 (2016).

[38] T. Morimae and T. Koshiba, Impossibility of Secure Cloud
Quantum Computing for Classical Client, arXiv:1407.1636.

[39] S. Aaronson, A. Cojocaru, A. Gheorghiu, and E. Kashefi,
On the Implausibility of Classical Client Blind Quantum
Computing, arXiv:1704.08482v1.

[40] V. Dunjko and E. Kashefi, Blind Quantum Computing with
Two Almost Identical States, arXiv:1604.01586.

[41] R. Raussendorf and H. J. Briegel, A One-Way Quantum
Computer, Phys. Rev. Lett. 86, 5188 (2001).

[42] D. Gottesman and I. L. Chuang,Demonstrating the Viability
of Universal Quantum Computation Using Teleportation
and Single-Qubit Operations, Nature (London) 402, 390
(1999).

[43] X. Zhou, D. W. Leung, and I. L. Chuang, Methodology for
Quantum Logic Gate Constructions, Phys. Rev. A 62,
052316 (2000).

[44] D. Browne, E. Kashefi, M. Mhalla, and S. Perdrix,
Generalized Flow and Determinism in Measurement-Based
Quantum Computation, New J. Phys. 9, 250 (2007).

[45] D. Markham and E. Kashefi, Entanglement, Flow and
Classical Simulatability in Measurement Based Quantum
Computation, arXiv:1311.3610.

[46] M. Nielsen and I. Chuang, Quantum Computation and
Quantum Information (Cambridge University Press,
Cambridge, England, 2000).

[47] V. Danos and E. Kashefi, Determinism in the One-Way
Model, Phys. Rev. A 74, 052310 (2006).

[48] V. Danos, E. Kashefi, and P. Panangaden, The Measurement
Calculus, J. ACM 54, 8 (2007).

[49] R. Raussendorf, D. E. Browne, and H. J. Briegel,
Measurement-Based Quantum Computation on Cluster
States, Phys. Rev. A 68, 022312 (2003).

[50] T. M. Cover and J. A. Thomas, Elements of Information
Theory (John Wiley & Sons, New York, 2012).

[51] D. Gottesman, The Heisenberg Representation of Quantum
Computers, arXiv:quant-ph/9807006.

[52] M. Mhalla, M. Murao, S. Perdrix, M. Someya, and P. S.
Turner, Which Graph States are Useful for Quantum
Information Processing?, in Theory of Quantum Compu-
tation, Communication, and Cryptography, edited by D.
Bacon, M. Martin-Delgado, and M. Roetteler, Lecture
Notes in Computer Science Vol. 6745 (Springer, Berlin,
Heidelberg, 2014), p. TQC 2011.

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017)

031004-14

https://doi.org/10.1103/PhysRevLett.111.230502
https://doi.org/10.1103/PhysRevLett.111.230502
https://doi.org/10.1103/PhysRevLett.111.230501
https://doi.org/10.1103/PhysRevLett.111.230501
https://doi.org/10.1103/PhysRevLett.114.220502
https://doi.org/10.1103/PhysRevLett.114.220502
https://doi.org/10.1103/PhysRevLett.109.230502
https://doi.org/10.1103/PhysRevLett.108.200502
https://doi.org/10.1103/PhysRevLett.108.200502
http://arXiv.org/abs/1203.5217
http://arXiv.org/abs/1203.5217
http://arXiv.org/abs/1502.02563v1
https://doi.org/10.1088/1367-2630/17/8/083040
https://doi.org/10.1103/PhysRevA.87.050301
https://doi.org/10.1103/PhysRevA.87.050301
https://doi.org/10.1103/PhysRevA.89.060302
https://doi.org/10.1103/PhysRevLett.115.220502
https://doi.org/10.1103/PhysRevLett.115.220502
http://arXiv.org/abs/1603.02195
http://arXiv.org/abs/1603.02195
https://doi.org/10.1126/science.1214707
https://doi.org/10.1038/nphys2763
https://doi.org/10.1038/nphys2763
https://doi.org/10.1088/1367-2630/18/1/013020
http://arXiv.org/abs/1509.09180
https://doi.org/10.1038/nature12035
https://doi.org/10.1038/nature12035
https://doi.org/10.4086/toc.2016.v012a003
http://arXiv.org/abs/1512.04375
http://arXiv.org/abs/1512.04375
http://arXiv.org/abs/1603.06046
http://arXiv.org/abs/1603.06046
https://doi.org/10.1088/0034-4885/75/8/082401
https://doi.org/10.1088/0034-4885/75/8/082401
https://doi.org/10.1038/ncomms1147
https://doi.org/10.1038/ncomms1147
https://doi.org/10.1038/ncomms9498
https://doi.org/10.1038/ncomms9498
https://doi.org/10.1088/2058-9565/2/1/015004
https://doi.org/10.1088/2058-9565/2/1/015004
https://doi.org/10.1088/1367-2630/18/3/032001
http://arXiv.org/abs/1407.1636
http://arXiv.org/abs/1704.08482v1
http://arXiv.org/abs/1604.01586
https://doi.org/10.1103/PhysRevLett.86.5188
https://doi.org/10.1038/46503
https://doi.org/10.1038/46503
https://doi.org/10.1103/PhysRevA.62.052316
https://doi.org/10.1103/PhysRevA.62.052316
https://doi.org/10.1088/1367-2630/9/8/250
http://arXiv.org/abs/1311.3610
https://doi.org/10.1103/PhysRevA.74.052310
https://doi.org/10.1145/1219092.1219096
https://doi.org/10.1103/PhysRevA.68.022312
http://arXiv.org/abs/quant-ph/9807006


[53] A. Ambainis, A. Nayak, A. Ta-Shma, and U. Vazirani,Dense
Quantum Coding and a Lower Bound for 1-Way Quantum
Automata, in Proceedings of the 31st Annual ACM Sympo-
sium on Theory of Computing, 1999, pp. 376–383.

[54] A. Nayak, Optimal Lower Bounds for Quantum Automata,
and Random Access Codes, in Proceedings of the 40th

Annual Symposium on Foundations of Computer Science
(FOCS ’99) (IEEE Computer Society, Washington, DC,
1999), p. 369.

[55] A. Mantri, T. F. Demarie, and J. F. Fitzsimons, Universality
of Quantum Computation with Cluster States and (X, Y)-
Plane Measurements, Sci. Rep. 7, 42861 (2017).

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017)

031004-15

https://doi.org/10.1038/srep42861

