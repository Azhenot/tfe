


















































Learning Certifiably Optimal Rule Lists for Categorical Data

Elaine Angelino elaine@eecs.berkeley.edu
Department of Electrical Engineering and Computer Sciences
University of California, Berkeley, Berkeley, CA 94720

Nicholas Larus-Stone nlarusstone@college.harvard.edu
Daniel Alabi alabid@g.harvard.edu
Margo Seltzer margo@eecs.harvard.edu
School of Engineering and Applied Sciences
Harvard University, Cambridge, MA 02138

Cynthia Rudin cynthia@cs.duke.edu
Department of Computer Science and Department of Electrical and Computer Engineering

Duke University, Durham, NC 27708

Abstract

We present the design and implementation of a custom discrete optimization technique
for building rule lists over a categorical feature space. Our algorithm provides the optimal
solution, with a certificate of optimality. By leveraging algorithmic bounds, efficient data
structures, and computational reuse, we achieve several orders of magnitude speedup in
time and a massive reduction of memory consumption. We demonstrate that our approach
produces optimal rule lists on practical problems in seconds. This framework is a novel
alternative to CART and other decision tree methods.

Keywords: Rule lists, Decision trees, Optimization, Interpretable models

1. Introduction

As machine learning continues to gain prominence in socially-important decision-making,
the interpretability of predictive models remains a crucial problem. Our goal is to build
models that are both highly predictive and easily understood by humans. We use rule lists,
also known as decision lists, to achieve this goal. Rule lists are lists composed of if-then
statements, which are easily interpreted; the rules give a reason for each prediction (Fig-
ure 1).

Constructing rule lists, or more generally, decision trees, has been a challenge for more
than 30 years; most approaches use greedy splitting techniques (Rivest, 1987; Breiman
et al., 1984; Quinlan, 1993). Recent approaches use Bayesian analysis, either to find a locally
optimal solution (Chipman et al., 1998) or to explore the search space (Letham et al., 2015;
Yang et al., 2016). These approaches achieve high accuracy while also managing to run
reasonably quickly. However, despite the apparent accuracy of the rule lists generated by
these algorithms, there is no way to determine either if the generated rule list is optimal or
how close it is to optimal.

Optimality is important, because there are societal implications for a lack of optimality.
Consider the recent ProPublica article on the COMPAS recidivism prediction tool (Larson
et al., 2016). It highlights a case where a black-box, proprietary predictive model is being
used for recidivism prediction. The authors show that the COMPAS scores are racially

ar
X

iv
:1

70
4.

01
70

1v
1 

 [
st

at
.M

L
] 

 6
 A

pr
 2

01
7



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

if (age = 23− 25) ∧ (priors = 2− 3) then predict yes
else if (age = 18− 20) then predict yes
else if (sex = male) ∧ (age = 21− 22) then predict yes
else if (priors > 3) then predict yes
else predict no

Figure 1: An example rule list that predicts two-year recidivism for the ProPublica dataset,
found by CORELS.

biased, but since the model is not transparent, no one (outside of the creators of COM-
PAS) can determine the reason or extent of the bias (Larson et al., 2016), nor can anyone
determine the reason for any particular prediction. By using COMPAS, users implicitly
assumed that a transparent model would not be sufficiently accurate for recidivism predic-
tion, i.e., they assumed that a black box model would provide better accuracy. We wondered
whether there was indeed no transparent and sufficiently accurate model. Answering this
question requires solving a computationally hard problem. Namely, we would like to both
find a transparent model that is optimal within a particular pre-determined class of models
and produce a certificate of its optimality. This would enable one to say, for this problem
and model class, with certainty and before resorting to black box methods, whether there
exists a transparent model.

To that end, we consider the class of rule lists assembled from pre-mined frequent item-
sets and search for an optimal rule list that minimizes a regularized risk function, R. This
is a hard discrete optimization problem. Brute force solutions that minimize R are compu-
tationally prohibitive due to the exponential number of possible rule lists. However, this is
a worst case bound that is not realized in practical settings. For realistic cases, it is possible
to solve fairly large cases of this problem to optimality, with the careful use of algorithms,
data structures, and implementation techniques.

We develop specialized tools from the fields of discrete optimization and artificial intel-
ligence. Specifically, we introduce a special branch-and-bound algorithm, called Certifiably
Optimal RulE ListS (CORELS), that provides (1) the optimal solution, (2) a certificate
of optimality, and (3) optionally, a collection of near-optimal solutions and the distance
between each such solution and the optimal one. The certificate of optimality means that
we can investigate how close other models (e.g., models provided by greedy algorithms) are
to optimal. In particular, we can investigate if the rule lists from probabilistic approaches
are nearly optimal or whether those approaches sacrifice too much accuracy in the interest
of speed.

Within its branch-and-bound procedure, CORELS maintains a lower bound on the
minimum value of R that each incomplete rule list can achieve. This allows CORELS to
prune an incomplete rule list (and every possible extension) if the bound is larger than
the error of the best rule list that it has already evaluated. The use of careful bounding
techniques leads to massive pruning of the search space of potential rule lists. It continues
to consider incomplete and complete rule lists until it has either examined or eliminated
every rule list from consideration. Thus, CORELS terminates with the optimal rule list and
a certificate of optimality.

2



Learning Certifiably Optimal Rule Lists for Categorical Data

The efficacy of CORELS depends on how much of the search space our bounds allow us
to prune; we seek a tight lower bound on R. The bound we maintain throughout execution is
a maximum of several bounds, that come in three categories. The first category of bounds are
those intrinsic to the rules themselves. This category includes bounds stating that each rule
must capture sufficient data; if not, the rule list is provably non-optimal. The second type
of bound compares a lower bound on the value of R to that of the current best solution.
This allows us to exclude parts of the search space that could never be better than our
current solution. Finally, our last type of bound is based on comparing incomplete rule lists
that capture the same data and allow us to pursue only the most accurate option. This last
class of bounds is especially important – without our use of a novel symmetry-aware map,
we are unable to solve most problems of reasonable scale. This symmetry-aware map keeps
track of the best accuracy over all observed permutations of a given incomplete rule list.

We keep track of these bounds using a modified prefix tree, a data structure also known
as a trie. Each node in the prefix tree represents an individual rule; thus, each path in the
tree represents a rule list such that the final node in the path contains metrics about that
rule list. This tree structure, together with a search policy and sometimes a queue, enables a
variety of strategies, including breadth-first, best-first, and stochastic search. In particular,
we can design different best-first strategies by customizing how we order elements in a
priority queue. In addition, we are able to limit the number of nodes in the tree and thereby
enable tuning of space-time tradeoffs in a robust manner. This tree structure is a useful way
of organizing the generation and evaluation of rule lists, and is parallelizable.

We evaluated CORELS on a number of publicly available datasets. Our metric of success
was 10-fold cross-validated prediction accuracy on a subset of the data. These datasets
involve hundreds of rules and thousands of observations. CORELS is generally able to
find an optimal rule list in a matter of seconds and certify its optimality within about 10
minutes. We show that we are able to achieve better or similar out-of-sample accuracy on
these datasets compared to the popular greedy algorithms, CART and C4.5.

CORELS targets large (not massive) problems, where interpretability and certifiable op-
timality are important. We illustrate the efficacy of our approach using (1) the ProPublica
COMPAS dataset (Larson et al., 2016), for the problem of two-year recidivism prediction,
and (2) the NYCLU 2014 stop-and-frisk dataset (New York Civil Liberties Union, 2014), to
predict whether a weapon will be found on a stopped individual who is frisked or searched.
We produce certifiably optimal, interpretable rule lists that achieve the same accuracy as
approaches such as random forests. This calls into question the need for use of a proprietary,
black box algorithm for recidivism prediction.

Our implementation of CORELS is at https://github.com/nlarusstone/corels. 1

2. Related Work

We discuss related literature in several subfields, and highlight two recent works that this
paper builds on.

Interpretable Models: There is a growing interest in interpretable (transparent, compre-
hensible) models because of their societal importance (see Rüping, 2006; Bratko, 1997;

1. Our work overlaps with the thesis presented by Larus-Stone (2017).

3

https://github.com/nlarusstone/corels


Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Dawes, 1979; Vellido et al., 2012; Giraud-Carrier, 1998; Holte, 1993; Shmueli, 2010; Huys-
mans et al., 2011; Freitas, 2014). There are now regulations on algorithmic decision-making
in the European Union on the “right to an explanation” (Goodman and Flaxman, 2016)
that would legally require interpretability in predictions.

Optimal Decision Tree Modeling : The body of work closest to ours is possibly that of
optimal decision tree modeling. Since the late 1990’s, there has been research on building
optimal decision trees using optimization techniques (Bennett and Blue, 1996; Dobkin et al.,
1996), continuing until the present (Farhangfar et al., 2008). A particularly interesting paper
along these lines is that of Nijssen and Fromont (2010), who created a “bottom-up” way
to form optimal decision trees. Their method performs an expensive search step, mining
all possible leaves (rather than all possible rules), and uses those leaves to form trees.
Their method can lead to memory problems, but it is possible that these memory issues
can be mitigated using the theorems in this paper. 2 Another work close to ours is that
of Garofalakis et al. (2000), who introduce an algorithm to generate more interpretable
decision trees by allowing constraints to be placed on the size of the decision tree. During
tree construction, they bound the possible Minimum Description Length (MDL) cost of
every different split at a given node. If every split at that node is more expensive than the
actual cost of the current subtree, then that node can be pruned. In this way, they are able
to prune the tree while constructing it instead of just constructing the tree and then pruning
at the end. They do not aim for optimal trees; they build trees that obey constraints, and
find optimal subtrees within the trees that were built during the building phase.

Greedy splitting and pruning: Unlike optimal decision tree methods, methods like CART
(Breiman et al., 1984) and C4.5 (Quinlan, 1993) do not perform exploration of the search
space beyond greedy splitting. There are a huge number of algorithms in this class.

Bayesian tree and rule list methods: Some of these approaches that aim to explore the
space of trees (Dension et al., 1998; Chipman et al., 2002, 2010) use Monte Carlo methods.
However, the space of trees of a given depth is much larger than the space of rule lists of
that same level of depth, and the trees within these algorithms are grown in a top-down
greedy way. Because of this, the authors noted that their MCMC chains tend to reach only
locally optimal solutions. This explains why Bayesian rule-based methods (Letham et al.,
2015; Yang et al., 2016) have tended to be more successful in escaping local minima. Our
work builds specifically on that of Yang et al. (2016). In particular, we use their library for
efficiently representing and operating on bit vectors, and build on their bounds. Note that
the RIPPER algorithm (Cohen, 1995) is similar to the Bayesian tree methods in that it
grows, prunes, and then locally optimizes.

Rule learning methods: Most rule learning methods are not designed for optimality or
interpretability, but for computational speed and/or accuracy. In associative classification
(Vanhoof and Depaire, 2010; Liu et al., 1998; Li et al., 2001; Yin and Han, 2003), classifiers
are often formed greedily from the top down as rule lists, or they are formed by taking the
simple union of pre-mined rules, whereby any observation that fits into any of the rules
is classified as positive. In inductive logic programming (Muggleton and De Raedt, 1994),
algorithms construct disjunctive normal form patterns via a set of operations (rather than
using optimization). These approaches are not appropriate for obtaining a guarantee of

2. There is no public version of their code for distribution as of this writing.

4



Learning Certifiably Optimal Rule Lists for Categorical Data

optimality. Methods for decision list learning construct rule lists iteratively in a greedy
way (Rivest, 1987; Sokolova et al., 2003; Marchand and Sokolova, 2005; Rudin et al., 2013;
Goessling and Kang, 2015); these too have no guarantee of optimality, and tend not to
produce optimal rule lists in general. Some methods allow for interpretations of single rules,
without constructing rule lists (McCormick et al., 2012).

There is a tremendous amount of related work in other subfields that are too numerous
to discuss at length here. We have not discussed rule mining algorithms since they are part
of an interchangeable preprocessing step for our algorithm and are deterministically fast
(i.e., they will not generally slow our algorithm down). We also did not discuss methods that
create disjunctive normal form models, e.g., logical analysis of data, and many associative
classification methods.

Related problems with interpretable lists of rules: Beyond trees that are optimized for
accuracy and sparsity, rule lists have been developed for various applications, and with
exotic types of constraints. For example, Falling Rule Lists (Wang and Rudin, 2015) are
constrained to have decreasing probabilities down the list as are rule lists for dynamic treat-
ment regimes (Zhang et al., 2015) and cost-sensitive dynamic treatment regimes (Lakkaraju
and Rudin, 2017). Both Wang and Rudin (2015) and Lakkaraju and Rudin (2017) use Monte
Carlo searches to explore the space of rule lists. The method proposed in this paper could po-
tentially be adapted to handle these kinds of interesting problems. We are currently working
on bounds for Falling Rule Lists (Chen and Rudin, 2017) similar to those presented here.

Two works that this paper builds on are those of Yang et al. (2016), and Rudin and
Ertekin (2015). The work of Yang et al. provided the bit vector libraries and several ideas
that were used here, and we used their code as a starting point. Their scalable Bayesian
rule lists (SBRL) method has uses beyond those of CORELS because SBRL models are
probabilistic, producing an estimate of P(Y = 1 |X) for any X, rather than a yes/no clas-
sification. On the other hand, because the model is probabilistic, the bounds depend on
approximations involving gamma functions. Bounds for CORELS have no such approxima-
tions and are substantially tighter. Yang et al. aim to find the optimal solution but do not
aim to prove optimality.

Both Yang et al. (2016) and Rudin and Ertekin (2015) contributed bounds that we
started from in this work, and in particular, the latter uses the same objective as we do and
has some of the same bounds, including the minimum support bound (§3.7, Theorem 10).
However, Ertekin and Rudin’s work is for a different purpose, namely it is for building
rule lists that can be customized; since the authors use mixed integer programming (MIP),
users can easily add constraints to the MIP and create rule lists that obey these arbitrary
constraints. As in our framework, their rule lists are certifiably optimal. However, since
generic MIP software is used without efficient bounds and data structures like the ones
introduced here, much more time can be required to prove optimality and to find the
optimal solution.

3. Learning optimal rule lists

In this section, we present our framework for learning certifiably optimal rule lists. First,
we define our setting and useful notation (§3.1), followed by the objective function we
seek to minimize (§3.2). Next, we describe the principal structure of our optimization algo-

5



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

if (age = 23− 25)∧ (priors = 2− 3) then predict yes
else if (age = 18− 20) then predict yes
else if (sex = male)∧(age = 21−22) then predict yes
else if (priors > 3) then predict yes
else predict no

if p1 then predict q1
else if p2 then predict q2
else if p3 then predict q3
else if p4 then predict q4
else predict q0

Figure 2: The same 4-rule list d = (r1, r2, r3, r4, r0), as in Figure 1, that predicts two-
year recidivism for the ProPublica dataset. Each rule is of the form rk = pk → qk, for
all k = 0, . . . , 4. We also equivalently write d = (dp, δp, q0,K), where dp = (p1, p2, p3, p4),
δp = (1, 1, 1, 1), q0 = 0, and K = 4.

rithm (§3.3), which depends on a hierarchically structured objective lower bound (§3.4). We
then derive a series of additional bounds that we incorporate into our algorithm because
they enable aggressive pruning of our state space.

3.1 Rule lists for binary classification

We restrict our setting to binary classification, where rule lists are Boolean functions; this
framework is straightforward to generalize to multi-class classification. Let {(xn, yn)}Nn=1
denote training data, where xn ∈ {0, 1}J are binary features and yn ∈ {0, 1} are labels.
Let x = {xn}Nn=1 and y = {yn}Nn=1, and let xn,j denote the j-th feature of xn.

A rule list d = (r1, r2, . . . , rK , r0) of length K ≥ 0 is a (K + 1)-tuple consisting of K
distinct association rules, rk = pk → qk, for k = 1, . . . ,K, followed by a default rule r0.
Figure 2 illustrates a rule list, which for clarity, we sometimes call a K-rule list. An asso-
ciation rule r = p→ q is an implication corresponding to the conditional statement, “if p,
then q.” In our setting, an antecedent p is a Boolean assertion that evaluates to either
true or false for each datum xn, and a consequent q is a label prediction. For example,
(xn,1 = 0) ∧ (xn,3 = 1)→ (yn = 1) is an association rule. The final default rule r0 in a rule
list can be thought of as a special association rule p0 → q0 whose antecedent p0 simply
asserts true.

Let d = (r1, r2, . . . , rK , r0) be a K-rule list, where rk = pk → qk for each k = 0, . . . ,K.
We introduce a useful alternate rule list representation: d = (dp, δp, q0,K), where we de-
fine dp = (p1, . . . , pK) to be d’s prefix, δp = (q1, . . . , qK) ∈ {0, 1}K gives the label predic-
tions associated with dp, and q0 ∈ {0, 1} is the default label prediction. In Figure 1, d =
(r1, r2, r3, r4, r0), and each rule is of the form rk = pk → qk, for all k = 0, . . . , 4; equivalently,
d = (dp, δp, q0,K), where dp = (p1, p2, p3, p4), δp = (1, 1, 1, 1), q0 = 0, and K = 4.

Let dp = (p1, . . . , pk, . . . , pK) be an antecedent list, then for any k ≤ K, we define dkp =
(p1, . . . , pk) to be the k-prefix of dp. For any such k-prefix d

k
p, we say that dp starts with d

k
p.

For any given space of rule lists, we define σ(dp) to be the set of all rule lists whose prefixes
start with dp:

σ(dp) = {(d′p, δ′p, q′0,K ′) : d′p starts with dp}. (1)

If dp = (p1, . . . , pK) and d
′
p = (p1, . . . , pK , pK+1) are two prefixes such that d

′
p starts with dp

and extends it by a single antecedent, we say that dp is the parent of d
′
p and that d

′
p is a

child of dp.

6



Learning Certifiably Optimal Rule Lists for Categorical Data

A rule list d classifies datum xn by providing the label prediction qk of the first rule rk
whose antecedent pk is true for xn. We say that an antecedent pk of antecedent list dp
captures xn in the context of dp if pk is the first antecedent in dp that evaluates to true
for xn. We also say that a prefix captures those data captured by its antecedents; for a rule
list d = (dp, δp, q0,K), data not captured by the prefix dp are classified according to the
default label prediction q0.

Let β be a set of antecedents. We define cap(xn, β) = 1 if an antecedent in β captures
datum xn, and 0 otherwise. For example, let dp and d

′
p be prefixes such that d

′
p starts

with dp, then d
′
p captures all the data that dp captures:

{xn : cap(xn, dp)} ⊆ {xn : cap(xn, d′p)}. (2)

Now let dp be an ordered list of antecedents, and let β be a subset of antecedents in dp.
Let us define cap(xn, β | dp) = 1 if β captures datum xn in the context of dp, i.e., if the first
antecedent in dp that evaluates to true for xn is an antecedent in β, and 0 otherwise. Thus,
cap(xn, β | dp) = 1 only if cap(xn, β) = 1; cap(xn, β | dp) = 0 either if cap(xn, β) = 0, or if
cap(xn, β) = 1 but there is an antecedent α in dp, preceding all antecedents in β, such that
cap(xn, α) = 1. For example, if dp = (p1, . . . , pk, . . . , pK) is a prefix, then

cap(xn, pk | dp) =

(
k−1∧
k′=1

¬ cap(xn, pk′)

)
∧ cap(xn, pk) (3)

indicates whether antecedent pk captures datum xn in the context of dp. Now, define
supp(β,x) to be the normalized support of β,

supp(β,x) =
1

N

N∑
n=1

cap(xn, β), (4)

and similarly define supp(β,x | dp) to be the normalized support of β in the context of dp,

supp(β,x | dp) =
1

N

N∑
n=1

cap(xn, β | dp), (5)

Next, we address how empirical data constrains rule lists. Given training data (x,y), an
antecedent list dp = (p1, . . . , pK) implies a rule list d = (dp, δp, q0,K) with prefix dp, where
the label predictions δp = (q1, . . . , qK) and q0 are empirically set to minimize the number
of misclassification errors made by the rule list on the training data. Thus for 1 ≤ k ≤ K,
label prediction qk corresponds to the majority label of data captured by antecedent pk in
the context of dp, and the default q0 corresponds to the majority label of data not captured
by dp. In the remainder of our presentation, whenever we refer to a rule list with a particular
prefix, we implicitly assume these empirically determined label predictions.

Finally, we note that our approach leverages pre-mined rules, following the methodology
taken by Letham et al. (2015) and Yang et al. (2016). One of the results we later prove
implies a constraint that can be used as a filter during rule mining – antecedents must have
at least some minimum support given by the lower bound in Theorem 10.

7



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

3.2 Objective function

We define a simple objective function for a rule list d = (dp, δp, q0,K):

R(d,x,y) = `(d,x,y) + λK. (6)

This objective function is a regularized empirical risk; it consists of a loss `(d,x,y), mea-
suring misclassification error, and a regularization term that penalizes longer rule lists.
`(d,x,y) is the fraction of training data whose labels are incorrectly predicted by d. In
our setting, the regularization parameter λ ≥ 0 is a small constant; e.g., λ = 0.01 can be
thought of as adding a penalty equivalent to misclassifying 1% of data when increasing a
rule list’s length by one association rule.

3.3 Optimization framework

Our objective has structure amenable to global optimization via a branch-and-bound frame-
work. In particular, we make a series of important observations that each translates into a
useful bound, and that together interact to eliminate large parts of the search space. We
will discuss these in depth throughout the following sections:

• Lower bounds on a prefix also hold for every extension of that prefix. (§3.4, Theorem 1)

• We can sometimes prune all rule lists that are longer than a given prefix, even without
knowing anything about what rules will be placed below that prefix. (§3.4, Lemma 2)

• We can calculate a priori an upper bound on the maximum length of an optimal rule
list. (§3.5, Theorem 6)

• Each rule in an optimal rule list must have support that is sufficiently large. This allows
us to construct rule lists from frequent itemsets, while preserving the guarantee that
we can find a globally optimal rule list from pre-mined rules. (§3.7, Theorem 10)

• Each rule in an optimal rule list must predict accurately. In particular, the number of
observations predicted correctly by each rule in an optimal rule list must be above a
threshold. (§3.7, Theorem 11)

• We need only consider the optimal permutation of antecedents in a prefix; we can
omit all other permutations. (§3.10, Theorem 17 and Corollary 18)

• If multiple observations have identical features and opposite labels, we know that any
model will make mistakes. In particular, the number of mistakes on these observations
will be at least the number of observations with the minority label. (§3.14, Theorem 22)

3.4 Hierarchical objective lower bound

We can decompose the misclassification error into two contributions corresponding to the
prefix and the default rule:

`(d,x,y) ≡ `p(dp, δp,x,y) + `0(dp, q0,x,y), (7)

8



Learning Certifiably Optimal Rule Lists for Categorical Data

where dp = (p1, . . . , pK) and δp = (q1, . . . , qK);

`p(dp, δp,x,y) =
1

N

N∑
n=1

K∑
k=1

cap(xn, pk | dp) ∧ 1[qk 6= yn] (8)

is the fraction of data captured and misclassified by the prefix, and

`0(dp, q0,x,y) =
1

N

N∑
n=1

¬ cap(xn, dp) ∧ 1[q0 6= yn] (9)

is the fraction of data not captured by the prefix and misclassified by the default rule.
Eliminating the latter error term gives a lower bound b(dp,x,y) on the objective,

b(dp,x,y) ≡ `p(dp, δp,x,y) + λK ≤ R(d,x,y), (10)

where we have suppressed the lower bound’s dependence on label predictions δp because
they are fully determined, given (dp,x,y). Furthermore, as we state next in Theorem 1,
b(dp,x,y) gives a lower bound on the objective of any rule list whose prefix starts with dp.

Theorem 1 (Hierarchical objective lower bound) Define b(dp,x,y) as in (10). Also,
define σ(dp) to be the set of all rule lists whose prefixes starts with dp, as in (1). Let d =
(dp, δp, q0,K) be a rule list with prefix dp, and let d

′ = (d′p, δ
′
p, q
′
0,K

′) ∈ σ(dp) be any rule
list such that its prefix d′p starts with dp and K

′ ≥ K, then b(dp,x,y) ≤ R(d′,x,y).

Proof Let dp = (p1, . . . , pK) and δp = (q1, . . . , qK); let d
′
p = (p1, . . . , pK , pK+1, . . . , pK′) and

δ′p = (q1, . . . , qK , qK+1, . . . , qK′). Notice that d
′
p yields the same mistakes as dp, and possibly

additional mistakes:

`p(d
′
p, δ
′
p,x,y) =

1

N

N∑
n=1

K′∑
k=1

cap(xn, pk | d′p) ∧ 1[qk 6= yn]

=
1

N

N∑
n=1

(
K∑
k=1

cap(xn, pk | dp) ∧ 1[qk 6= yn] +
K′∑

k=K+1

cap(xn, pk | d′p) ∧ 1[qk 6= yn]

)
≥ `p(dp, δp,x,y), (11)

where we have used the fact that cap(xn, pk | d′p) = cap(xn, pk | dp) for 1 ≤ k ≤ K. It follows
that

b(dp,x,y) = `p(dp, δp,x,y) + λK

≤ `p(d′p, δ′p,x,y) + λK ′ = b(d′p,x,y) ≤ R(d′,x,y). (12)

To generalize, consider a sequence of prefixes such that each prefix starts with all previ-
ous prefixes in the sequence. It follows that the corresponding sequence of objective lower

9



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Algorithm 1 Branch-and-bound for learning rule lists.

Input: Objective function R(d,x,y), objective lower bound b(dp,x,y), set of antecedents
S = {sm}Mm=1, training data (x,y) = {(xn, yn)}Nn=1, initial best known rule list d0 with
objective R0 = R(d0,x,y)
Output: Provably optimal rule list d∗ with minimum objective R∗

(dc, Rc)← (d0, R0) . Initialize best rule list and objective
Q← queue( [ ( ) ] ) . Initialize queue with empty prefix
while Q not empty do . Stop when queue is empty

dp ← Q.pop( ) . Remove prefix dp from the queue
if b(dp,x,y) < R

c then . Bound: Apply Theorem 1
R← R(d,x,y) . Compute objective of dp’s rule list d
if R < Rc then . Update best rule list and objective

(dc, Rc)← (d,R)
end if
for s in S do . Branch: Enqueue dp’s children

if s not in dp then
Q.push( (dp, s) )

end if
end for

end if
end while
(d∗, R∗)← (dc, Rc) . Identify provably optimal solution

bounds increases monotonically. This is precisely the structure required and exploited by
branch-and-bound, illustrated in Algorithm 1.

Specifically, the objective lower bound in Theorem 1 enables us to prune the state
space hierarchically. While executing branch-and-bound, we keep track of the current best
(smallest) objective Rc, thus it is a dynamic, monotonically decreasing quantity. If we
encounter a prefix dp with lower bound b(dp,x,y) ≥ Rc, then by Theorem 1, we needn’t
consider any rule list d′ ∈ σ(dp) whose prefix d′p starts with dp. For the objective of such a
rule list, the current best objective provides a lower bound, i.e., R(d′,x,y) ≥ b(d′p,x,y) ≥
b(dp,x,y) ≥ Rc, and thus d′ cannot be optimal.

Next, we state an immediate consequence of Theorem 1.

Lemma 2 (Objective lower bound with one-step lookahead) Let dp be a K-prefix
and let Rc be the current best objective. If b(dp,x,y) + λ ≥ Rc, then for any K ′-rule list
d′ ∈ σ(dp) whose prefix d′p starts with dp and K ′ > K, it follows that R(d′,x,y) ≥ Rc.

Proof By the definition of the lower bound (10), which includes the penalty for longer
prefixes,

R(d′p,x, y) ≥ b(d′p,x,y) = `p(d′p,x,y) + λK ′

= `p(d
′
p,x,y) + λK + λ(K

′ −K)
= b(dp,x,y) + λ(K

′ −K) ≥ b(dp,x,y) + λ ≥ Rc. (13)

10



Learning Certifiably Optimal Rule Lists for Categorical Data

Therefore, even if we encounter a prefix dp with lower bound b(dp,x,y) ≤ Rc, as long
as b(dp,x,y) + λ ≥ Rc, then we can prune all prefixes d′p that start with and are longer
than dp.

3.5 Upper bounds on prefix length

The simplest upper bound on prefix length is given by the total number of available an-
tecedents.

Proposition 3 (Trivial upper bound on prefix length) Consider a state space of all
rule lists formed from a set of M antecedents, and let L(d) be the length of rule list d.
M provides an upper bound on the length of any optimal rule list d∗ ∈ argmindR(d,x,y),
i.e., L(d) ≤M .

Proof Rule lists consist of distinct rules by definition.

At any point during branch-and-bound execution, the current best objective Rc implies
an upper bound on the maximum prefix length we might still have to consider.

Theorem 4 (Upper bound on prefix length) Consider a state space of all rule lists
formed from a set of M antecedents. Let L(d) be the length of rule list d and let Rc be the
current best objective. For all optimal rule lists d∗ ∈ argmindR(d,x,y)

L(d∗) ≤ min
(⌊

Rc

λ

⌋
,M

)
, (14)

where λ is the regularization parameter. Furthermore, if dc is a rule list with objective
R(dc,x,y) = Rc, length K, and zero misclassification error, then for every optimal rule
list d∗ ∈ argmindR(d,x,y), if dc ∈ argmindR(d,x,y), then L(d∗) ≤ K, or otherwise if
dc /∈ argmindR(d,x,y), then L(d∗) ≤ K − 1.

Proof For an optimal rule list d∗ with objective R∗,

λL(d∗) ≤ R∗ = R(d∗,x,y) = `(d∗,x,y) + λL(d∗) ≤ Rc. (15)

The maximum possible length for d∗ occurs when `(d∗,x,y) is minimized; combining with
Proposition 3 gives bound (14).

For the rest of the proof, let K∗ = L(d∗) be the length of d∗. If the current best rule
list dc has zero misclassification error, then

λK∗ ≤ `(d∗,x,y) + λK∗ = R(d∗,x,y) ≤ Rc = R(dc,x,y) = λK, (16)

and thus K∗ ≤ K. If the current best rule list is suboptimal, i.e., dc /∈ argmindR(d,x,y),
then

λK∗ ≤ `(d∗,x,y) + λK∗ = R(d∗,x,y) < Rc = R(dc,x,y) = λK, (17)

11



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

in which case K∗ < K, i.e., K∗ ≤ K − 1, since K is an integer.

The latter part of Theorem 4 tells us that if we only need to identify a single instance of
an optimal rule list d∗ ∈ argmindR(d,x,y), and we encounter a perfect K-prefix with zero
misclassification error, then we can prune all prefixes of length K or greater.

Corollary 5 (Simple upper bound on prefix length) Let L(d) be the length of rule
list d. For all optimal rule lists d∗ ∈ argmindR(d,x,y),

L(d∗) ≤ min
(⌊

1

2λ

⌋
,M

)
. (18)

Proof Let d = ((), (), q0, 0) be the empty rule list; it has objective R(d,x,y) = `(d,x,y) ≤
1/2, which gives an upper bound on Rc. Combining with (14) and Proposition 3 gives (18).

For any particular prefix dp, we can obtain potentially tighter upper bounds on prefix
length for the family of all prefixes that start with dp.

Theorem 6 (Prefix-specific upper bound on prefix length) Let d = (dp, δp, q0,K) be
a rule list, let d′ = (d′p, δ

′
p, q
′
0,K

′) ∈ σ(dp) be any rule list such that d′p starts with dp, and
let Rc be the current best objective. If d′p has lower bound b(d

′
p,x,y) < R

c, then

K ′ < min

(
K +

⌊
Rc − b(dp,x,y)

λ

⌋
,M

)
. (19)

Proof First, note that K ′ ≥ K, since d′p starts with dp. Now recall from (12) that

b(dp,x,y) = `(d, δp,x,y) + λK ≤ `(d′, δ′p,x,y) + λK ′ = b(d′p,x,y), (20)

and from (11) that `(d, δp,x,y) ≤ `(d′, δ′p,x,y). Combining these bounds and rearranging
gives

b(dp,x,y) + λ(K
′ −K) ≤ b(d′p,x,y). (21)

Combining (21) with b(d′p,x,y) < R
c and Proposition 3 gives (19).

We can view Theorem 6 as a generalization of our one-step lookahead bound (Lemma 2),
as (19) is equivalently a bound on K ′ −K, an upper bound on the number of remaining
‘steps’ corresponding to an iterative sequence of single-rule extensions of a prefix dp. No-
tice that when d = ((), (), q0, 0) is the empty rule list, this bound replicates (14), since
b(dp,x,y) = 0.

3.6 Upper bounds on the number of prefix evaluations

In this section, we use our upper bounds on prefix length from §3.5 to derive corresponding
upper bounds on the number of prefix evaluations made by Algorithm 1. First, we present
Theorem 7, in which we use information about the state of Algorithm 1’s execution to

12



Learning Certifiably Optimal Rule Lists for Categorical Data

calculate, for any given execution state, upper bounds on the number of additional prefix
evaluations that might be required for the execution to complete. This number of remaining
evaluations is equal to the number of prefixes that are currently in or will be inserted into
the queue. The relevant execution state depends on the current best objective Rc and
information about prefixes we are planning to evaluate, i.e., prefixes in the queue Q of
Algorithm 1. After Theorem 7, we present two weaker propositions that provide useful
intuition.

Theorem 7 (Fine-grain upper bound on remaining prefix evaluations) Consider
the state space of all rule lists formed from a set of M antecedents, and consider Algorithm 1
at a particular instant during execution. Let Rc be the current best objective, let Q be the
queue, and let L(dp) be the length of prefix dp. Define Γ(R

c, Q) to be the number of remaining
prefix evaluations, then

Γ(Rc, Q) ≤
∑
dp∈Q

f(dp)∑
k=0

(M − L(dp))!
(M − L(dp)− k)!

, (22)

where

f(dp) = min

(⌊
Rc − b(dp,x,y)

λ

⌋
,M − L(dp)

)
. (23)

Proof The number of remaining prefix evaluations is equal to the number of prefixes that
are currently in or will be inserted into queue Q. For any such prefix dp, Theorem 6 gives
an upper bound on the length of any prefix d′p that starts with dp:

L(d′p) ≤ min
(
L(dp) +

⌊
Rc − b(dp,x,y)

λ

⌋
,M

)
≡ U(dp). (24)

This gives an upper bound on the number of remaining prefix evaluations:

Γ(Rc, Q) ≤
∑
dp∈Q

U(dp)−L(dp)∑
k=0

P (M − L(dp), k) =
∑
dp∈Q

f(dp)∑
k=0

(M − L(dp))!
(M − L(dp)− k)!

. (25)

Our first proposition below is a näıve upper bound on the total number of prefix evalua-
tions over the course of Algorithm 1’s execution. It only depends on the number of rules and
the regularization parameter λ; i.e., unlike Theorem 7, it does not use algorithm execution
state to bound the size of the search space.

Proposition 8 (Upper bound on the total number of prefix evaluations) Define
Γtot(S) to be the total number of prefixes evaluated by Algorithm 1, given the state space of
all rule lists formed from a set S of M rules. For any set S of M rules,

Γtot(S) ≤
K∑
k=0

M !

(M − k)!
, (26)

where K = min(b1/2λc,M).

13



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Proof By Corollary 5, K ≡ min(b1/2λc,M) gives an upper bound on the length of any
optimal rule list. Since we can think of our problem as finding the optimal selection and
permutation of k out of M rules, over all k ≤ K,

Γtot(S) ≤ 1 +
K∑
k=1

P (M,k) =

K∑
k=0

M !

(M − k)!
. (27)

Our next upper bound is strictly tighter than the bound in Proposition 8. Like Theo-
rem 7, it uses the current best objective and information about the lengths of prefixes in the
queue to constrain the lengths of prefixes in the remaining search space. However, Propo-
sition 9 is weaker than Theorem 7 because it leverages only coarse-grain information from
the queue. Specifically, Theorem 7 is strictly tighter because it additionally incorporates
prefix-specific objective lower bound information from prefixes in the queue, which further
constrains the lengths of prefixes in the remaining search space.

Proposition 9 (Coarse-grain upper bound on remaining prefix evaluations)
Consider a state space of all rule lists formed from a set of M antecedents, and consider
Algorithm 1 at a particular instant during execution. Let Rc be the current best objective,
let Q be the queue, and let L(dp) be the length of prefix dp. Let Qj be the number of prefixes
of length j in Q,

Qj =
∣∣{dp : L(dp) = j, dp ∈ Q}∣∣ (28)

and let J = argmaxdp∈Q L(dp) be the length of the longest prefix in Q. Define Γ(R
c, Q) to

be the number of remaining prefix evaluations, then

Γ(Rc, Q) ≤
J∑
j=1

Qj

(
K−j∑
k=0

(M − j)!
(M − j − k)!

)
, (29)

where K = min(bRc/λc,M).

Proof The number of remaining prefix evaluations is equal to the number of prefixes that
are currently in or will be inserted into queueQ. For any such remaining prefix dp, Theorem 4
gives an upper bound on its length; defineK to be this bound: L(dp) ≤ min(bRc/λc,M) ≡ K.
For any prefix dp in queue Q with length L(dp) = j, the maximum number of prefixes that
start with dp and remain to be evaluated is:

K−j∑
k=0

P (M − j, k) =
K−j∑
k=0

(M − j)!
(M − j − k)!

, (30)

where P (T, k) denotes the number of k-permutations of T . This gives an upper bound on
the number of remaining prefix evaluations:

Γ(Rc, Q) ≤
J∑
j=0

Qj

(
K−j∑
k=0

P (M − j, k)

)
=

J∑
j=0

Qj

(
K−j∑
k=0

(M − j)!
(M − j − k)!

)
. (31)

14



Learning Certifiably Optimal Rule Lists for Categorical Data

3.7 Lower bounds on antecedent support

In this section, we give two lower bounds on the normalized support of each antecedent in
any optimal rule list; both are related to the regularization parameter λ.

Theorem 10 (Lower bound on antecedent support) Let d∗ = (dp, δp, q0,K) be any
optimal rule list with objective R∗, i.e., d∗ ∈ argmindR(d,x,y). For each antecedent pk
in prefix dp = (p1, . . . , pK), the regularization parameter λ provides a lower bound on the
normalized support of pk,

λ < supp(pk,x | dp). (32)

Proof Let d∗ = (dp, δp, q0,K) be an optimal rule list with prefix dp = (p1, . . . , pK) and
labels δp = (q1, . . . , qK). Consider the rule list d = (d

′
p, δ
′
p, q
′
0,K − 1) derived from d∗ by

deleting a rule pi → qi, therefore d′p = (p1, . . . , pi−1, pi+1, . . . , pK) and δ′p = (q1, . . . , qi−1,
q′i+1, . . . , q

′
K), where q

′
k need not be the same as qk, for k > i and k = 0.

The largest possible discrepancy between d∗ and d would occur if d∗ correctly classified
all the data captured by pi, while d misclassified these data. This gives an upper bound:

R(d,x,y) = `(d,x,y) + λ(K − 1) ≤ `(d∗,x,y) + supp(pi,x | dp) + λ(K − 1)
= R(d∗,x,y) + supp(pi,x | dp)− λ
= R∗ + supp(pi,x | dp)− λ (33)

where supp(pi,x | dp) is the normalized support of pi in the context of dp, defined in (5),
and the regularization ‘bonus’ comes from the fact that d is one rule shorter than d∗.

At the same time, we must have R∗ < R(d,x,y) for d∗ to be optimal. Combining this
with (33) and rearranging gives (32), therefore the regularization parameter λ provides a
lower bound on the support of an antecedent pi in an optimal rule list d

∗.

Thus, we can prune a prefix dp if any of its antecedents do not capture more than a
fraction λ of data, even if b(dp,x,y) < R

∗. Notice that the bound in Theorem 10 depends on
the antecedents, but not the label predictions, and thus doesn’t account for misclassification
error. Theorem 11 gives a tighter bound by leveraging this additional information, which
specifically tightens the upper bound on R(d,x,y) in (33).

Theorem 11 (Lower bound on accurate antecedent support) Let d∗ be any opti-
mal rule list with objective R∗, i.e., d∗ = (dp, δp, q0,K) ∈ argmindR(d,x,y). Let d∗ have
prefix dp = (p1, . . . , pK) and labels δp = (q1, . . . , qK). For each rule pk → qk in d∗, define ak
to be the fraction of data that are captured by pk and correctly classified:

ak ≡
1

N

N∑
n=1

cap(xn, pk | dp) ∧ 1[qk = yn]. (34)

15



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

The regularization parameter λ provides a lower bound on ak:

λ < ak. (35)

Proof As in Theorem 10, let d = (d′p, δ
′
p, q
′
0,K − 1) be the rule list derived from d∗ by

deleting a rule pi → qi. Now, let us define `i to be the portion of R∗ due to this rule’s
misclassification error,

`i ≡
1

N

N∑
n=1

cap(xn, pi | dp) ∧ 1[qi 6= yn]. (36)

The largest discrepancy between d∗ and d would occur if d misclassified all the data captured
by pi. This gives an upper bound on the difference between the misclassification error of d
and d∗:

`(d,x,y)− `(d∗,x,y) ≤ supp(pi,x | dp)− `i

=
1

N

N∑
n=1

cap(xn, pi | dp)−
1

N

N∑
n=1

cap(xn, pi | dp) ∧ 1[qi 6= yn]

=
1

N

N∑
n=1

cap(xn, pi | dp) ∧ 1[qi = yn] = ai, (37)

where we defined ai in (34). Relating this bound to the objectives of d and d
∗ gives

R(d,x,y) = `(d,x,y) + λ(K − 1) ≤ `(d∗,x,y) + ai + λ(K − 1)
= R(d∗,x,y) + ai − λ
= R∗ + ai − λ (38)

Combining (38) with the requirement R∗ < R(d,x,y) gives the bound λ < ai.

Thus, we can prune a prefix if any of its rules do not capture and correctly classify
at least a fraction λ of data. While the lower bound in Theorem 10 is a sub-condition of
the lower bound in Theorem 11, we can still leverage both – since the sub-condition is
easier to check, checking it first can accelerate pruning. In addition to applying Theorem 10
in the context of constructing rule lists, we can furthermore apply it in the context of
rule mining (§3.1). Specifically, it implies that we should only mine rules with normalized
support greater than λ; we need not mine rules with a smaller fraction of observations. In
contrast, we can only apply Theorem 11 in the context of constructing rule lists; it depends
on the misclassification error associated with each rule in a rule list, thus it provides a lower
bound on the number of observations that each such rule must correctly classify.

3.8 Upper bound on antecedent support

In the previous section (§3.7), we proved lower bounds on antecedent support; in this section,
we give an upper bound on antecedent support. Specifically, Theorem 12 shows that an
antecedent’s support in a rule list cannot be too similar to the set of data not captured by
preceding antecedents in the rule list.

16



Learning Certifiably Optimal Rule Lists for Categorical Data

Theorem 12 (Upper bound on antecedent support) Let d∗ = (dp, δp, q0,K) be any
optimal rule list with objective R∗, i.e., d∗ ∈ argmindR(d,x,y), and let dp = (p1, . . . , pj−1,
pj , . . . , pK−1, pK) be its prefix. The last antecedent pK in dp has support

supp(pK ,x | dp) ≤ 1− supp(dK−1p ,x)− λ, (39)

where dK−1p = (p1, . . . , pK−1), with equality implying that there also exists a shorter optimal

rule list d′ = (dK−1p , δ
′
p, q
′
0,K − 1) ∈ argmindR(d,x,y) with prefix dK−1p . For all k ≤ K − 1,

every antecedent pk in dp has support less than the fraction of all data not captured by
preceding antecedents, by an amount greater than the regularization parameter λ:

supp(pk,x | dp) < 1− supp(dk−1p ,x)− λ, (40)

where dk−1p = (p1, . . . , pk−1).

Proof We begin by focusing on the last antecedent in a rule list. Let d = (dp, δp, q0,K)
be a rule list with prefix dp = (p1, . . . , pK) and objective R(d,x,y) ≤ R∗, where R∗ ≡
minD R(D,x,y) is the optimal objective. Also let d

′ = (d′p, δ
′
p, q
′
0,K + 1) be a rule list whose

prefix d′p = (p1, . . . , pK , pK+1) starts with dp and ends with a new antecedent pK+1. Sup-
pose pK+1 in the context of d

′
p captures nearly all data not captured by dp, except for a

fraction � upper bounded by the regularization parameter λ:

1− supp(dp,x)− supp(pK+1,x | d′p) ≡ � ≤ λ. (41)

Since d′p starts with dp, its prefix misclassification error is at least as great; the only discrep-
ancy between the misclassification errors of d and d′ can come from the difference between
the support of the set of data not captured by dp and the support of pK+1:

|`(d′,x,y)− `(d,x,y)| ≤ 1− supp(dp,x)− supp(pK+1,x | d′p) = �. (42)

The best outcome for d′ would occur if its misclassification error were smaller than that
of d by �, therefore

R(d′,x,y) = `(d′,x,y) + λ(K + 1)

≥ `(d,x,y)− �+ λ(K + 1) = R(d,x,y)− �+ λ ≥ R(d,x,y) ≥ R∗. (43)

d′ is an optimal rule list, i.e., d′ ∈ argminD R(D,x, y), if and only ifR(d′,x,y) = R(d,x,y) =
R∗, which requires � = λ. Otherwise, � < λ, in which case

R(d′,x,y) ≥ R(d,x,y)− �+ λ > R(d,x,y) ≥ R∗, (44)

i.e., d′ is not optimal. This proves the first half of Theorem 12.
To finish, we prove the bound in (40) by contradiction. First, note that the data not

captured by d′p has normalized support � ≤ λ, i.e.,

1− supp(d′p,x) = 1− supp(dp,x)− supp(pK+1,x | d′p) = � ≤ λ. (45)

Thus for any rule list d′′ whose prefix d′′p = (p1, . . . , pK+1, . . . , pK′) starts with d
′
p and ends

with one or more additional rules, each additional rule pk has support supp(pk,x | d′′p) ≤

17



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

� ≤ λ, for all k > K + 1. By Theorem 10, all of the additional rules have insufficient sup-
port, therefore d′′p cannot be optimal, i.e., d

′′ /∈ argminD R(D,x,y).

Similar to Theorem 10, our lower bound on antecedent support, we can apply Theo-
rem 12 in the contexts of both constructing rule lists and rule mining (§3.1). Theorem 12
implies that if we only seek a single optimal rule list, then during branch-and-bound ex-
ecution, we can prune a prefix if we ever add an antecedent with support too similar to
the support of set of data not captured by the preceding antecedents. One way to view
this result is that if d = (dp, δp, q0,K) and d

′ = (d′p, δ
′
p, q
′
0,K + 1) are rule lists such that d

′
p

starts with dp and ends with an antecedent that captures all or nearly all data not captured
by dp, then the new rule in d

′ behaves similar to the default rule of d. As a result, the
misclassification error of d′ must be similar to that of d, and any reduction may not be
sufficient to offset the penalty for longer prefixes. Furthermore, Theorem 12 implies that
we should only mine rules with normalized support less than 1− λ; we need not mine rules
with a larger fraction of observations.

3.9 Antecedent rejection and its propagation

In this section, we demonstrate further consequences of our lower (§3.7) and upper bounds
(§3.8) on antecedent support, under a unified framework we refer to as antecedent rejection.
Let dp = (p1, . . . , pK) be a prefix, and let pk be an antecedent in dp. Define pk to have in-
sufficient support in dp if does not obey the bound in (32) of Theorem 10. Define pk to have
insufficient accurate support in dp if it does not obey the bound in (35) of Theorem 11.
Define pk to have excessive support in dp if it does not obey the appropriate bound in
Theorem 12, i.e., either it’s the last antecedent and doesn’t obey (40), or it’s any other
antecedent and doesn’t obey (39). If pk in the context of dp has insufficient support, insuffi-
cient accurate support, or excessive support, let us say that prefix dp rejects antecedent pK .
Next, in Theorem 13, we describe large classes of related rule lists whose prefixes all reject
the same antecedent.

Theorem 13 (Antecedent rejection propagates) For any prefix dp = (p1, . . . , pK), let
φ(dp) denote the set of all prefixes d

′
p such that the set of all antecedents in dp is a subset

of the set of all antecedents in d′p, i.e.,

φ(dp) = {d′p = (p′1, . . . , p′K′) s.t. {pk : pk ∈ dp} ⊆ {p′κ : p′κ ∈ d′p},K ′ ≥ K}. (46)

Let d = (dp, δp, q0,K) be a rule list with prefix dp = (p1, . . . , pK−1, pK), such that dp rejects
its last antecedent pK , either because pK in the context of dp has insufficient support, insuf-
ficient accurate support, or excessive support. Let dK−1p = (p1, . . . , pK−1) be the first K − 1
antecedents of dp. Let D = (Dp,∆p, Q0, κ) be any rule list with prefix Dp = (P1, . . . , PK′−1,
PK′ , . . . , Pκ) such that Dp starts with D

K′−1
p = (P1, . . . , PK′−1) ∈ φ(dK−1p ) and antecedent

PK′ = pK . It follows that prefix Dp rejects PK′ for the same reason that dp rejects pK , and
furthermore, D cannot be optimal, i.e., D /∈ argmind† R(d†,x,y).

Proof Combine Propositions 14, 15, and 16.

18



Learning Certifiably Optimal Rule Lists for Categorical Data

Proposition 14 (Insufficient antecedent support propagates) First define φ(dp) as
in (46), and let dp = (p1, . . . , pK−1, pK) be a prefix, such that its last antecedent pK has
insufficient support, i.e., the opposite of the bound in (32): supp(pK ,x | dp) ≤ λ. Let dK−1p =
(p1, . . . , pK−1), and let D = (Dp,∆p, Q0, κ) be any rule list with prefix Dp = (P1, . . . , PK′−1,
PK′ , . . . , Pκ), such that Dp starts with D

K′−1
p = (P1, . . . , PK′−1) ∈ φ(dK−1p ) and PK′ = pK .

It follows that PK′ has insufficient support in prefix Dp, and furthermore, D cannot be
optimal, i.e., D /∈ argmindR(d,x,y).

Proof The support of pK in dp depends only on the set of antecedents in d
K
p = (p1, . . . , pK):

supp(pK ,x | dp) =
1

N

N∑
n=1

cap(xn, pK | dp) =
1

N

N∑
n=1

(
¬ cap(xn, dK−1p )

)
∧ cap(xn, pK)

=
1

N

N∑
n=1

(
K−1∧
k=1

¬ cap(xn, pk)

)
∧ cap(xn, pK) ≤ λ.

(47)

Similarly, the support of PK′ in Dp depends only on the set of antecedents in D
K′
p =

(P1, . . . , PK′):

supp(PK′ ,x |Dp) =
1

N

N∑
n=1

cap(xn, PK′ |Dp)

=
1

N

N∑
n=1

(
¬ cap(xn, DK

′−1
p )

)
∧ cap(xn, PK′)

=
1

N

N∑
n=1

(
K′−1∧
k=1

¬ cap(xn, Pk)

)
∧ cap(xn, PK′)

≤ 1
N

N∑
n=1

(
K−1∧
k=1

¬ cap(xn, pk)

)
∧ cap(xn, PK′)

=
1

N

N∑
n=1

(
K−1∧
k=1

¬ cap(xn, pk)

)
∧ cap(xn, pK) = supp(pK ,x | dp) ≤ λ.

(48)

The first inequality reflects the condition that DK
′−1

p ∈ φ(dK−1p ), which implies that the
set of antecedents in DK

′−1
p contains the set of antecedents in d

K−1
p , and the next equality

reflects the fact that PK′ = pK . Thus, P
′
K has insufficient support in prefix Dp, therefore

by Theorem 10, D cannot be optimal, i.e., D /∈ argmindR(d,x,y).

Proposition 15 (Insufficient accurate antecedent support propagates) Let φ(dp)
denote the set of all prefixes d′p such that the set of all antecedents in dp is a subset of
the set of all antecedents in d′p, as in (46). Let d = (dp, δp, q0,K) be a rule list with prefix

19



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

dp = (p1, . . . , pK) and labels δp = (q1, . . . , qK), such that the last antecedent pK has insuffi-
cient accurate support, i.e., the opposite of the bound in (35):

1

N

N∑
n=1

cap(xn, pK | dp) ∧ 1[qK = yn] ≤ λ. (49)

Let dK−1p = (p1, . . . , pK−1) and let D = (Dp,∆p, Q0, κ) be any rule list with prefix Dp =

(P1, . . . , Pκ) and labels ∆p = (Q1, . . . , Qκ), such that Dp starts with D
K′−1
p = (P1, . . . , PK′−1)

∈ φ(dK−1p ) and PK′ = pK . It follows that PK′ has insufficient accurate support in prefix Dp,
and furthermore, D /∈ argmind† R(d†,x,y).

Proof The accurate support of PK′ in Dp is insufficient:

1

N

N∑
n=1

cap(xn, PK′ |Dp) ∧ 1[QK′ = yn]

=
1

N

N∑
n=1

(
K′−1∧
k=1

¬ cap(xn, Pk)

)
∧ cap(xn, PK′) ∧ 1[QK′ = yn]

≤ 1
N

N∑
n=1

(
K−1∧
k=1

¬ cap(xn, pk)

)
∧ cap(xn, PK′) ∧ 1[QK′ = yn]

=
1

N

N∑
n=1

(
K−1∧
k=1

¬ cap(xn, pk)

)
∧ cap(xn, pK) ∧ 1[QK′ = yn]

=
1

N

N∑
n=1

cap(xn, pK | dp) ∧ 1[QK′ = yn]

≤ 1
N

N∑
n=1

cap(xn, pK | dp) ∧ 1[qK = yn] ≤ λ. (50)

The first inequality reflects the condition that DK
′−1

p ∈ φ(dK−1p ), the next equality reflects
the fact that PK′ = pK . For the following equality, notice that QK′ is the majority class
label of data captured by PK′ in Dp, and qK is the majority class label of data captured
by PK in dp, and recall from (48) that supp(PK′ ,x |Dp) ≤ supp(pK ,x | dp). By Theorem 11,
D /∈ argmind† R(d†,x,y).

Proposition 16 (Excessive antecedent support propagates) Define φ(dp) as in (46),
and let dp = (p1, . . . , pK) be a prefix, such that its last antecedent pK has excessive support,
i.e., the opposite of the bound in (39):

supp(pK ,x | dp) ≥ 1− supp(dK−1p ,x)− λ, (51)

where dK−1p = (p1, . . . , pK−1). Let D = (Dp,∆p, Q0, κ) be any rule list with prefix Dp =

(P1, . . . , Pκ) such that Dp starts with D
K′−1
p = (P1, . . . , PK′−1) ∈ φ(dK−1p ) and PK′ = pK . It

follows that PK′ has excessive support in prefix Dp, and furthermore, D /∈ argmindR(d,x,y).

20



Learning Certifiably Optimal Rule Lists for Categorical Data

Proof Since DK
′

p = (P1, . . . , PK′) contains all the antecedents in dp, we have that

supp(DK
′

p ,x) ≥ supp(dp,x). (52)

Expanding these two terms gives

supp(DK
′

p ,x) = supp(D
K′−1
p ,x) + supp(PK′ ,x |Dp)

≥ supp(dp,x) = supp(dK−1p ,x) + supp(pK ,x | dp) ≥ 1− λ. (53)

Rearranging gives

supp(PK′ ,x |Dp) ≥ 1− supp(DK
′−1

p ,x)− λ, (54)

thus PK′ has excessive support in Dp. By Theorem 12, D /∈ argmindR(d,x,y).

Theorem 13 implies potentially significant computational savings. During branch-and-
bound execution, if we ever encounter a prefix dp = (p1, . . . , pK−1, pK) that rejects its last
antecedent pK , then we can prune dp. Furthermore, we can also prune any prefix d

′
p whose

antecedents contains the set of antecedents in dp, in almost any order, with the constraint
that all antecedent in {p1, . . . , pK−1} precede pK .

3.10 Equivalent support bound

Let Dp be a prefix, and let ξ(Dp) be the set of all prefixes that capture exactly the same
data as Dp. Now, let d be a rule list with prefix dp in ξ(Dp), such that d has the minimum
objective over all rule lists with prefixes in ξ(Dp). Finally, let d

′ be a rule list whose prefix d′p
starts with dp, such that d

′ has the minimum objective over all rule lists whose prefixes start
with dp. Theorem 17 below implies that d

′ also has the minimum objective over all rule lists
whose prefixes start with any prefix in ξ(Dp).

Theorem 17 (Equivalent support bound) Define σ(dp) to be the set of all rule lists
whose prefixes starts with dp, as in (1). Let d = (dp, δp, q0,K) be a rule list with prefix
dp = (p1, . . . , pK), and let D = (Dp,∆p, Q0, κ) be a rule list with prefix Dp = (P1, . . . , Pκ),
such that dp and Dp capture the same data, i.e.,

{xn : cap(xn, dp)} = {xn : cap(xn, Dp)}. (55)

If the objective lower bounds of d and D obey b(dp,x,y) ≤ b(Dp,x,y), then the objective of
the optimal rule list in σ(dp) gives a lower bound on the objective of the optimal rule list
in σ(Dp):

min
d′∈σ(dp)

R(d′,x,y) ≤ min
D′∈σ(Dp)

R(D′,x,y). (56)

Proof We begin by defining four related rule lists. First, let d = (dp, δp, q0,K) be a rule list
with prefix dp = (p1, . . . , pK) and labels δp = (q1, . . . , qK). Second, let D = (Dp,∆p, Q0, κ)
be a rule list with prefix Dp = (P1, . . . , Pκ) that captures the same data as dp, and la-
bels ∆p = (Q1, . . . , Qκ). Third, let d

′ = (d′p, δ
′
p, q
′
0,K

′) ∈ σ(dp) be any rule list whose prefix

21



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

starts with dp, such that K
′ ≥ K. Denote the prefix and labels of d′ by d′p = (p1, . . . , pK ,

pK+1, . . . , pK′) and δp = (q1, . . . , qK′), respectively. Finally, define D
′ = (D′p,∆

′
p, Q

′
0, κ
′) ∈

σ(Dp) to be the ‘analogous’ rule list, i.e., whose prefix D
′
p = (P1, . . . , Pκ, Pκ+1, . . . , Pκ′) =

(P1, . . . , Pκ, pK+1, . . . , pK′) starts with Dp and ends with the same K
′ −K antecedents

as d′p. Let ∆
′
p = (Q1, . . . , Qκ′) denote the labels of D

′.
Next, we claim that the difference in the objectives of rule lists d′ and d is the same as

the difference in the objectives of rule lists D′ and D. Let us expand the first difference as

R(d′,x,y)−R(d,x,y) = `(d′,x,y) + λK ′ − `(d,x,y)− λK
= `p(d

′
p, δ
′
p,x,y) + `0(d

′
p, q
′
0,x,y)− `p(dp, δp,x,y)− `0(dp, q0,x,y) + λ(K ′ −K).

Similarly, let us expand the second difference as

R(D′,x,y)−R(D,x,y) = `(D′,x,y) + λκ′ − `(D,x,y)− λκ
= `p(D

′
p,∆

′
p,x,y) + `0(D

′
p, Q

′
0,x,y)− `p(Dp,∆p,x,y)− `0(Dp, Q0,x,y) + λ(K ′ −K),

where we have used the fact that κ′ − κ = K ′ −K.
The prefixes dp and Dp capture the same data. Equivalently, the set of data that is not

captured by dp is the same as the set of data that is not captured by Dp, i.e.,

{xn : ¬ cap(xn, dp)} = {xn : ¬ cap(xn, Dp)}. (57)

Thus, the corresponding rule lists d and D share the same default rule, i.e., q0 = Q0, yielding
the same default rule misclassification error:

`0(dp, q0,x,y) = `0(Dp, Q0,x,y). (58)

Similarly, prefixes d′p and D
′
p capture the same data, and thus rule lists d

′ and D′ have the
same default rule misclassification error:

`0(dp, q0,x,y) = `0(Dp, Q0,x,y). (59)

At this point, to demonstrate our claim relating the objectives of d, d′, D, and D′, what
remains is to show that the difference in the misclassification errors of prefixes d′p and dp is
the same as that between D′p and Dp. We can expand the first difference as

`p(d
′
p, δ
′
p,x,y)− `p(dp, δp,x,y) =

1

N

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[qk 6= yn], (60)

where we have used the fact that since d′p starts with dp, the first K rules in d
′
p make the

same mistakes as those in dp. Similarly, we can expand the second difference as

`p(D
′
p,∆

′
p,x,y)− `p(Dp,∆p,x,y) =

1

N

N∑
n=1

κ′∑
k=κ+1

cap(xn, Pk |D′p) ∧ 1[Qk 6= yn]

=
1

N

N∑
n=1

K′∑
k=K+1

cap(xn, pk |D′p) ∧ 1[Qk 6= yn]

=
1

N

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] (61)

= `p(d
′
p, δ
′
p,x,y)− `p(dp, δp,x,y).

22



Learning Certifiably Optimal Rule Lists for Categorical Data

To justify the equality in (61), we observe first that prefixes D′p and d
′
p start with κ and K

antecedents, respectively, that capture the same data. Second, prefixes D′p and d
′
p end with

exactly the same ordered list of K ′ −K antecedents, therefore for any k = 1, . . . ,K ′ −K,
antecedent Pκ+k = pK+k inD

′
p captures the same data as pK+k captures in d

′
p. It follows that

the corresponding labels are all equivalent, i.e., Qκ+k = qK+k, for all k = 1, . . . ,K
′ −K, and

consequently, the prefix misclassification error associated with the last K ′ −K antecedents
of d′p is the same as that of D

′
p. We have therefore shown that the difference between the

objectives of d′ and d is the same as that between D′ and D, i.e.,

R(d′,x,y)−R(d,x,y) = R(D′,x,y)−R(D,x,y). (62)

Next, suppose that the objective lower bounds of d and D obey b(dp,x,y) ≤ b(Dp,x,y),
therefore

R(d,x,y) = `p(dp, δp,x,y) + `0(dp, q0,x,y) + λK

= b(dp,x,y) + `0(dp, q0,x,y)

≤ b(Dp,x,y) + `0(dp, q0,x,y) = b(Dp,x,y) + `0(Dp, Q0,x,y) = R(D,x,y).
(63)

Now let d∗ be an optimal rule list with prefix constrained to start with dp,

d∗ ∈ argmin
d†∈σ(dp)

R(d†,x,y), (64)

and let K∗ be the length of d∗. Let D∗ be the analogous κ∗-rule list whose prefix starts
with Dp and ends with the same K

∗ −K antecedents as d∗, where κ∗ = κ+K∗ −K.
By (62),

R(d∗,x,y)−R(d,x,y) = R(D∗,x,y)−R(D,x,y). (65)

Furthermore, we claim that D∗ is an optimal rule list with prefix constrained to start
with Dp,

D∗ ∈ argmin
D†∈σ(Dp)

R(D†,x,y). (66)

To demonstrate (66), we consider two separate scenarios. In the first scenario, prefixes dp
and Dp are composed of the same antecedents, i.e., the two prefixes are equivalent up to a
permutation of their antecedents, and as a consequence, κ = K and κ∗ = K∗. Here, every
rule list d′′ ∈ σ(dp) that starts with dp has an analogue D′′ ∈ σ(Dp) that starts with Dp,
such that d′′ and D′′ obey (62), and vice versa, and thus (66) is a direct consequence of (65).

In the second scenario, prefixes dp and Dp are not composed of the same antecedents.
Define φ = {pk : (pk ∈ dp) ∧ (pk /∈ Dp)} to be the set of antecedents in dp that are not in Dp,
and define Φ = {Pk : (Pk ∈ Dp) ∧ (Pk /∈ dp)} to be the set of antecedents in Dp that are not
in dp; either φ 6= ∅, or Φ 6= ∅, or both.

Suppose φ 6= ∅, and let p ∈ φ be an antecedent in φ. It follows that there exists a subset
of rule lists in σ(Dp) that do not have analogues in σ(dp). Let D

′′ ∈ σ(Dp) be such a rule
list, such that its prefix D′′p = (P1, . . . , Pκ, . . . , p, . . . ) starts with Dp and contains p among

23



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

its remaining antecedents. Since p captures a subset of the data that dp captures, and Dp
captures the same data as dp, it follows that p doesn’t capture any data in D

′′
p , i.e.,

1

N

N∑
n=1

cap(xn, p |D′′p) = 0 ≤ λ. (67)

By Theorem 10, antecedent p has insufficient support in D′′, and thus D′′ cannot be op-
timal, i.e., D′′ /∈ argminD†∈σ(Dp)R(D

†,x,y). By a similar argument, if Φ 6= ∅ and P ∈ Φ,
and d′′ ∈ σ(dp) is any rule list whose prefix starts with dp and contains antecedent P , then d′′
cannot be optimal, i.e., d′′ /∈ argmind†∈σ(dp)R(d

†,x,y).
To finish justifying claim (66) for the second scenario, first define

τ(dp,Φ) ≡ {d′′ = (d′′p, δ′′p , q′′0 ,K ′′) : d′′ ∈ σ(dp) and pk /∈ Φ,∀pk ∈ d′′p} ⊂ σ(dp) (68)

to be the set of all rule lists whose prefixes start with dp and don’t contain any antecedents
in Φ. Now, recognize that the optimal prefixes in τ(dp,Φ) and σ(dp) are the same, i.e.,

argmin
d†∈τ(dp,Φ)

R(d†,x,y) = argmin
d†∈σ(dp)

R(d†,x,y), (69)

and similarly, the optimal prefixes in τ(Dp, φ) and σ(Dp) are the same, i.e.,

argmin
D†∈τ(Dp,φ)

R(D†,x,y) = argmin
D†∈σ(Dp)

R(D†,x,y). (70)

Since we have shown that every d′′ ∈ τ(dp,Φ) has a direct analogue D′′ ∈ τ(Dp, φ), such
that d′′ and D′′ obey (62), and vice versa, we again have (66) as a consequence of (65).

We can now finally combine (63) and (66) to obtain

min
d′∈σ(dp)

R(d′,x,y) = R(d∗,x,y) ≤ R(D∗,x,y) = min
D′∈σ(Dp)

R(D′,x,y). (71)

Thus, if prefixes dp and Dp capture the same data, and their objective lower bounds obey
b(dp,x,y) ≤ b(Dp,x,y), Theorem 17 implies that we can prune Dp. Next, in Sections 3.11
and 3.12, we highlight and analyze the special case of prefixes that capture the same data
because they contain the same antecedents.

3.11 Permutation bound

Let P = {pk}Kk=1 be a set of K antecedents, and let Π be the set of all K-prefixes corre-
sponding to permutations of antecedents in P . Now, let d be a rule list with prefix dp in Π,
such that d has the minimum objective over all rule lists with prefixes in Π. Finally, let d′

be a rule list whose prefix d′p starts with dp, such that d
′ has the minimum objective over all

rule lists whose prefixes start with dp. Corollary 18 below, which can be viewed as special
case of Theorem 17, implies that d′ also has the minimum objective over all rule lists whose
prefixes start with any prefix in Π.

24



Learning Certifiably Optimal Rule Lists for Categorical Data

Corollary 18 (Permutation bound) Let π be any permutation of {1, . . . ,K}, and de-
fine σ(dp) = {(d′p, δ′p, q′0,K ′) : d′p starts with dp} to be the set of all rule lists whose prefixes
start with dp. Let d = (dp, δp, q0,K) and D = (Dp,∆p, Q0,K) denote rule lists with prefixes
dp = (p1, . . . , pK) and Dp = (pπ(1), . . . , pπ(K)), respectively, i.e., the antecedents in Dp cor-
respond to a permutation of the antecedents in dp. If the objective lower bounds of d and D
obey b(dp,x,y) ≤ b(Dp,x,y), then the objective of the optimal rule list in σ(dp) gives a
lower bound on the objective of the optimal rule list in σ(Dp):

min
d′∈σ(dp)

R(d′,x,y) ≤ min
D′∈σ(Dp)

R(D′,x,y). (72)

Proof Since prefixes dp and Dp contain the same antecedents, they both capture the same
data. Thus, we can apply Theorem 17.

Thus if prefixes dp and Dp have the same antecedents, up to a permutation, and their
objective lower bounds obey b(dp,x,y) ≤ b(Dp,x,y), Corollary 18 implies that we can
prune Dp. We call this symmetry-aware pruning, and we illustrate the subsequent compu-
tational savings next in §3.12.

3.12 Upper bound on prefix evaluations with symmetry-aware pruning

Here, we present an upper bound on the total number of prefix evaluations that accounts for
the effect of symmetry-aware pruning (§3.11). Since every subset of K antecedents generates
an equivalence class of K! prefixes equivalent up to permutation, symmetry-aware pruning
dramatically reduces the search space.

First, notice that Algorithm 1 describes a breadth-first exploration of the state space of
rule lists. Now suppose we integrate symmetry-aware pruning into our execution of branch-
and-bound, so that after evaluating prefixes of length K, we only keep a single best prefix
from each set of prefixes equivalent up to a permutation.

Theorem 19 (Upper bound on prefix evaluations with symmetry-aware pruning)
Consider a state space of all rule lists formed from a set S of M antecedents, and consider
the branch-and-bound algorithm with symmetry-aware pruning. Define Γtot(S) to be the total
number of prefixes evaluated. For any set S of M rules,

Γtot(S) ≤ 1 +
K∑
k=1

1

(k − 1)!
· M !

(M − k)!
, (73)

where K = min(b1/2λc,M).

Proof By Corollary 5, K ≡ min(b1/2λc,M) gives an upper bound on the length of any
optimal rule list. The algorithm begins by evaluating the empty prefix, followed by M pre-
fixes of length k = 1, then P (M, 2) prefixes of length k = 2, where P (M, 2) is the number of
size-2 subsets of {1, . . . ,M}. Before proceeding to length k = 3, we keep only C(M, 2) pre-
fixes of length k = 2, where C(M,k) denotes the number of k-combinations of M . Now, the

25



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

number of length k = 3 prefixes we evaluate is C(M, 2)(M − 2). Propagating this forward
gives

Γtot(S) ≤ 1 +
K∑
k=1

C(M,k − 1)(M − k + 1) = 1 +
K∑
k=1

1

(k − 1)!
· M !

(M − k)!
. (74)

Γtot(S) ≤ 1 +
K∑
k=1

C(M,k − 1)(M − k + 1). (75)

Pruning based on permutation symmetries thus yields significant computational savings.
Let us compare, for example, to the näıve number of prefix evaluations given by the upper
bound in Proposition 8. If M = 100 and K = 5, then the näıve number is about 9.1× 109,
while the reduced number due to symmetry-aware pruning is about 3.9× 108, which is
smaller by a factor of about 23. If M = 1000 and K = 10, the number of evaluations falls
from about 9.6× 1029 to about 2.7× 1024, which is smaller by a factor of about 360,000.

While 1024 seems infeasibly enormous, it does not represent the number of rule lists we
evaluate. As we show in our experiments (§6), our permutation bound in Corollary 18 and
our other bounds together conspire to reduce the search space to a size manageable on a
single computer. The choice of M = 1000 and K = 10 in our example above corresponds to
the state space size our efforts target. K = 10 rules represents a (heuristic) upper limit on
the size of an interpretable rule list, and M = 1000 represents the approximate number of
rules with sufficiently high support (Theorem 10) we expect to obtain via rule mining (§3.1).

3.13 Similar support bound

We now present a relaxation of our equivalent support bound from Theorem 17. Note that
our implementation (§5) does not currently leverage the bound in Theorem 20.

Theorem 20 (Similar support bound) Define σ(dp) to be the set of all rule lists whose
prefixes starts with dp, as in (1). Let dp = (p1, . . . , pK) and Dp = (P1, . . . , Pκ) be prefixes
that capture nearly the same data. Specifically, define ω to be the normalized support of data
captured by dp and not captured by Dp, i.e.,

ω ≡ 1
N

N∑
n=1

¬ cap(xn, Dp) ∧ cap(xn, dp). (76)

Similarly, define Ω to be the normalized support of data captured by Dp and not captured
by dp, i.e.,

Ω ≡ 1
N

N∑
n=1

¬ cap(xn, dp) ∧ cap(xn, Dp). (77)

26



Learning Certifiably Optimal Rule Lists for Categorical Data

We can bound the difference between the objectives of the optimal rule lists in σ(dp) and
σ(Dp) as follows:

min
D†∈σ(Dp)

R(D†,x,y)− min
d†∈σ(dp)

R(d†,x,y) ≥ b(Dp,x,y)− b(dp,x,y)− ω − Ω, (78)

where b(dp,x,y) and b(Dp,x,y) are the objective lower bounds of d and D, respectively.

Proof We begin by defining four related rule lists. First, let d = (dp, δp, q0,K) be a rule list
with prefix dp = (p1, . . . , pK) and labels δp = (q1, . . . , qK). Second, let D = (Dp,∆p, Q0, κ)
be a rule list with prefix Dp = (P1, . . . , Pκ) and labels ∆p = (Q1, . . . , Qκ). Define ω as
in (76) and Ω as in (77), and require that ω,Ω ≤ λ. Third, let d′ = (d′p, δ′p, q′0,K ′) ∈ σ(dp)
be any rule list whose prefix starts with dp, such that K

′ ≥ K. Denote the prefix and la-
bels of d′ by d′p = (p1, . . . , pK , pK+1, . . . , pK′) and δp = (q1, . . . , qK′), respectively. Finally,
define D′ = (D′p,∆

′
p, Q

′
0, κ
′) ∈ σ(Dp) to be the ‘analogous’ rule list, i.e., whose prefix D′p =

(P1, . . . , Pκ, Pκ+1, . . . , Pκ′) = (P1, . . . , Pκ, pK+1, . . . , pK′) starts with Dp and ends with the
same K ′ −K antecedents as d′p. Let ∆′p = (Q1, . . . , Qκ′) denote the labels of D′.

The smallest possible objective for D′, in relation to the objective of d′, reflects both
the difference between the objective lower bounds of D and d and the largest possible
discrepancy between the objectives of d′ and D′. The latter would occur if d′ misclassified
all the data corresponding to both ω and Ω while D′ correctly classified this same data,
thus

R(D′,x,y) ≥ R(d′,x,y) + b(Dp,x,y)− b(dp,x,y)− ω − Ω. (79)

Now let D∗ be an optimal rule list with prefix constrained to start with Dp,

D∗ ∈ argmin
D†∈σ(Dp)

R(D†,x,y), (80)

and let κ∗ be the length of D∗. Also let d∗ be the analogous K∗-rule list whose prefix starts
with dp and ends with the same κ

∗ − κ antecedents as D∗, where K∗ = K + κ∗ − κ. By (79),

min
D†∈σ(Dp)

R(D†,x,y) = R(D∗,x,y)

≥ R(d∗,x,y) + b(Dp,x,y)− b(dp,x,y)− ω − Ω
≥ min

d†∈σ(dp)
R(d†,x,y) + b(Dp,x,y)− b(dp,x,y)− ω − Ω. (81)

Theorem 20 implies that if prefixes dp and Dp are similar, and we know the optimal
objective of rule lists starting with dp, then

min
D′∈σ(Dp)

R(D′,x,y) ≥ min
d′∈σ(dp)

R(d′,x,y) + b(Dp,x,y)− b(dp,x,y)− χ

≥ Rc + b(Dp,x,y)− b(dp,x,y)− χ, (82)

27



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

where Rc is the current best objective, and χ is the normalized support of the set of data
captured either exclusively by dp or exclusively by Dp. It follows that

min
D′∈σ(Dp)

R(D′,x,y) ≥ Rc + b(Dp,x,y)− b(dp,x,y)− χ ≥ Rc (83)

if b(Dp,x,y)− b(dp,x,y) ≥ χ. To conclude, we summarize this result and combine it with
our notion of lookahead from Lemma 2. During branch-and-bound execution, if we demon-
strate that mind′∈σ(dp)R(d

′,x,y) ≥ Rc, then we can prune all prefixes that start with any
prefix D′p in the following set:{

D′p : b(D
′
p,x,y) + λ− b(dp,x,y) ≥

1

N

N∑
n=1

cap(xn, dp)⊕ cap(xn, D′p)

}
. (84)

3.14 Equivalent points bound

The bounds in this section quantify the following: If multiple observations that are not
captured by a prefix dp have identical features and opposite labels, then no rule list that
starts with dp can correctly classify all these observations. For each set of such observations,
the number of mistakes is at least the number of observations with the minority label within
the set.

Consider a dataset {(xn, yn)}Nn=1 and also a set of antecedents {sm}Mm=1. Define dis-
tinct datapoints to be equivalent if they are captured by exactly the same antecedents,
i.e., xi 6= xj are equivalent if

1

M

M∑
m=1

1[cap(xi, sm) = cap(xj , sm)] = 1. (85)

Notice that we can partition a dataset into sets of equivalent points; let {eu}Uu=1 enumerate
these sets. Now define θ(eu) to be the normalized support of the minority class label with
respect to set eu, e.g., let

eu = {xn : 1[cap(xn, sm) = cap(xi, sm)]}, (86)

and let qu be the minority class label among points in eu, then

θ(eu) =
1

N

N∑
n=1

1[xn ∈ eu] ∧ 1[yn = qu]. (87)

The existence of equivalent points sets with non-singleton support yields a tighter ob-
jective lower bound that we can combine with our other bounds; as our experiments demon-
strate (§6), the practical consequences can be dramatic. First, for intuition, we present a
general bound in Proposition 21; next, we explicitly integrate this bound into our framework
in Theorem 22.

Proposition 21 (General equivalent points bound) Let d = (dp, δp, q0,K) be a rule
list, then

R(d,x,y) ≥
U∑
u=1

θ(eu) + λK. (88)

28



Learning Certifiably Optimal Rule Lists for Categorical Data

Proof Recall that the objective is R(d,x,y) = `(d,x,y) + λK, where the misclassification
error `(d,x,y) is given by

`(d,x,y) = `0(dp, q0,x,y) + `p(dp, δp,x,y)

=
1

N

N∑
n=1

(
¬ cap(xn, dp) ∧ 1[q0 6= yn] +

K∑
k=1

cap(xn, pk | dp) ∧ 1[qk 6= yn]

)
. (89)

In the context of the rule list d, each set of equivalent points is classified by either a specific
antecedent pk in d, or the default rule p0. For a set of equivalent points u, the rule list d
correctly classifies either points that have the majority class label, or points that have
the minority class label. Thus, d misclassifies a number of points in u at least as great as
the number of points with the minority class label. To translate this into a lower bound
on `(d,x,y), we first sum over all sets of equivalent points, and then for each such set, count
differences between class labels and the minority class label of the set, instead of counting
mistakes:

`(d,x,y)

=
1

N

U∑
u=1

N∑
n=1

(
¬ cap(xn, dp) ∧ 1[q0 6= yn] +

K∑
k=1

cap(xn, pk | dp) ∧ 1[qk 6= yn]

)
∧ 1[xn ∈ eu]

≥ 1
N

U∑
u=1

N∑
n=1

(
¬ cap(xn, dp) ∧ 1[yn = qu] +

K∑
k=1

cap(xn, pk | dp) ∧ 1[yn = qu]

)
∧ 1[xn ∈ eu].

(90)

Next, we factor out the indicator for equivalent point set membership, which yields a term
that sums to one, because every datum is either captured or not captured by prefix dp.

`(d,x,y) =
1

N

U∑
u=1

N∑
n=1

(
¬ cap(xn, dp) +

K∑
k=1

cap(xn, pk | dp)

)
∧ 1[xn ∈ eu] ∧ 1[yn = qu]

=
1

N

U∑
u=1

N∑
n=1

(¬ cap(xn, dp) + cap(xn, dp)) ∧ 1[xn ∈ eu] ∧ 1[yn = qu]

=
1

N

U∑
u=1

N∑
n=1

1[xn ∈ eu] ∧ 1[yn = qu] =
U∑
u=1

θ(eu), (91)

where the final equality applies the definition of θ(eu) in (87). Therefore, R(d,x,y) =
`(d,x,y) + λK ≥

∑U
u=1 θ(eu) + λK.

Now, recall that to obtain our lower bound b(dp,x,y) in (10), we simply deleted the
default rule misclassification error `0(dp, q0,x,y) from the objective R(d,x,y). Theorem 22
obtains a tighter objective lower bound via a tighter lower bound on the default rule mis-
classification error, 0 ≤ b0(dp,x,y) ≤ `0(dp, q0,x,y).

29



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Theorem 22 (Equivalent points bound) Let d be a rule list with prefix dp and lower
bound b(dp,x,y), then for any rule list d

′ ∈ σ(d) whose prefix d′p starts with dp,

R(d′,x,y) ≥ b(dp,x,y) + b0(dp,x,y), (92)

where

b0(dp,x,y) =
1

N

U∑
u=1

N∑
n=1

¬ cap(xn, dp) ∧ 1[xn ∈ eu] ∧ 1[yn = qu]. (93)

Proof We derive a lower bound on the default rule misclassification error `0(dp, q0,x,y),
analogous to the lower bound (90) on the misclassification error `(d,x,y) in the proof of
Proposition 21. As before, we sum over all sets of equivalent points, and then for each such
set, we count differences between class labels and the minority class label of the set, instead
of counting mistakes made by the default rule:

`0(dp, q0,x,y) =
1

N

N∑
n=1

¬ cap(xn, dp) ∧ 1[q0 6= yn]

=
1

N

U∑
u=1

N∑
n=1

¬ cap(xn, dp) ∧ 1[q0 6= yn] ∧ 1[xn ∈ eu]

≥ 1
N

U∑
u=1

N∑
n=1

¬ cap(xn, dp) ∧ 1[yn = qu] ∧ 1[xn ∈ eu] = b0(dp,x,y), (94)

where the final equality comes from the definition of b0(dp,x,y) in (93). Since we can write
the objective R(d,x,y) as the sum of the objective lower bound b(dp,x,y) and default rule
misclassification error `0(dp, q0,x,y), applying (94) gives a lower bound on R(d,x,y):

R(d,x,y) = `p(dp, δp,x,y) + `0(dp, q0,x,y) + λK = b(dp,x,y) + `0(dp, q0,x,y)

≥ b(dp,x,y) + b0(dp,x,y). (95)

It follows that for any rule list d′ ∈ σ(d) whose prefix d′p starts with dp, we have

R(d′,x,y) ≥ b(d′p,x,y) + b0(d′p,x,y). (96)

Finally, we show that the lower bound on R(d,x,y) in (95) is not greater than the lower
bound on R(d′,x,y) in (96). First, let us define

Υ(d′p,K,x,y) ≡
1

N

U∑
u=1

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[xn ∈ eu] ∧ 1[yn = qu]. (97)

30



Learning Certifiably Optimal Rule Lists for Categorical Data

Now, we write a lower bound on b(d′p,x,y) with respect to b(dp,x,y):

b(d′p,x,y) = `p(d
′
p, δp,x,y) + λK

′ =
1

N

N∑
n=1

K′∑
k=1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] + λK ′

= `p(dp, δp,x,y) + λK +
1

N

N∑
n=1

K′∑
k=K

cap(xn, pk | d′p) ∧ 1[qk 6= yn] + λ(K ′ −K)

= b(dp,x,y) +
1

N

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] + λ(K ′ −K)

= b(dp,x,y) +
1

N

U∑
u=1

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] ∧ 1[xn ∈ eu] + λ(K ′ −K)

≥ b(dp,x,y) +
1

N

U∑
u=1

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[yn = qu] ∧ 1[xn ∈ eu] + λ(K ′ −K)

= b(dp,x,y) + Υ(d
′
p,K,x,y) + λ(K

′ −K). (98)

Next, we write b0(dp,x,y) with respect to b0(d
′
p,x,y),

b0(dp,x,y) =
1

N

U∑
u=1

N∑
n=1

¬ cap(xn, dp) ∧ 1[xn ∈ eu] ∧ 1[yn = qu]

=
1

N

U∑
u=1

N∑
n=1

(
¬ cap(xn, d′p) +

K′∑
k=K+1

cap(xn, pk | d′p)

)
∧ 1[xn ∈ eu] ∧ 1[yn = qu]

= b0(d
′
p,x,y) +

1

N

U∑
u=1

N∑
n=1

K′∑
k=K+1

cap(xn, pk | d′p) ∧ 1[xn ∈ eu] ∧ 1[yn = qu], (99)

thus rearranging gives

b0(d
′
p,x,y) = b0(dp,x, y)−Υ(d′p,K,x,y). (100)

Combining (96) with first (100) and then (98) gives:

R(d′,x,y) ≥ b(d′p,x,y) + b0(d′p,x,y)
= b(d′p,x,y) + b0(dp,x, y)−Υ(d′p,K,x,y)
≥ b(dp,x,y) + Υ(d′p,K,x,y) + λ(K ′ −K) + b0(dp,x, y)−Υ(d′p,K,x,y)
= b(dp,x,y) + b0(dp,x, y) + λ(K

′ −K) ≥ b(dp,x,y) + b0(dp,x,y). (101)

31



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

4. Incremental computation

For every prefix dp evaluated during Algorithm 1’s execution, we compute the objective
lower bound b(dp,x,y) and sometimes the objective R(d,x,y) of the corresponding rule
list d. These calculations are the dominant computations with respect to execution time.
This motivates our use of a highly optimized library, designed by Yang et al. (2016) for
representing rule lists and performing operations encountered in evaluating functions of rule
lists. Furthermore, we exploit the hierarchical nature of the objective function and its lower
bound to compute these quantities incrementally throughout branch-and-bound execution.
In this section, we provide explicit expressions for the incremental computations that are
central to our approach. Later, in §5, we describe a cache data structure for supporting our
incremental framework in practice.

For completeness, before presenting our incremental expressions, let us begin by writing
down the objective lower bound and objective of the empty rule list, d = ((), (), q0, 0), the
first rule list evaluated in Algorithm 1. Since its prefix contains zero rules, it has zero prefix
misclassification error and also has length zero. Thus, the empty rule list’s objective lower
bound is zero:

b((),x,y) = `p((), (),x,y) + λ · 0 = 0. (102)

Since none of the data are captured by the empty prefix, the default rule corresponds to
the majority class, and the objective corresponds to the default rule misclassification error:

R(d,x,y) = `(d,x,y) + λ · 0 = `p((), (),x,y) + `0((), q0,x,y)
= b((),x,y) + `0((), q0,x,y) = `0((), q0,x,y). (103)

Now, we derive our incremental expressions for the objective function and its lower
bound. Let d = (dp, δp, q0,K) and d

′ = (d′p, δ
′
p, q
′
0,K + 1) be rule lists such that prefix dp =

(p1, . . . , pK) is the parent of d
′
p = (p1, . . . , pK , pK+1). Let δp = (q1, . . . , qK) and δ

′
p = (q1, . . . ,

qK , qK+1) be the corresponding labels. The hierarchical structure of Algorithm 1 enforces
that if we ever evaluate d′, then we will have already evaluated both the objective and ob-
jective lower bound of its parent, d. We would like to reuse as much of these computations as
possible in our evaluation of d′. We can write the objective lower bound of d′ incrementally,
with respect to the objective lower bound of d:

b(d′p,x,y) = `p(d
′
p, δ
′
p,x,y) + λ(K + 1)

=
1

N

N∑
n=1

K+1∑
k=1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] + λ(K + 1) (104)

= `p(dp, δp,x,y) + λK + λ+
1

N

N∑
n=1

cap(xn, pK+1 | d′p) ∧ 1[qK+1 6= yn]

= b(dp,x,y) + λ+
1

N

N∑
n=1

cap(xn, pK+1 | d′p) ∧ 1[qK+1 6= yn]

= b(dp,x,y) + λ+
1

N

N∑
n=1

¬ cap(xn, dp) ∧ cap(xn, pK+1) ∧ 1[qK+1 6= yn]. (105)

32



Learning Certifiably Optimal Rule Lists for Categorical Data

Thus, if we store b(dp,x,y), then we can reuse this quantity when computing b(d
′
p,x,y).

Transforming (104) into (105) yields a significantly simpler expression that is a function of
the stored quantity b(dp,x,y). For the objective of d

′, first let us write a näıve expression:

R(d′,x,y) = `(d′,x,y) + λ(K + 1) = `p(d
′
p, δ
′
p,x,y) + `0(d

′
p, q
′
0,x,y) + λ(K + 1)

=
1

N

N∑
n=1

K+1∑
k=1

cap(xn, pk | d′p) ∧ 1[qk 6= yn] +
1

N

N∑
n=1

¬ cap(xn, d′p) ∧ 1[q′0 6= yn] + λ(K + 1).

(106)

Instead, we can compute the objective of d′ incrementally with respect to its objective lower
bound:

R(d′,x,y) = `p(d
′
p, δ
′
p,x,y) + `0(d

′
p, q
′
0,x,y) + λ(K + 1)

= b(d′p,x,y) + `0(d
′
p, q
′
0,x, y)

= b(d′p,x,y) +
1

N

N∑
n=1

¬ cap(xn, d′p) ∧ 1[q′0 6= yn]

= b(d′p,x,y) +
1

N

N∑
n=1

¬ cap(xn, dp) ∧ (¬ cap(xn, pK+1)) ∧ 1[q′0 6= yn]. (107)

The expression in (107) is much simpler than the näıve one in (106), and is a function
of b(d′p,x,y), which we computed in (105). Though we could compute the objective of d

′

incrementally with respect to that of d, doing so would in practice require that we also
store R(d,x,y); we prefer the approach suggested by (107) since it avoids this additional
storage overhead.

We present an incremental branch-and-bound procedure in Algorithm 2, and show the
incremental computations of the objective lower bound (105) and objective (107) as two
separate functions in Algorithms 3 and 4, respectively. In Algorithm 2, we use a cache to
store prefixes and their objective lower bounds. Algorithm 2 additionally reorganizes the
structure of Algorithm 1 to group together the computations associated with all children
of a particular prefix. This has two advantages. The first is to consolidate cache queries: all
children of the same parent prefix compute their objective lower bounds with respect to the
parent’s stored value, and we only require one cache ‘find’ operation for the entire group
of children, instead of a separate query for each child. The second is to shrink the queue’s
size: instead of adding all of a prefix’s children as separate queue elements, we represent
the entire group of children in the queue by a single element. Since the number of children
associated with each prefix is close to the total number of possible antecedents, both of these
effects can yield significant savings. For example, if we are trying to optimize over rule lists
formed from a set of 1000 antecedents, then the maximum queue size in Algorithm 2 will
be smaller than that in Algorithm 1 by a factor of nearly 1000.

5. Implementation

We implement our algorithm using a collection of optimized data structures: a trie (prefix
tree), a symmetry-aware map, and a queue. The trie acts like a cache, keeping track of

33



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Algorithm 2 Incremental branch-and-bound for learning rule lists, for simplicity, from a
cold start. We explicitly show the incremental objective lower bound and objective functions
in Algorithms 3 and 4, respectively.

Input: Objective function R(d,x,y), objective lower bound b(dp,x,y), set of antecedents
S = {sm}Mm=1, training data (x,y) = {(xn, yn)}Nn=1, regularization parameter λ
Output: Provably optimal rule list d∗ with minimum objective R∗

dc ← ((), (), q0, 0) . Initialize current best rule list with empty rule list
Rc ← R(dc,x,y) . Initialize current best objective
Q← queue( [ ( ) ] ) . Initialize queue with empty prefix
C ← cache( [ ( ( ) , 0 ) ] ) . Initialize cache with empty prefix and its objective lower bound
while Q not empty do . Optimization complete when the queue is empty

dp ← Q.pop( ) . Remove a prefix dp from the queue
b(dp,x,y)← C.find(dp) . Look up dp’s lower bound in the cache
u← ¬ cap(x, dp) . Bit vector indicating data not captured by dp
for s in S do . Evaluate all of dp’s children

if s not in dp then
Dp ← (dp, s) . Branch: Generate child Dp
v← u ∧ cap(x, s) . Bit vector indicating data captured by s in Dp
b(Dp,x,y)← b(dp,x,y) + λ + IncrementalLowerBound(v,y, N)
if b(Dp,x,y) < R

c then . Bound: Apply bound from Theorem 1
R(D,x,y)← b(Dp,x,y) + IncrementalObjective(u,v,y, N)
if R(D,x,y) < Rc then

(dc, Rc)← (D,R(D,x,y)) . Update current best rule list and objective
end if
Q.push(Dp) . Add Dp to the queue
C.insert(Dp, b(Dp,x,y)) . Add Dp and its lower bound to the cache

end if
end if

end for
end while
(d∗, R∗)← (dc, Rc) . Identify provably optimal rule list and objective

rule lists we have already evaluated. Each node in the trie contains metadata associated
with that corresponding rule list; the metadata consists of bookkeeping information such
as what child rule lists are feasible and the lower bound and accuracy for that rule list. We
also track the best observed minimum objective and its associated rule list.

The symmetry-aware map supports symmetry-aware pruning. We implement this using
the C++ STL unordered map, to map all permutations of a set of antecedents to a key,
whose value contains the best ordering of those antecedents (i.e., the prefix with the small-
est lower bound). Every antecedent is associated with an index, and we call the numerically
sorted order of a set of antecedents its canonical order. Thus by querying a set of antecedents
by its canonical order, all permutations map to the same key. The symmetry-aware map
dominates memory usage for problems that explore longer prefixes. Before inserting per-

34



Learning Certifiably Optimal Rule Lists for Categorical Data

Algorithm 3 Incremental objective lower bound (105) used in Algorithm 2.

Input: Bit vector v ∈ {0, 1}N indicating data captured by s, the last antecedent in Dp,
bit vector of class labels y ∈ {0, 1}N , number of observations N
Output: Component of D’s misclassification error due to data captured by s

function IncrementalLowerBound(v,y, N)
nv = sum(v) . Number of data captured by s, the last antecedent in Dp
w← v ∧ y . Bit vector indicating data captured by s with label 1
nw = sum(w) . Number of data captured by s with label 1
if nw/nv > 0.5 then

return (nv − nw)/N . Misclassification error of the rule s→ 1
else

return nw/N . Misclassification error of the rule s→ 0
end if

end function

Algorithm 4 Incremental objective function (107) used in Algorithm 2.

Input: Bit vector u ∈ {0, 1}N indicating data not captured by Dp’s parent prefix, bit
vector v ∈ {0, 1}N indicating data not captured by s, the last antecedent in Dp, bit
vector of class labels y ∈ {0, 1}N , number of observations N
Output: Component of D’s misclassification error due to its default rule

function IncrementalObjective(u,v,y, N)
f ← u ∧ ¬v . Bit vector indicating data not captured by Dp
nf = sum(f) . Number of data not captured by Dp
g← f ∧ y . Bit vector indicating data not captured by Dp with label 1
ng = sum(w) . Number of data not captued by Dp with label 1
if nf/ng > 0.5 then

return (nf − ng)/N . Default rule misclassification error with label 1
else

return ng/N . Default rule misclassification error with label 0
end if

end function

mutation Pi into the symmetry-aware map, we check if there exists a permutation Pj of Pi
already in the map. If the lower bound of Pi is better than that of Pj , we update the map
and remove Pj and its subtree from the trie. Otherwise we do nothing (i.e., we do not insert
Pi into the symmetry-aware map or the trie).

We use a queue to store all of the leaves of the trie that still need to be explored. We order
entries in the queue to implement several different policies. A first-in-first-out (FIFO) queue
implements breadth-first search (BFS), and a priority queue implements best-first search.
Example priority queue policies include ordering by the lower bound, the objective, or a
custom metric that maps prefixes to real values. We also support a stochastic exploration

35



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

process that bypasses the need for a queue by instead following random paths from the root
to leaves. We find that ordering by the lower bound and other priority metrics often leads
to a shorter runtime than using BFS.

Mapping our algorithm to our data structures produces the following execution strategy.
While the trie contains unexplored leaves, a scheduling policy selects the next prefix to
extend. Then, for every antecedent that is not already in this prefix, we calculate the lower
bound, objective, and other metrics for the rule list formed by appending the antecedent
to the prefix. If the lower bound of the new rule list is less than the current minimum
objective, we insert that rule list into the symmetry-aware map, trie, and queue, and, if
relevant, update the current minimum objective. If the lower bound is greater than the
minimum objective, then no extension of this rule list could possibly be optimal, thus we
do not insert the new rule list into the tree or queue. We also leverage our other bounds
from §3 to aggressively prune the search space.

During execution, we garbage collect the trie. Each time we update the minimum ob-
jective, we traverse the trie in a depth-first manner, deleting all subtrees of any node with
lower bound larger than the current minimum objective. At other times, when we encounter
a node with no children, we prune upwards–deleting that node and recursively traversing
the tree towards the root, deleting any childless nodes. This garbage collection allows us
to constrain the trie’s memory consumption, though in our experiments we observe the
minimum objective to decrease only a small number of times.

Our implementation of CORELS is at https://github.com/nlarusstone/corels.

6. Experiments

Our experimental analysis addresses five questions: (1) How does CORELS’ accuracy com-
pare to other algorithms? (2) How does CORELS’ model size compare to other algorithms?
(3) How rapidly does the objective function converge? (4) How rapidly does CORELS prune
the search space? (5) How much does each of the implementation optimizations contribute
to CORELS’ performance?

All results that we present were executed on a server with two Intel Xeon E5-2699 v4
(55 MB cache, 2.20 GHz) processors and 448 GB RAM. Except where we mention a memory
constraint, all experiments can run comfortably on smaller machines, e.g., a laptop with
16GB RAM.

Our evaluation focuses on two socially-important prediction problems associated with
recent, publicly-available datasets:

• Predicting which individuals in the ProPublica COMPAS dataset (Larson et al., 2016)
recidivate within two years.

• Using the NYCLU 2014 stop-and-frisk dataset (New York Civil Liberties Union, 2014)
to predict whether a weapon will be found on a stopped individual who is frisked or
searched.

Our choice of and approach to the second problem is inspired by the work of Goel et al.
(2016), who develop regression models to analyze racial disparities in New York City’s stop-
and-frisk policy, for a similar, larger dataset. In particular, the authors arrive at a simple

36

https://github.com/nlarusstone/corels


Learning Certifiably Optimal Rule Lists for Categorical Data

if (location = transit authority) then predict yes
else if (stop reason = suspicious object) then predict yes
else if (stop reason = suspicious bulge) then predict yes
else predict no

Figure 3: An example rule list that predicts whether a weapon will be found on a stopped
individual who is frisked or searched, for the NYCLU stop-and-frisk dataset. This is the
most common optimal rule list found by CORELS across 10 cross-validation folds; the others
contain the same rules, up to a permutation.

GL
M

SV
M

Ad
aB

oo
st
CA

RT
C4

.5 RF

RI
PP

ER
SB

RL

CO
RE

LS
0.63

0.65

0.67

0.69

0.71

A
cc

u
ra

cy

Recidivism prediction (ProPublica)

GL
M

SV
M

Ad
aB

oo
st
CA

RT
C4

.5 RF
SB

RL

CO
RE

LS
0.62

0.65

0.68

0.71

0.74

Weapon prediction (NYCLU)

Figure 4: Comparison of CORELS and a panel of eight other algorithms: logistic regres-
sion (GLM), support vector machines (SVM), AdaBoost, CART, C4.5, random forests (RF),
RIPPER, scalable Bayesian rule lists (SBRL). Test accuracy means (white squares), stan-
dard deviations (error bars), and values (colors correspond to folds), for 10-fold cross-
validation experiments. Left: Two-year recidivism prediction for the ProPublica COMPAS
dataset. For CORELS, we use regularization parameter λ = 0.005. Right: Weapon predic-
tion for the NYCLU stop-and-frisk dataset. For CORELS, we use λ = 0.01. Note that we
were unable to execute RIPPER for the NYCLU problem.

and interpretable heuristic that could potentially help police officers more effectively decide
when to frisk and/or search stopped individuals, i.e., when such interventions are likely to
discover criminal possession of a weapon.

We first ran a 10-fold cross validation experiment using CORELS and eight other al-
gorithms: logistic regression, support vector machines, AdaBoost, CART, C4.5, random
forests, RIPPER, and scalable Bayesian rule lists (SBRL). 3 We use standard R packages,
with default parameter settings, for the first seven algorithms. 4

Figures 1 and 3 show example optimal rule lists that CORELS learns for the ProPublica
and NYCLU datasets, respectively. While our goal is to provide illustrative examples, and
not to provide a detailed analysis nor to advocate for the use of these specific models, we
note that these rule lists are short and easy to understand. In particular, the three-rule list
for weapon prediction in Figure 3 has the spirit of the heuristic strategy presented by Goel

3. For SBRL, we use the C implementation at https://github.com/Hongyuy/sbrlmod.
4. For CART, C4.5 (J48), and RIPPER, i.e., the tree and rule list learning algorithms, we use the imple-

mentations from the R packages rpart, RWeka, and caret, respectively. By default, CART uses complexity
parameter cp = 0.01, and C4.5 uses complexity parameter C = 0.25.

37

https://github.com/Hongyuy/sbrlmod


Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

0 5 10 15 20 25 30 35
Model size

0.60

0.62

0.64

0.66

0.68

0.70

A
cc

u
ra

cy

Two-year recidivism prediction (ProPublica dataset)

CORELS (.005)

CORELS (.01)

CORELS (.02)

RIPPER

SBRL

CART (.001)

CART (.003)

CART (.01)

CART (.03)

CART (.1)

C4.5 (.05)

C4.5 (.15)

C4.5 (.25)

C4.5 (.35)

C4.5 (.45)

0 5 10 15 20 25 30 35 40 45 50 55
Model size

0.63

0.65

0.67

0.69

0.71

0.73

0.75

A
cc

u
ra

cy

Weapon prediction (NYCLU stop-and-frisk dataset)

CORELS (.0025)

CORELS (.01)

CORELS (.04)

SBRL

CART (.001)

CART (.003)

CART (.01)

CART (.1)

Figure 5: Training and test accuracy as a function of model size. For CORELS, CART,
and C4.5, we vary the regularization parameter λ, and complexity parameters cp and C,
respectively; numbers within parentheses in the legend indicate parameter values. Note
that the CART implementation sets cp = 0.01 by default, and C4.5 uses C = 0.25. Legend
markers and error bars indicate means and standard deviations, respectively, of test accuracy
across cross-validation folds. Small circles mark associated training accuracy means. Top:
Two-year recidivism prediction for the ProPublica COMPAS dataset. None of the models
exhibit significant overfitting: mean training accuracy never exceeds mean test accuracy by
more than about 0.01. Bottom: Weapon prediction for the NYCLU stop-and-frisk dataset.
Only CART with cp = 0.001 significantly overfits. We do not depict C4.5, which finds large
models (> 100 leaves) and dramatically overfits for all tested parameters.

et al. (2016) that combines three stop criteria and is based on a reduced version of their
full regression model.

Figure 4 shows that there were no statistically significant differences in algorithm ac-
curacies. In fact, the difference between folds was far larger than the difference between
algorithms. We conclude that CORELS produces models whose accuracy is comparable to
those found via other algorithms.

Figure 5 summarizes differences in accuracy and model size for CORELS and other
tree (CART, C4.5) and rule list (RIPPER, SBRL) learning algorithms. For both problems,
CORELS can learn short rule lists without sacrificing accuracy.

38



Learning Certifiably Optimal Rule Lists for Categorical Data

10-3 10-2 10-1 100 101 102 103 104
0.0

0.1

0.2

0.3

0.4

0.5

V
a
lu

e

1

2 3 4

Execution progress

Objective (CORELS)

Lower bound (CORELS)

Lower bound (w/o  equivalent points bound)

10-3 10-2 10-1 100 101 102 103 104

Time (s)

0

50

100

150

lo
g
1
0
(S

iz
e
)

Size of remaining search space

w/o equivalent points bound

CORELS

Figure 6: CORELS with (lines) and without (dashes) the equivalent points bound (Theo-
rem 22). Top: Objective value (thin line) and lower bound (thick line) for CORELS, as a
function of wall clock time (log scale). Numbered hatch marks along the trace of the ob-
jective value indicate when the length of the best known rule list changes, and are labeled
by the new length. CORELS quickly achieves the optimal value (star marker), and certi-
fies optimality when the lower bound matches the objective value. A separate execution
of CORELS without the equivalent points bound remains far from complete, and its lower
bound (dashed line) far from the optimum. Bottom: blog10 Γ(Rc, Q)c, as a function of wall
clock time (log scale), where Γ(Rc, Q) is the upper bound on remaining search space size
(Theorem 7).

In the remainder, we show results using the ProPublica dataset. The solid lines in
Figure 6 illustrate how both the objective (top) and the size of the remaining search space
(bottom) decrease as CORELS executes. The objective drops quickly, achieving the optimal
value within 10 seconds. CORELS certifies optimality in less than 6 minutes – the objective
lower bound of the remaining search space steadily converges to the optimal objective as
the search space shrinks.

Finally, we determine the efficacy of each of our bounds and data structure optimiza-
tions. Both panels of Figure 6 also highlight a separate execution of CORELS without the
equivalent points bound. After nearly 3 hours, the execution is still far from complete; in
particular, the lower bound is far from the optimum objective value. Table 1 provides sum-
mary statistics for experiments using the full CORELS implementation and five variants
that each remove a specific optimization. Figure 7 presents a view of the same experi-
ments. These plots depict the number of prefixes of a given length in the queue during the
algorithm’s execution.

39



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

Removed component ttotal (min) topt (s) itotal (×106) Qmax (×106) Kmax
none (CORELS) 5.5 (1.6) 8 (2) 1.7 (0.4) 1.3 (0.4) 5-6
priority queue (BFS) 6.7 (2.2) 4 (1) 1.9 (0.6) 1.5 (0.5) 5-6
support bounds 10.2 (3.4) 13 (4) 2.7 (0.8) 2.2 (0.7) 5-6
symmetry-aware map 58.6 (23.3) 23 (6) 16.0 (5.9) 14.5 (5.7) 5-6
lookahead bound 71.9 (23.0) 9 (2) 18.5 (5.9) 16.3 (5.3) 6-7
equivalent pts bound >134 >7168* >800 >789 ≥10

Table 1: Per-component performance improvement. The columns report total execution
time, time to optimum, number of queue insertions, maximum queue size, and maximum
evaluated prefix length. The first row shows CORELS; subsequent rows show variants that
each remove a specific implementation optimization or bound. (We are not measuring the
cumulative effects of removing a sequence of components.) All rows represent complete
executions, except for the final row, in which each execution was terminated due to memory
constraints, once the size of the cache reached 8× 108 elements, after consuming 390-410GB
RAM. In all but the final row and column, we report means (and standard deviations) over
10 cross-validation folds; in the final row, we report the minimum values across folds.
* Only 4 out of 10 folds achieve the optimum before being terminated.

10-4 10-3 10-2 10-1 100 101 102 103 104
100

101

102

103

104

105

106

107

108

C
o
u
n
t

1 2 3 4 

T ≡ 149 s

CORELS

10-4 10-3 10-2 10-1 100 101 102 103 104
100

101

102

103

104

105

106

107

108

1 2 3 4 

 176 s ≈ 1.2 T

No priority queue

10-4 10-3 10-2 10-1 100 101 102 103 104
100

101

102

103

104

105

106

107

108

1 2 3 4 

 270 s ≈ 1.8 T

No support bounds

10-4 10-3 10-2 10-1 100 101 102 103 104

Time (s)

100

101

102

103

104

105

106

107

108

C
o
u
n
t

1 2 3 4 

1340 s ≈ 9.0 T

No symmetry-aware map

10-4 10-3 10-2 10-1 100 101 102 103 104

Time (s)

100

101

102

103

104

105

106

107

108

1 2 3 4 5 

 1759 s ≈ 12 T

No lookahead bound

10-4 10-3 10-2 10-1 100 101 102 103 104

Time (s)

100

101

102

103

104

105

106

107

108

1 2 3 4 5 6 7 8 9 

> 9532 s ≈ 64 T

No equivalent points bound

Figure 7: Logical queue composition. Numbers of prefixes in the queue (log scale), labeled
and colored by length, as a function of wall clock time (log scale), for full CORELS (top
left), and five variants that each remove a specific implementation optimization or bound.
The gray shading fills in the area beneath the total number of queue elements for CORELS,
i.e., the sum over all lengths in the top left figure. For comparison, we replicate the same
gray region in the other three subfigures. For each execution, we indicate the total time
both in seconds, and relative to the full CORELS implementation (T = 149 s).

40



Learning Certifiably Optimal Rule Lists for Categorical Data

7. Conclusion

CORELS is an efficient and accurate algorithm for constructing provably optimal rule lists.
Optimality is particularly important in domains where model interpretability has social
consequences, e.g., recidivism prediction. While achieving optimality on such discrete op-
timization problems is computationally hard in general, we aggressively prune our prob-
lem’s search space via a suite of bounds. This makes realistically sized problems tractable.
CORELS is amenable to parallelization, which should allow it to scale to even larger prob-
lems.

Acknowledgments

E.A. is supported by the Miller Institute for Basic Research in Science, University of Cal-
ifornia, Berkeley, and is hosted by Prof. M.I. Jordan at RISELab. C.D.R. is supported in
part by MIT-Lincoln Labs. E.A. would like to thank E. Jonas, E. Kohler, and S. Tu for
early implementation guidance, A. D’Amour for pointing out the work by Goel et al. (2016),
J. Schleier-Smith and E. Thewalt for helpful conversations, and members of RISELab, SAIL,
and the UC Berkeley Database Group for their support and feedback. We thank H. Yang
and B. Letham for sharing advice and code for processing data and mining rules.

References

K. P. Bennett and J. A. Blue. Optimal decision trees. Technical report, R.P.I. Math Report
No. 214, Rensselaer Polytechnic Institute, 1996.

I. Bratko. Machine learning: Between accuracy and interpretability. In Learning, Networks
and Statistics, volume 382 of International Centre for Mechanical Sciences, pages 163–
177. Springer Vienna, 1997. ISBN 978-3-211-82910-3.

L. Breiman, J. H. Friedman, R. A. Olshen, and C. J. Stone. Classification and Regression
Trees. Wadsworth, 1984.

C. Chen and C. Rudin. Optimized falling rule lists and softly falling rule lists. Work in
progress, 2017.

H. A. Chipman, E. I. George, and R. E. McCulloch. Bayesian CART model search. Journal
of the American Statistical Association, 93(443):935–948, 1998.

H. A. Chipman, E. I. George, and R. E. McCulloch. Bayesian treed models. Machine
Learning, 48(1/3):299–320, 2002.

H. A. Chipman, E. I. George, and R. E. McCulloch. BART: Bayesian additive regression
trees. The Annals of Applied Statistics, 4(1):266–298, 2010.

W. W. Cohen. Fast effective rule induction. In Twelfth International Conference on Machine
Learning (ICML), pages 115–123, 1995.

41



Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

R. M. Dawes. The robust beauty of improper linear models in decision making. American
Psychologist, 34(7):571–582, 1979.

D. Dension, B. Mallick, and A.F.M. Smith. A Bayesian CART algorithm. Biometrika, 85
(2):363–377, 1998.

D. Dobkin, T. Fulton, D. Gunopulos, S. Kasif, and S. Salzberg. Induction of shallow decision
trees, 1996.

A. Farhangfar, R. Greiner, and M. Zinkevich. A fast way to produce optimal fixed-depth
decision trees. In International Symposium on Artificial Intelligence and Mathematics
(ISAIM 2008), 2008.

A. A. Freitas. Comprehensible classification models: a position paper. ACM SIGKDD
Explorations Newsletter, 15(1):1–10, 2014.

M. Garofalakis, D. Hyun, R. Rastogi, and K. Shim. Efficient algorithms for constructing
decision trees with constraints. In Proceedings of the Sixth ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining (KDD’98), pages 335–339, 2000.

C. Giraud-Carrier. Beyond predictive accuracy: What? In Proceedings of the ECML-98
Workshop on Upgrading Learning to Meta-Level: Model Selection and Data Transforma-
tion, pages 78–85, 1998.

S. Goel, J. M. Rao, and R. Shroff. Precinct or prejudice? Understanding racial disparities
in New York City’s stop-and-frisk policy. Ann. Appl. Stat., 10(1):365–394, 03 2016.

M. Goessling and S. Kang. Directional decision lists. Preprint at arXiv:1508.07643, Aug
2015.

B. Goodman and S. Flaxman. EU regulations on algorithmic decision-making and a “right
to explanation”. Preprint at arXiv:1606.08813, 2016.

R. C. Holte. Very simple classification rules perform well on most commonly used datasets.
Machine Learning, 11(1):63–91, 1993.

J. Huysmans, K. Dejaeger, C. Mues, J. Vanthienen, and B. Baesens. An empirical evaluation
of the comprehensibility of decision table, tree and rule based predictive models. Decision
Support Systems, 51(1):141–154, 2011.

H. Lakkaraju and C. Rudin. Cost-sensitive and interpretable dynamic treatment regimes
based on rule lists. In Proceedings of the Artificial Intelligence and Statistics (AISTATS),
2017.

J. Larson, S. Mattu, L. Kirchner, and J. Angwin. How we analyzed the COMPAS recidivism
algorithm. ProPublica, 2016.

N. L. Larus-Stone. Learning Certifiably Optimal Rule Lists: A Case For Discrete Optimiza-
tion in the 21st Century. 2017. Undergraduate thesis, Harvard College.

42



Learning Certifiably Optimal Rule Lists for Categorical Data

B. Letham, C. Rudin, T. H. McCormick, and D. Madigan. Interpretable classifiers using
rules and Bayesian analysis: Building a better stroke prediction model. Annals of Applied
Statistics, 9(3):1350–1371, 2015.

W. Li, J. Han, and J. Pei. CMAR: Accurate and efficient classification based on multiple
class-association rules. IEEE International Conference on Data Mining, pages 369–376,
2001.

B. Liu, W. Hsu, and Y. Ma. Integrating classification and association rule mining. In Pro-
ceedings of the 4th International Conference on Knowledge Discovery and Data Mining,
KDD ’98, pages 80–96, 1998.

M. Marchand and M. Sokolova. Learning with decision lists of data-dependent features.
Journal of Machine Learning Research, 6:427–451, 2005.

T. H. McCormick, C. Rudin, and D. Madigan. Bayesian hierarchical rule modeling for
predicting medical conditions. The Annals of Applied Statistics, 6:652–668, 2012.

S. Muggleton and L. De Raedt. Inductive logic programming: Theory and methods. The
Journal of Logic Programming, 19:629–679, 1994.

New York Civil Liberties Union. Stop-and-frisk data, 2014. http://www.nyclu.org/
content/stop-and-frisk-data.

S. Nijssen and E. Fromont. Optimal constraint-based decision tree induction from itemset
lattices. Data Mining and Knowledge Discovery, 21(1):9–51, 2010. ISSN 1384-5810.

J. R. Quinlan. C4.5: Programs for Machine Learning. Morgan Kaufmann, 1993.

R. L. Rivest. Learning decision lists. Machine Learning, 2(3):229–246, November 1987.

C. Rudin and S. Ertekin. Learning optimized lists of rules with mathematical programming.
Unpublished, 2015.

C. Rudin, B. Letham, and D. Madigan. Learning theory analysis for association rules and
sequential event prediction. Journal of Machine Learning Research, 14:3384–3436, 2013.

S. Rüping. Learning interpretable models. PhD thesis, Universität Dortmund, 2006.

G. Shmueli. To explain or to predict? Statistical Science, 25(3):289–310, August 2010. ISSN
0883-4237.

M. Sokolova, M. Marchand, N. Japkowicz, and J. Shawe-Taylor. The decision list machine.
In Advances in Neural Information Processing Systems, volume 15 of NIPS ’03, pages
921–928, 2003.

K. Vanhoof and B. Depaire. Structure of association rule classifiers: A review. In Proceedings
of the International Conference on Intelligent Systems and Knowledge Engineering, ISKE
’10, pages 9–12, 2010.

43

http://www.nyclu.org/content/stop-and-frisk-data
http://www.nyclu.org/content/stop-and-frisk-data


Angelino, Larus-Stone, Alabi, Seltzer, and Rudin

A. Vellido, J. D. Mart́ın-Guerrero, and P. J.G. Lisboa. Making machine learning models
interpretable. In Proceedings of the European Symposium on Artificial Neural Networks,
Computational Intelligence and Machine Learning, 2012.

F. Wang and C. Rudin. Falling rule lists. In Proceedings of Artificial Intelligence and
Statistics (AISTATS), 2015.

H. Yang, C. Rudin, and M. Seltzer. Scalable Bayesian rule lists. Preprint at
arXiv:1602.08610, 2016.

X. Yin and J. Han. CPAR: Classification based on predictive association rules. In Pro-
ceedings of the 2003 SIAM International Conference on Data Mining, ICDM ’03, pages
331–335, 2003.

Y. Zhang, E. B. Laber, A. Tsiatis, and M. Davidian. Using decision lists to construct
interpretable and parsimonious treatment regimes. Preprint at arXiv:1504.07715, April
2015.

44


	1 Introduction
	2 Related Work
	3 Learning optimal rule lists
	3.1 Rule lists for binary classification
	3.2 Objective function
	3.3 Optimization framework
	3.4 Hierarchical objective lower bound
	3.5 Upper bounds on prefix length
	3.6 Upper bounds on the number of prefix evaluations
	3.7 Lower bounds on antecedent support
	3.8 Upper bound on antecedent support
	3.9 Antecedent rejection and its propagation
	3.10 Equivalent support bound
	3.11 Permutation bound
	3.12 Upper bound on prefix evaluations with symmetry-aware pruning
	3.13 Similar support bound
	3.14 Equivalent points bound

	4 Incremental computation
	5 Implementation
	6 Experiments
	7 Conclusion

