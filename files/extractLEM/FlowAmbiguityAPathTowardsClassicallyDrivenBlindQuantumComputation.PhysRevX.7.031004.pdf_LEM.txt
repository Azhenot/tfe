




































untitled 


Flow Ambiguity: A Path Towards Classically Driven Blind Quantum Computation 

Atul Mantri,1,2 Tommaso F. Demarie,1,2,† Nicolas C. Menicucci,3,4,* and Joseph F. Fitzsimons1,2,‡ 
1Singapore University of Technology and Design, 8 Somapah Road, Singapore 487372 

2Centre for Quantum Technologies, National University of Singapore, 
Block S15, 3 Science Drive 2, Singapore 117543 

3Centre for Quantum Computation and Communication Technology, School of Science, 
RMIT University, Melbourne, Victoria 3001, Australia 

4School of Physics, The University of Sydney, Sydney, New South Wales 2006, Australia 
(Received 1 September 2016; revise manuscript receive 4 April 2017; publish 11 July 2017) 

Blind quantum computation protocol allow a user to delegate a computation to a remote quantum computer 
in such a way that the privacy of their computation be preserved, even from the device implement the 
computation. To date, such protocol be only know for setting involve at least two quantum devices: either 
a user with some quantum capability and a remote quantum server or two or more entangle but 
noncommunicating servers. In this work, we take the first step towards the construction of a blind quantum 
compute protocol with a completely classical client and single quantum server. Specifically, we show how a 
classical client can exploit the ambiguity in the flow of information inmeasurement-based quantum compute 
to construct a protocol for hiding critical aspect of a computation delegate to a remote quantum computer. 
This ambiguity arises due to the fact that, for a fix graph, there exist multiple choice of the input and output 
vertex set that result in deterministic measurement pattern consistent with the same fix total order of 
vertices. This allows a classical user, compute only measurement angles, to drive a measurement-based 
computation perform on a remote device while hiding critical aspect of the computation. 

DOI: 10.1103/PhysRevX.7.031004 Subject Areas: Quantum Information 

I. INTRODUCTION 

Large-scale quantum computer offer the promise of 
quite extreme computational advantage over conventional 
compute technology for a range of problem span 
cryptanalysis [1], simulation of physical system [2], and 
machine learn [3]. Recently, however, a new application 
have emerge for quantum computers: secure delegate 
computation [4]. 
Consider a user wish to have a computation perform 

on a remote server. Two main security concern arise for 
the user relate to the privacy and the correctness of the 
computation. The privacy concern be that the description of 
their computation, both the program and any input data, 
remains hidden even from the server. The correctness 
concern be that a malicious server might tamper with their 
computation, send them a mislead result; hence, 
ideally such behavior would be detectable. Quantum proto- 
col have be propose that can mitigate both of these 
concerns. In the literature, protocol that allow for program 
and data privacy be know a blind quantum compute 
protocols, while protocol that allow for correctness to be 

ensure with high probability be know a verifiable 
quantum compute protocol [5]. 
The first blind quantum compute protocol be propose 

by Childs [6]. While functional, this scheme put a rather 
heavy burden on the client’s side in term of resources, with 
the client require to control a quantum memory and to 
perform SWAP gates. A subsequent protocol, from Arrighi 
and Salvail [7], introduce mechanism for both verification 
and blindness for a limited range of function and can be 
see a the start of an intimate link between blindness 
and verifiability. This link be further establish with the 
discovery of the universal blind quantum compute 
(UBQC) protocol [8], which allows a client, equip only 
with the ability to produce single-qubit states, to delegate an 
arbitrary quantumcomputation to a universal quantum server 
while make it blind with unconditional security. 
This schemehasbeenmodified andextended several time 

in the last few years, with work investigate robustness 
[9–11], optimality [12–14], and issue related to physical 
implementation [15,16]. Importantly, the blind computation 
protocol have proven a powerful tool in the construction of 
verifiable quantum compute protocols, with a number of 
protocol emerge in recent year base on the UBQC 
protocol [17–19] and on an alternative blind protocol from 
Morimae and Fujii [20] in which the client performs single- 
qubit measurement rather than state preparation [21–23]. 
The relatively low overhead in such scheme have make it 
possible to implement both blind and verifiable quantum 
compute protocol in quantum optic [24–26]. 

*ncmenicucci@gmail.com 
†tommaso_demarie@sutd.edu.sg 
‡joseph_fitzsimons@sutd.edu.sg 

Published by the American Physical Society under the term of 
the Creative Commons Attribution 3.0 License. Further distri- 
bution of this work must maintain attribution to the author(s) and 
the publish article’s title, journal citation, and DOI. 

PHYSICAL REVIEW X 7, 031004 (2017) 

2160-3308=17=7(3)=031004(15) 031004-1 Published by the American Physical Society 

https://doi.org/10.1103/PhysRevX.7.031004 
https://doi.org/10.1103/PhysRevX.7.031004 
https://doi.org/10.1103/PhysRevX.7.031004 
https://doi.org/10.1103/PhysRevX.7.031004 
http://creativecommons.org/licenses/by/3.0/ 
http://creativecommons.org/licenses/by/3.0/ 


The question of verifiability, directly rather than a a 
consequence of blindness, have also attract attention. This 
problem be first study by Aharonov et al. [27], who 
consider the use of a constant-sized quantum computer to 
verify a large device. Subsequent work by Broadbent [28] 
reduce the requirement on the prover to mirror those 
use in the UBQC protocol. An entirely distinct route to 
verification have also emerged, which considers a classical 
user but require multiple entangle but noncommuni- 
cat server [29,30]. Surprisingly, perhaps, many of these 
scheme be also blind, though often this be not the aim 
of the paper. In fact, only a few example of verifiable com- 
put scheme exist that be not naturally blind [31,32], 
and it be tempt to conjecture a fundamental link between 
blindness and verifiability. 
The verification method discuss above provide a very 

strong form of certification, amount to interactive proof 
for correctness, which do not rely on any assumption 
about the function of the device to be tested. From an 
experimental point of view, the first nonclassically simu- 
lable evolution of quantum system will most likely be 
implement by mean of nonuniversal quantum simula- 
tor rather than fully universal quantum computers. Here, 
too, the problem arises of certify the correct function 
of a device [33] that cannot be efficiently simulated. 
However, in this regime, interactive proof have proven 
more difficult to construct. Nonetheless, progress have be 
make in develop a range of certification technique for 
various physical systems. These include feasible quantum 
state tomography of matrix product state [34], certification 
of the experimental preparation of resource for photonic 
quantum technology [35], certification of simulator of 
frustration-free Hamiltonians [36], and derivation of a 
statistical benchmark for boson sample experiment [37]. 
A common feature among all blind quantum compute 

protocol and interactive proof of correctness for quantum 
computation be that they require that at least two party 
posse quantum capabilities. Removing this requirement 
and allow a purely classical user to interact with a single 
quantum server would greatly expand the practicality of 
delegate quantumcomputation since itwould remove large- 
scale quantum network a a prerequisite for verifiability. In 
the present work, we focus specifically on the question of 
blind computation with a completely classical client, but 
give the historic link between progress in blindness and 
verification, it be natural to expect that progress in either 
direction will likely be reflect in the other. 
While it be presently unknown if such a protocol 

can exist, a negative result in this context be a scheme- 
dependent impossibility proof present in Ref. [38]. 
There, the author consider a scenario where a classical 
user and a quantum server exchange classical information 
in a two-step process. First, the classical client encodes her 
description of the computation use an affine encryption 
scheme and then sends all the classical encrypt data to the 

server. The server then performs a quantum computation 
use the receive data and return the classical output to 
the client, who decrypts the result use her encryption key. 
For this setting, it be show that secure blind quantum 
compute cannot be achieve unless BPP ¼ BQP (i.e., 
unless a classical computer can efficiently simulate a 
quantum computer). While this be an interest result, it 
imposes strong assumption on the operational method of 
blind quantum computation with a classical client and 
therefore do not seem to limit further study in this 
direction. Additionally, Aaronson et al. [39] have recently 
suggest that information-theoretically blind quantum 
compute with a classical client be not likely to be possible 
because the existence of such a scheme implies unlikely 
containment between complexity classes. Additional 
implication that the development of a classical-client 
blind-computation protocol would have in complexity 
theory be discuss in Ref. [40]. 
Here, we provide evidence in the opposite direction. We 

introduce a form of delegate quantum computation use 
measurement-based quantum compute (MBQC) a the 
underlie framework. This allows u to introduce a 
model-specific protocol that achieves a satisfy degree 
of security by directly exploit the structure of MBQC. 
We show that the classical communication receive by the 
party perform quantum operation be insufficient to 
reconstruct a description of the computation. This insuffi- 
ciency remains even when the server be require only to 
identify the computation up to pre- and post-processing by 
polynomial-sized classical computation, under plausible 
complexity-theoretic assumptions. We call our scheme 
classically driven blind quantum compute (CDBQC). 
The paper be structure a follows: In Sec. II, we present 

a short introduction to MBQC. In Sec. III, we describe the 
step of the CDBQC protocol. In Sec. IV, we use mutual 
information to analyze the degree of blindness for a single 
round of the CDBQC protocol. In Sec. V, we introduce the 
concept of flow ambiguity, and we show how this be use by 
the client to hide information from the quantum server. Our 
conclusion be present in Sec. VI. 

II. MEASUREMENT-BASED 
QUANTUM COMPUTATION 

In MBQC, a computation be perform by mean of 
single-qubit projective measurement that drive the quan- 
tum information across a highly entangle resource state. 
The most general resource for MBQC be graph state 
[41]. A graph state be define by a simple and undirected 
graph, i.e., a mathematical object G ¼ ðV; EÞ compose of 
a vertex set V and an edge set E, with cardinality jVj and 
jEj, respectively. The vertex of the graph represent the 
qubits, while their interaction be symbolize by the edges. 
A graph state jGi be an N-qubit state, where N ¼ jVj. Each 
qubit be initialize in the state jþi ¼ 1ffiffi 

2 
p ðj0i þ j1iÞ and 

then entangle with it neighbor by controlled-Z gates, 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-2 



ĈZi;j ¼ j0ih0ji ⊗ Îj þ j1ih1ji ⊗ Ẑj, where Î and Ẑ be 
the single-qubit identity and Pauli-Z gate, respectively. 
Explicitly, jGi ¼ Qði;jÞ∈EĈZi;jjþi⊗N . Equivalently, a graph 
state jGi can be define by the stabilizer relation 
K̂vjGi ¼ jGi, with stabilizer [41] 

K̂v ¼ X̂v 
Y 

w∈N ðvÞ 
Ẑw; ∀ v ∈ V; ð1Þ 

where N ðvÞ denotes the neighborhood of v in G. Without 
loss of generality, the vertex in G can be label ð1;…; NÞ 
in the order that the correspond qubits be to be 
measured. We take this order to be implicit in the 
definition of the graph, for example, a the order in which 
the vertex appear in the adjacency matrix for G. It be also 
useful to define a specific type of graph state that will be 
use later. An N-qubit cluster state jCSin;m be the graph 
state correspond to an n ×m regular square-lattice graph 
Gn;m. For such a graph, N ¼ nm. 
In the MBQC framework, give a resource state with 

graph G, the standard procedure to perform a computation 
be to first identify two set of qubits fI; Og on G. This 
procedure defines an open graph GðI; OÞ, such that I,O⊆V 
for a give G. The set I corresponds to the input set, while 
O denotes the output set. In general, 0 < jIj ≤ jOj ≤ jVj. 
Note that the input and output set can overlap. The 
complement of I be write Ic, and similarly, the comple- 
ment of O be Oc. We also denote by PðIcÞ the power set of 
all the subset of element in Ic, and we define 

OddðKÞ ≔ fi∶jN ðiÞ ∩ Kj ¼ 1 mod 2g ð2Þ 
a the odd neighborhood of a set of vertex K ⊆ V. In 
this work, we be only interested in MBQC protocol 
that implement unitary embeddings. Hence, for us, 
jIj ¼ jOj ≤ N. Intuitively, the state of the qubits in the 
input set corresponds to the input state of a computation. 
Similarly, the qubits in the output set will contain the 
quantum information correspond to the result of the 
computation once all the qubits in Oc have be measured. 
In the process, the quantum information be transform by 
the same principle that governs the generalize one-bit 
teleportation scheme [42,43]. 
For our purposes, we restrict the measurement to be 

projectivemeasurements in theXY-plane of theBloch sphere, 
denote M 

αj 
j ¼fj�αih�αjjg for qubit j, where j�αi ¼ 

1ffiffi 
2 

p ðj0i � eiαj1iÞ. As a convention, we use bj ¼ 0 for the 
measure qubit collapse to jþαij and bj ¼ 1 for collapse 
to j−αij. The computation tobeperformed be specifiedbothby 
the choice of open graphGðI; OÞ and by a vectorα specify 
the measurement basis αi for each qubit i. Note that these be 
the measurement that would be make directly on the cluster 
state if all themeasurement outcomeswere zero for nonoutput 
qubits—i.e., if one be to implement the positive branch of 
the MBQC computation. Importantly, by convention, the 

positive branch corresponds to the target computation. In 
general, however, these base need to be update base on 
outcome of early measurement in order to ensure the 
correct computation be performed. The description of the 
resource state, theorder ofmeasurements, and thedependency 
of themeasurementbases onpreviousmeasurement outcome 
be collectively know a a measurement pattern. 
Projective measurement be inherently random in quan- 

tum mechanics, and one need a procedure to correct for 
this randomness. We show that this need for adaptation of 
future measurement base on previous outcome be what 
prevents Bob from know the protocol perfectly. Not 
incidentally, it be also what circumvents the no-go result 
from Ref. [38]. This be because only Alice know how she 
be choose to adapt future measurement base dependent 
on previous measurement outcomes: Our observation be 
that different choice of adaptation strategy correspond to 
different computation in general. 
The structure that determines how to recover determin- 

istic evolution from a MBQCmeasurement pattern be call 
g-flow [44], from “generalized quantum-information flow.” 
Rigorously, give some resource state jGi and a measure- 
ment pattern on it, if the associate open graph GðI; OÞ 
satisfies certain g-flow condition (to be described later), 
then the pattern be runnable, and it be also uniformly, 
strongly, and stepwise deterministic. This mean that each 
branch of the pattern can be make equal to the positive 
branch after each measurement by application of local 
corrections, independently of the measurement angles. We 
use “deterministic” without ambiguity to indicate all these 
attributes. Note also that satisfy the g-flow condition be 
a necessary and sufficient condition for determinism. 
In practice, the g-flow assigns a set of local Pauli 

correction to a subset of unmeasured qubits after a 
measurement. See Ref. [45] for the fine detail regard 
the practicality of g-flow. For simplicity, in the definition 
of g-flow below adapt from Ref. [44], we assume all 
qubits be measure in the XY-plane of the Bloch sphere. 
The idea behind g-flow be to determine whether one can 
find a correction operator (related to a correct set on the 
graph) that, in the case of a nonzero measurement outcome, 
can revert the quantum state onto the projection corre- 
sponding to the zero outcome. This be do by apply 
stabilizer operator on the state. The g-flow condition 
determine whether the geometrical structure of an open 
graph allows for these correction after each measurement. 

Definition 1. [g-flow] For an open graph GðI; OÞ, there 
exists a g-flow ðg;≻Þ if one can define a function g∶Oc → 
PðIcÞ and a partial order ≻ on V such that ∀i ∈ Oc all of 
the follow condition hold: 

(G1) if j ∈ gðiÞ and j ≠ i, then j ≻ i; 
(G2) if j ⊁ i and i ≠ j, then j ∉ Odd(gðiÞ); and 
(G3) i ∉ gðiÞ and i ∈ Odd(gðiÞ). 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-3 



The successor function gðiÞ indicates what measurement 
will be affected by the outcome of the measurement of qubit 
i, while the partial order≻ should be thought of a the causal 
order of measurements. The condition (G1) say that if a 
vertex j be in the correct set of the vertex i, then j should 
be measure after the vertex i. In other words, a correction 
should happen after the assign measurement. Condition 
(G2) make sure that if the correct set of a vertex i be 
connect to a vertex j, and j ismeasured before the vertex i, 
then the vertex j should have an even number of con- 
nections with the correct set of vertex i. Then, vertex j 
receives an even number of equal Pauli corrections, which 
be equivalent to receive none; hence, no correction can 
affect early corrections. Finally, condition (G3) ensures 
that each vertex i have an odd number of connection with it 
correct set, such that a correction be indeed perform on 
i [45]. In this sense, the g-flow condition be understood in 
term of geometrical condition on the open graph. 
Guided by these conditions, for cluster states, here and in 

the following, we always adopt the same choice of vertex 
label on the graph a show in Fig. 1. This choice be 
motivate by our late goal of counting how many choice 
of open graph satisfy the g-flow condition on a give 
cluster state. Since a vertex label corresponds to a total 
order of measurement, it be easy to check that, in order to 
satisfy the g-flow conditions, for any vertex i, the quantum 
information can only move towards the right, move towards 
the bottom, or stay on that vertex. Furthermore, condition 
(G3) imposes that the information from a vertex cannot 
move simultaneously towards the right and towards the 
bottom. In order to further simplify the process of counting 
flows, we introduce an additional criterion, which be not 
strictly require by g-flow: 

(G4) If k ∈ N ðiÞ ∪ N ðjÞ, and if k ∈ gðiÞ, then k ∉ gðjÞ. 
For Gn;m, a we shall see later, it will prove easy to 
count flow satisfy (G1)–(G4) than those satisfy 

(G1)–(G3). This process of course only provide a low 
bound on the number of flow rather than the exact number, 
but it will be sufficient for our purposes. 
With these four criterion in place, we can define a g-flow 

graph path, in this restrict version of g-flow, a an 
order set of adjacent edge of the graph, start from 
an element of the input set and end on an element of the 
output set, such that for each edge ij of the path, we have 
j ∈ gðiÞ, with j ≻ i. Then, it follow that (G4) do not 
allow the g-flow graph path to cross. To help the under- 
stand of MBQC, one could think of a g-flow graph path 
a a representation of a wire in the quantum circuit picture. 
This intuition will be use late in this work to count how 
many way one could define an open graph with g-flow for 
our choice of total ordering, which in turn provide a link to 
the idea that different open graph with g-flow lead to 
different quantum computations. 

III. CLASSICALLY DRIVEN BLIND 
QUANTUM COMPUTATION 

We start from the situation where Alice, the client, want 
to obtain the result of a particular quantum computation. 
Having no quantum device of her own, the quantum 
computation must have a classical output. We allow Alice 
to control a probabilistic polynomial-time universal Turing 
machine (i.e., a classical computer with access to random- 
ness). Alice have classical communication line to and from 
Bob, the server. Bob have access to a universal (and 
noiseless) quantum computer. Bob could help Alice, but 
she do not trust him. Alice wish to ask Bob to perform a 
quantum computation for her in a way that Bob obtains a 
little information a possible about her choice of compu- 
tation. Without loss of generality, we assume that the 
quantum system use in the protocol be qubits (two-level 
quantum system [46]). In general, here and in the 
following, we denote by 

ΔA ¼ fρI; ÛA;Mg ð3Þ 

the classical description of Alice’s computation, where ρI be 
the n-qubit input state of the computation, ÛA be the unitary 
embed that map ρI to the output state ρO ¼ ÛAρIÛ†A, 
and M be the final set of measurement on ρO require to 
extract the classical output. Note that we be imply that 
the input state can be efficiently described classically. For 
instance, it could be a standard choice of input such a the 
n-qubit computational basis ρI ¼ j0ih0j⊗n. We also (rather 
pedantically) assume that the number of computational 
step be at most polynomial in the input size. Making the 
process abstract, Alice’s desire task becomes equal to 
sample the string 

p ¼ fpig ¼ πðΔAÞ ≔ MðÛAρIÛ†AÞ; ð4Þ 
FIG. 1. Total order of the measurement for a generic n ×m 
cluster state use a a resource state in Protocol 1. 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-4 



where π be a map that describes the blind operation 
perform by the protocol, which output the correct 
probability distribution fpig on the joint measurement 
outcome give ΔA a Alice’s delegate target computa- 
tion. An outline of the protocol be present in Protocol 1. 
Let u now introduce the relevant definition for the 

variable use in the protocol and describe the step 
thoroughly. The initial step of the protocol be for Bob to 
prepare the resource state jGi that will be use to implement 
the MBQC. Once the graph state jGi be prepared by Bob, the 
interactive part of the protocol start with Alice communicat- 
ing to Bob the angle to bemeasured, one by one. Because of 
the randomness introduce by the result of the projective 
measurements, there exists the possibility that these angle 
must be correct base on the outcome 

b ≔ ðb1;…; bNÞ ∈ ZN2 ð5Þ 

of Alice’s would-be measurements. Nonetheless, Alice can 
pick a canonical set of angle 

α ≔ ðα1;…;αNÞ ∈ AN ð6Þ 

correspond to the positive branch case where b ¼ 0. As 
discuss earlier, it be possible that the angle for qubit jmust 
be modify base on the outcome of the precede j − 1 
measurements, which we denote 

b<j ≔ ðb1;…; bj−1Þ: ð7Þ 

We account for this adaptation in dependency set 

sx ≔ ðsx1;…; sxNÞ ∈ ZN2 ; ð8Þ 

sz ≔ ðsz1;…; szNÞ ∈ ZN2 ; ð9Þ 

which depend on theb<j and also on theg-flow construction, 
here represent by a bit string 

f ≔ ðf1;…; fMÞ ∈ ZM2 ð10Þ 

of lengthM call the flow control bit (or just “flow bits”). 
At this point, we still have to quantify the value ofM. Note, 
though, that it represent the number of bit need to 
enumerate all the possible combination of input and output 
that satisfy the g-flow condition [44,47]. Hence, for a fix 
total order of the measurements, it be a function of N. 
Explicitly, the X and Z correction associate with the 
measurement angle of each qubit j be determine by the 
dependency sets: 

sxj∶ D½b<j� ×D½f� → Z2; ð11Þ 

szj∶ D½b<j� ×D½f� → Z2; ð12Þ 

where the function D denotes the domain of the argument. 
Without loss of generality,we choose sz1 ¼ sx1 ¼ 0 since there 
be no previous outcome onwhich these could depend. For a 
fix open graph GðI; OÞ, the form of the dependency set be 
uniquely define by the g-flow [4]. Analogously, the flow bit 
f fully specify the dependency set (as function of b). As 
such, the quantum circuit that Alice intend to implement be 
specify by the information 

ðα; fÞ ∈ AN × ZM2 ; ð13Þ 

consist of N measurement angle and M flow bit for 
a give graph with fix total order of measurement. 
Consequently, once the graph G be known, there exists a 
one-to-one correspondence GðI; OÞn;m ↔ f, and we can 
accordingly denote the correspond MBQC measure- 
ment pattern a follows: 

Protocol 1 CDBQC ðG;AÞ: Classically Driven Blind Quantum 
Computation. 

Protocol parameters: 
(i) A graph G with an implicit total order of vertices. 
(ii) A set of angle A satisfy Eq. (19). 

Alice’s input: 
(i) A target computation ΔA implement use MBQC a 

ΔMA ¼ fG;α; fg; 

represent a measurement pattern on G compatible with 
the total order of measurement implicit in G, which 
describes a unitary embed ÛA. The set α represent a 
sequence of N measurement angle over the graph G, with 
each angle chosen from a set A, which be also take to be a 
parameter of the protocol and be know to both parties. The 
g-flow construction f fully determines the input state ρin, 
through the location of the input and output qubit set on 
the graph (I and O, respectively) and the dependency set 
ðsx; szÞ. 

Steps of the protocol: 
1. State preparation 

(a) Bob prepares the graph state jGi. 
2. Measurements 

For i ¼ 1;…; N, repeat the following: 
(a) Alice pick a binary digit ri ∈ Z2 uniformly at random. 

Then, use ri, sx, sz, and the function in Eq. (18), she 
computes the angle α0i. Alice transmits α 

0 
i to Bob. 

(b) Bob measure the ith qubit in the basis fj�α0iig and 
transmits to Alice the measurement outcome b0i ∈ Z2. 

(c) Alice record bi ¼ b0i ⊕ ri in b and then update the 
dependency set ðsx; szÞ. If i ∈ O, then she also record 
bi in pCB . 

3. Post-processing of the output 
(a) Alice implement the final round of correction on the 

output string by calculate p ¼ pC ⊕ sZO, with sZO 
the set of Z correction on the output at the end of the 
protocol. 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-5 



ΔMA ¼ ðGn;m;α; fÞ: ð14Þ 

Explicitly, note that by choose f, Alice be define a 
unique choice of the input and output on the graph state 
before the protocol begins. In line with the computation 
description from Eq. (3), we call ρI the input state on G. 
We now turn our attention to what kind of information 

Bob receives when Alice asks him to perform the mea- 
surements on her behalf. The interactive part of the protocol 
consists of N steps. At each step i, Alice request Bob to 
measure, in the XY-plane of the Bloch sphere, the ith qubit, 
accord to the total order imply by G, and he sends back 
a bit for each measurement. We identify the measurement 
instruction Bob receives a a list of angle 

α0 ≔ ðα01;…; α0NÞ ∈ AN; ð15Þ 

and we label the string of bit Alice receives from Bob a 

b0 ≔ ðb01;…; b0NÞ ∈ ZN2 ; ð16Þ 

while remember that they be communicate alternately 
(α01 to Bob, b 

0 
1 to Alice, α 

0 
2 to Bob, b 

0 
2 to Alice, etc.). Note 

that in the case of a dishonest Bob, the string b0 do not 
need to correspond to real measurement outcome but 
could have be generate by Bob through some alternative 
process. 
Realizing thatmeasuring α can just a easily be effect by 

ask Bob to measure αþ π and then flip the return 
outcome bit, we introduce a uniformly random N-bit string 

r ≔ ðr1;…; rNÞ ∈ ZN2 ð17Þ 

that Alice will use to pad the angle in an attempt to conceal 
the measurement outcomes. All that remains be to specify 
how α0 depends on α. This be specify by the follow 
functional dependence [17,47,48]: 

α0 ¼ ð−1Þsxαþ ðsz þ rÞπ mod 2π; ð18Þ 

which follow from the g-flow construction and show how 
correction change subsequent measurement angles. Here, 
we have use multi-index notation to present the result 
concisely a a vector. Note that the dependency set ðsx; szÞ 
be update by Alice after each measurement. To make the 
analysis of the protocol meaningful, we construct a domain 
forα such that the domain of all validα0 be the same. Thus, in 
general, 

A ¼ fð−1Þxθ þ zπjθ ∈ A; x ∈ Z2; z ∈ Z2g: ð19Þ 

Also note that now 

b0 ¼ b ⊕ r; ð20Þ 

where ⊕ indicates addition modulo 2 for each bit. We 
can identify the data that Bob receives during the interactive 
part of the protocol (some from Alice, some from his own 
measurements) a 

ðdata Bob receivesÞ ≔ ðb0;α0Þ ∈ ZN2 ×AN: ð21Þ 

The interactive part of the protocol end when all the 
qubits have be measure and Alice hold the binary 
register b, derive from b0 to account for the one-time pad 
r. Since Alice know the output set O, whenever the ith 
qubit belongs to the set of output qubits, Alice save bi into 
a second binary sequence of length jOj: 

pCB ≔ ðp1;…; pjOjÞ ∈ ZjOj2 ; ð22Þ 

where pi ¼ bi, ∀i ∈ O. If Bob be honest, then pCB be 
equivalent to pC. At the end of the protocol, this string 
contains the classical result of the computation, up to 
classical post-processing. This be account for by calcu- 
lating p ¼ pC ⊕ sZO, where sZO be use to represent the final 
set of Z correction on the output qubits. Clearly, the 
classical nature of the client allows u to consider only 
quantum computation with classical output. 
In order for the protocol to have any utility, we require 

that the output p satisfies Eq. (4), a property know a 
correctness. The correctness of this protocol can be prove 
straightforwardly. Note that the positive branch of the 
MBQC pattern ΔMA [that is, where all the measurement 
outcome happen to be equal to zero (b ¼ 0)] implement 
Alice’s target computation ΔA by definition. In the circuit 
model, this corresponds to a quantum circuit that imple- 
ments the unitary ÛA over the correct input state ρI and a 
final round of measurement whose output be the binary 
string p [49]. Below, we give a proof of the correctness of 
the CDBQC protocol. 
Theorem 1. [correctness] For honest Alice and Bob, the 

outcome of Protocol 1 be correct. 
Proof.—There be only two difference between Protocol 

1 and a conventional MBQC implementation of ΔMA . 
The first be the use of r to hide measurement outcomes. 
The effect of r be to add an additional π to the measurement 
angle on certain qubits, result in a bit flip on the 
correspond measurement result b0i. However, since this 
be immediately undone, it have no effect on the statistic of 
the measurement result obtain after decode b. 
The other difference be that the g-flow construction, and 

hence the dependency sets, be only know to Alice and not to 
Bob. However, this do not affect the input state, which be 
equivalent to the usual case if Alice be honest (i.e., if she 
correctly performs her role in implement the protocol). 
Furthermore, if Alice update the measurement angle 
correctly use the dependency set a dictate by the 
g-flow, and Bob measure them accordingly, every branch 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-6 



of ΔMA be equivalent to the positive branch. Then, the 
measurement pattern correctly implement the unitary trans- 
formation ρout ¼ ÛAρinÛ†A. The protocol also allows Alice to 
identify the element of the output string pC in b since she 
know thepositionof theoutputon thegraph.Hence,whenboth 
Alice and Bob follow the protocol, the output stringp ¼ pC ⊕ 
sZO be the desire probability distribution that follow from the 
joint measurement of the correct quantum output. □ 

IV. BLINDNESS ANALYSIS 

We now look at the degree of blindness for a single round 
of Protocol 1. In this setting, we consider a cheat Bob 
with unbounded computational power, able to deviate from 
the protocol and follow any strategy allow by the law of 
physics. Our aim, however, be not to verify that Bob be 
indeed perform the correct quantum computation a 
requested. Instead, we want to quantify the amount of 
information that Bob can access when Protocol 1 be run 
only once (stand-alone) and compare it against the total 
amount of information need to describe the computation. 
To completely identify Alice’s computation, Bob need to 
know the description ΔMA . 
We identify variable with uppercase letter and particular 

instance of such variable with lowercase letters. The 
probability of a give instance x of a random variable X be 
denote PrðxÞ, and average over X be denote h·iX or h·i 
when there be no ambiguity. Given a random variable X, we 
callNX the number of possible outcome for the variable and 
nX ≔ log2NX the number of bit require to enumerate them. 
We denote the Shannon entropy [50] of a random 

variable X by HðXÞ ≔ h− log2 PrðxÞiX ≤ nX, with equal- 
ity if and only if X be uniformly random. For two ran- 
dom variable X and Y, their joint entropy be write 
HðX;YÞ ≔ h−log2 Prðx; yÞiX;Y , and the conditional en- 
tropy of X give Y be HðXjYÞ ≔ h−log2 PrðxjyÞiX;Y . 
These satisfy 

HðXjYÞ ¼ HðX;YÞ −HðYÞ: ð23Þ 

The mutual information of X and Y be 

IðX;YÞ ≔ HðXÞ þHðYÞ −HðX;YÞ 
¼ HðXÞ −HðXjYÞ 
¼ HðYÞ −HðYjXÞ; ð24Þ 

which will be our main tool of analysis. Intuitively, IðX;YÞ 
measure how much information Y have about X. More 
precisely, it quantifies how much the entropy of X be 
reduced, on average, when the value of Y be known. 
Because of the symmetry of the definition, these statement 
also hold when the role of X and Y be swapped. 
Let u call the angle variable A and the flow variable F. 

Specifying ΔMA , in general, therefore require nA þ nF bits. 

In addition, we use B for the eventual measurement 
outcome and R for the (uniformly random) string of 
π-shift bit that be know only to Alice. In any give run of 
the protocol, A and F be drawn from a joint prior 
probability Prðα; fÞ, which be know to Bob. Thus, 
HðA;FÞ ≤ nA þ nF bits, with equality if and only if the 
prior be uniform over F and A. Note that we do not make 
any assumption about this prior in what follows. 
We have see before that a single instance of the data 

Bob receives at the end of Protocol 1 be equal to ðG;b0;α0Þ. 
In a stand-alone setting, this be the only data available to 
Bob from which he might be able to gain some information 
about the circuit chosen by Alice. If this protocol be to be 
use a a subroutine or in parallel with another protocol, 
then one must analyze the security in a composable 
framework. Such an analysis be beyond the scope of the 
present work and be left a an open problem. Note that the 
graph be consider a parameter of the protocol and not part 
of Alice’s secret. Bob’s useful information at the end of a 
single run of Protocol 1 be then equal to the mutual infor- 
mation IðB0;A0;A;FÞ between the variable associate 
with the circuit ðA;FÞ and Bob’s data ðB0;A0Þ. 
In other words, we be model the leakage of 

information a an unintentional classical channel between 
Alice and Bob, where ðA;FÞ be the input of the channel 
and ðB0;A0Þ be the output at Bob’s side. Then, the mutual 
information tell u how many bit of the original mes- 
sage Bob receives on average, when average over many 
us of the channel. Importantly, one cannot recover, from 
mutual information, what bit of the original message be 
pass to Bob. For our protocol, the mutual information 
satisfies the follow bound, which do not rely on any 
computational assumption but be entirely derive from 
information theory. 
Theorem 2. [blindness] In a single instance of Protocol 

1, the mutual information between the client’s secret input 
fα; fg and the information receive by the server be 
bound by 

IðB0;A0;A;FÞ ≤ HðA0Þ: ð25Þ 

Proof.—From the definition of mutual information, we 
have 

IðB0;A0;A;FÞ ¼ HðB0;A0Þ −HðB0;A0jA;FÞ: 
Applying the inequality HðX;YÞ ≤ HðXÞ þHðYÞ, 
together with the fact that HðB0Þ ≤ nB0 ¼ N, to the above 
equation yield 

IðB0;A0;A;FÞ ≤ HðA0Þ þ N −HðB0;A0jA;FÞ: ð26Þ 
What remains to be show be that HðB0;A0jA;FÞ ≥ N. 
This result be prove a Lemma 4 in the Appendix by 
bound Prðb0;α0jα; fÞ ≤ 2−N base on the full joint 
probability for the protocol. With this bound in place, 
Eq. (25) directly follows. □ 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-7 



The conditional entropy HðA;FjB0;A0Þ quantifies the 
amount of information that, on average, remains unknown 
to Bob about Alice’s computation at the end of Protocol 1. 
As mention previously, in the case where Alice chooses 
the measurement angle A uniformly randomly from a 
finite set, one Aj for each qubit, and she chooses the flow F 
uniformly randomly from the set of all flow compatible 
with the total order implicit in G, then 

HðA;FÞ ¼ nA þ nF: ð27Þ 
In this case, by calculate the conditional entropy 

HðA;FjB0;A0Þ ¼ HðA;FÞ − IðB0;A0;A;FÞ; ð28Þ 
we have HðA;FjB0;A0Þ ≥ nF because of Theorem 2. Note 
that Theorem 2 guarantee zero mutual information for a 
single run of Protocol 1 only if nA ¼ 0, which mean only 
one choice of measurement angle for each qubit. However, 
the structure of the domain of α and α0 [see Eq. (19)] 
forbids such a choice. A minimal choice of angle that be 
not classically simulable (via the Gottesman-Knill theorem 
[51]) be give by 

A ¼ 
� 
π 

4 
; 
3π 

4 
; 
5π 

4 
; 
7π 

4 

� 
: ð29Þ 

In this case, for each angle αj, one have nαj ¼2, so nA¼2N. 
Since HðA0Þ ≤ nA0 ¼ nA, Bob gain at most two bit of 
information per qubit measured, with this information 
be a nontrivial function of both α and f. 

V. APPLICATION TO CLUSTER STATES 

To conclude the security analysis of the stand-alone 
scenario, it be necessary to calculate the exact value of NF, 
which in turn give u the value of nF and hence the low 
bound of the conditional entropy for the case of uniform 
variable A, F a explain above. Clearly, this depends on 
the choice of G. Here, we consider the case of cluster states, 
where G be take to be Gn;m with implicit total order of 
vertex a illustrate in Fig. 1. Note that M, the length of 
the bit string f, be equal to log2NF. When condition (G4) be 
included, the g-flows we consider correspond to focus 
g-flows [52]. Hence, there be a one-to-one correspondence 
between an instance of a g-flow f of F and a choice of input 
and output set on the graph [52]. Here, we place a low 
bound on M by counting flow that satisfy condition 
(G1)–(G4). The use of the additional constraint (G4), which 
be not implicit in the definition of g-flow, implies that we be 
undercounting the total number of flows; hence, 

NF ≥ #GðI; OÞn;m; ð30Þ 
where #GðI; OÞn;m corresponds to the number of possible 
way one can define an open graph that satisfies condition 
(G1)–(G4). We now show that this quantity can grow 

exponentially in the dimension of the cluster state such 
that nF ∝ N. 
Theorem 3. For a cluster state correspond to Gn;m 

with fix total order a depict in Fig. 1, the number 
of different open graph GðI; OÞ satisfy condition 
(G1)–(G4) be give by 

#GðI; OÞn;m ¼ Fjn−mj2minðn;mÞþ1 
Yminðn;mÞ 
μ¼2 

F22μ; ð31Þ 

where Fi be the ith Fibonacci number. 
Proof.—The proof of this theorem be somewhat involved. 

We begin by consider a set of diagonal cut acrossGn;m, a 
depict in Fig. 2(a). As we be consider only those flow 
that satisfy condition (G4), there be a straightforward con- 
straint on the information flow,which can be see by isolate 
a single cut and thevertices link byedges that the cut pass 
through [see Fig. 2(b)]. In the follow discussion, we 
consider only the vertex connect by edge through which 
a particular cut passes. Because of the total order impose 
on the vertex of Gn;m, condition (G1)–(G3) ensure that 
information can only pas through a cut from the left side to 
the right side and not in the reverse direction. Condition (G4) 
then allows exactly the set of flow where for any vertex k on 
the right side of the cut, information flow to k from at 

(a) 

(b) 

FIG. 2. (a) A cluster-state graph Gn;m with diagonal cut 
imposed. The flow across each cut be independent, and the 
number of possible flow across each cut be indicated. (b) Several 
cut with their neighbor vertex isolated. 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-8 



most one of it neighbor on the left side of the cut. So, 
if i, j ∈ N ðkÞ, then k ∉ gðiÞ ∩ gðjÞ. 
We divide the cut into three types: (i) those have one 

less neighbor vertex on the left side of the cut than on 
the right, (ii) those have one more neighbor vertex on 
the left side of the cut than on the right, and (iii) those 
have an equal number of neighbor vertex on both 
side of the cut. We label the total number of flow for each 
type a Aμ, Bμ, and Cμ, respectively, where μ indicates the 
number of neighbor vertex on the left side of the cut, a 
show in Fig. 2(b). 
In order to quantify these, we begin by note that 

Aμ ¼ A→μ þ A→μ , where A→μ denotes the number of flow 
with the restriction that information flow from the upper- 
most neighbor vertex on the left side of the cut to the 
uppermost neighbor vertex on the right side of the cut, 
and A→μ denotes the number of flow where this constraint 
be not satisfied. These quantity can be calculate use a 
simple recursion relation, a follows. 
Here, A→μ allows precisely one possibility for flow 

between the uppermost vertex of the cut, preclude 
flow from the uppermost vertex on the left side of the 
cut to low vertex on the right side. Hence, the remain 
μ − 1 vertex on the left side and μ − 1 on the right side will 
be isolated and identical to the situation where the cut 
partition one few vertex on each side. Thus,A→μ ¼ Aμ−1 ¼ 
A→μ−1 þ A→μ−1. 
Calculating A→μ be a little more involved, a there be two 

possibility to consider. The first be that no information 
flow from the uppermost vertex on the left side of the cut 
across the cut (in which case, it be an output). In this case, 
isolation of the low vertex occurs a in the analysis ofA→μ ; 
hence, there be A→μ−1 þ A→μ−1 possible flows. In the second 
case, no information can flow into the second uppermost 
vertex on the right side of the cut; hence, onlyA→μ−1 flow be 
possible. Thus, A→μ ¼ A→μ−1 þ 2A→μ−1 ¼ A→μ þ A→μ−1. These 
correspondence be depict in Fig. 3. 
Note that A→μ and A→μ satisfy the same recursion relation 

a the Fibonacci sequence when order a ðA→1 ; A→1 ; 
A→2 ; A 

→ 
2 ;…Þ and start with A→1 ¼ 1 ¼ F2 and A→1 ¼ 

2 ¼ F3. It follow that Aμ ¼ F2μþ2. By similar arguments, 
we have Bμ ¼ F2μ and Cμ ¼ F2μþ1. 
It remains only to be note that the configuration of the 

information flow across one cut be independent of the 
information flow across other cuts; hence, the total number 
of possible flow be give by the product of the possible 
flow across each cut. Therefore, 

#GðI; OÞn;m 

¼ 
� Yminðn;mÞ−1 

μ¼1 
F2μþ2 

� 
Fjn−mj 
2minðn;mÞþ1 

� Yminðn;mÞ 
ν¼2 

F2ν 

� 
; ð32Þ 

which simplifies to Eq. (31) a required. □ 

The Fibonacci number can bewritten exactly in term of 
the golden ratio ϕ ¼ 1 

2 
ð1þ ffiffiffi5p Þ a 

Fk ¼ 
ϕk − ð−ϕÞ−kffiffiffi 

5 
p : ð33Þ 

For large cluster state (n, m ≫ 1), the number of possible 
flow be give by 

#GðI; OÞn;m ≈ 5−jn−mj=2ϕð2λþ1Þjn−mj 
Yλ 
ν¼2 

ϕ4ν 

5 
ð34Þ 

¼ 5−ðnþm−2Þ=2ϕ2mnþmþn−4; ð35Þ 
where λ ¼ minðn;mÞ. The above approximation be 
obtain by note that Fk ≈ ϕk= 

ffiffiffi 
5 

p 
, since jð−ϕÞ−kj≪1 

for large k, and use this to approximate Eq. (31). 
Taking N ¼ nm and assume m grows polynomially in 

n, then m ¼ polyðnÞ, and 

#GðI; OÞn;m ¼ 22N log2 ϕþOðNϵÞ ð36Þ 

for some ϵ < 1. In such a case, use Eq. (30) and 
evaluate to lead order, 

nF ≥ log2#GðI; OÞn;m ≈ 1.388N: ð37Þ 

This result implies that the conditional entropy 
HðA;FjB0;A0Þ ≥ 1.388N. For the case of a computation 
chosen uniformly at random by Alice, the total number 
of bit require to entirely describe her computation be 
approximately equal to 3.388N. However, Bob only 
receives exactly 2N bit of information from Alice (the 
angle α0). From Theorem 2.1 in Ref. [53], it be easy to 
verify that Bob cannot decode Alice’s computation entirely 
with unit probability. Additionally, Theorem 2.4 in 
Ref. [54] show that Bob cannot guess Alice’s computation 
with probability great than 2−1.388N . 
To make sense of this result, one should remember 

that a particular deterministic MBQC computation be 

FIG. 3. A→μ and A→μ can be construct recursively, a show 
above. Here, arrow indicate information flow, while edge 
indicate the possibility of information flow. 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-9 



characterize by identify an input and output set on the 
underlie graph of the resource state, together with an 
information flow construction. This structure determines 
how the quantum information be deterministically trans- 
ferred via projective measurement from the physical 
location of the input to the output. Furthermore, once 
the input and output system be fix on the graph, the 
flow, if it can be constructed, be unique. Hence, in the 
canonical approach to MBQC, the usual procedure be to fix 
the input and the output and assign a partial order of 
measurement that guarantee determinism under a specific 
set of rules. Consequently, the flow construction imposes a 
total order of measurements, which must respect the 
partial one. 
Here, we have reverse this point of view. As such, 

Theorem 3 be base on the nontrivial observation that, for a 
give MBQC resource state with a fix total order of 
measurements, choice of g-flow, i.e., choice of input and 
output vertex on the graph that correspond to different 
deterministic quantum computations, be generally not 
unique. Nonetheless, Alice’s choice of input and output 
enforces a unique computation among all the possible 
choices. This choice of g-flow be not communicate to the 
server and be kept hidden by Alice, who us it to update 
the classical instruction sent to Bob. This observation 
make it possible for a client to conceal the flow of 
quantum information from a quantum server classically 
instruct on what operation to perform. In particular, 
since a large number of other computation be still 
compatible with the information Bob receives, the 
achieve blindness follow from the ambiguity about 
the flow of information on the graph. Furthermore, our 
protocol circumvents the scheme-dependent no-go theo- 
rem for classical blind quantum compute state in 
Ref. [38]. Here, we do not make use of any affine 
encryption on the client’s side, but a mention above, 
we use flow ambiguity to encode a part of the client’s 
computation. As a consequence of this encoding, Protocol 
1 require multiple round of communication between the 
client and server. This requirement be in direct contrast with 
the assumption of Ref. [38], where only one round of 
communication be allowed. 
We can additionally make two important observations. 

The first be that the circuit implementable on Gn;m be not 
classically simulable unless BPP ¼ BQP. This stem from 
the fact that the cluster state be universal with only XY-plane 
measurements, a have recently be proven in Ref. [55]. 
The above bound provide an exponential low bound on 
the number of consistent flow for all cluster states. The 
second observation be that the computation correspond 
to different choice of flow be not equivalent, even when 
classical post-processing be allowed. This can most easily 
be see by consider an example. We consider the 
simplest case of the 2 × 2 plaquette jCSi2;2. In Fig. 4, 
we show an example of two different choice of open 

FIG. 5. List of the nine possible GðI; OÞ2;2 combination 
(and associate patterns) with g-flow for the cluster state 
jCSi2;2. The arrow indicate the direction of the quantum 
information flow. Note that overlap input and output set 
be allowed. All the pattern implement unitary embeddings on 
the input state. 

FIG. 4. A 2 × 2 cluster state with measurement angle 
fα; β; γ; δg. In this example, we show how to encode two 
different computation use a fix total order of measure- 
ments f1; 2; 3; 4g. The difference follow from the choice of 
the GðI; OÞ. In diagram (a), the input set be f1; 3g, and the 
output set be f2; 4g, with g-flow function gð1Þ ¼ f2g and 
gð3Þ ¼ f4g. The equivalent circuit associate with the positive 
branch of this MBQC pattern be show below. Note that any 
final round of correction be push into the classical post- 
processing of the output. In diagram (b), the input set be 
f1; 2g, the output set be f3; 4g, gð1Þ ¼ f3g, and gð2Þ ¼ f4g. 
Similarly to (a), we show the circuit of the positive branch of 
the MBQC pattern, and the final round of correction be 
classically post-processed. 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-10 



graph compatible with the underlie total order of 
measurements. Both choice satisfy the g-flow conditions, 
and a a result, they correspond to two deterministic 
MBQC patterns, i.e., two different and well-defined 

computations. Since in this particular case the input state 
(ĈZjþþi) be equivalent, the difference be dictate by the 
unitary transformation (specified by the measurement 
angles) that act on it. As can be see from Fig. 4, the 
correspond circuit be different and perform different 
unitaries. Because of the flow ambiguity and the obfusca- 
tion due to the one-time pad, a quantum server that be to 
perform the measurement follow Protocol 1, at the end 
of the procedure, would not have enough information to 
exactly identify Alice’s choice of open graph. For G2;2, 
there be nine possible flow configuration a expect 
from Eq. (31), which be depict in Fig. 5. Given any fix 
transcript of the protocol, for each flow there exists a choice 
of α such that it be consistent with the transcript. An 
example run of Protocol 1 be present in Fig. 6 for the 
G2;2 case. 
As a final comment, it be clear that there exist case 

where, for a fix graph and choice of angles, different 
choice of flow will correspond to the same computation. 
For instance, refer to Fig. 5, measure all qubits with 
the same angle would give a two-to-one correspondence for 
some of the computations. However, it be reasonable to 
conjecture that when the angle be chosen from set of 
large cardinality, the mapping will be close to one to one. 
The full characterization of the mapping be left a an open 
problem. 

VI. DISCUSSION AND CONCLUSIONS 

Our overall motivation in this work have be to explore 
the possibility of classically driven blind quantum com- 
putation. While this may seem an impossible task, the fact 
that multiple nonequivalent computation in the MBQC 
model can yield the same transcript of measurement 
angle and results, even when the resource state and 
order of measurement be fixed, allows the tantalize 
possibility that it may be possible for a classical user to 
hide a computation from a quantum server. Protocol 1 
make use of this flow ambiguity to provide some 
measure of hiding for quantum computation chosen 
from certain restrict sets. Our intention in introduce 
this protocol be not to provide a practical cryptographic 
protocol but rather to demonstrate that it be indeed 
possible to hide nonequivalent quantum computation 
use this flow ambiguity. As such, we concentrate on 
show that in a single run of the protocol, the amount of 
information obtain by the server be bounded, rather than 
introduce a composable security definition, which be 
nontrivial give the dependence of the leak information 
on the response of the server. 
Our result provoke a couple of questions. The first and 

most obvious be whether the flow ambiguity effect can be 
exploit to hide a universal set of computation even after 
the measurement angle have be communicate to the 
server. A second and perhaps even more important question 
be whether this phenomenon can be use a a building block 

FIG. 6. Illustration of an exemplary run of Protocol 1. At the start 
of the protocol, Alice’s computation be express a a measurement 
pattern on a graph, in this case, G2;2. This be communicate to Bob, 
who prepares the initial state. The computation then proceeds in 
round with Alice compute the relevant entry of sx and sz and, 
use these together with ri, the measurement angle α0i. The 
measurement angle α0i be communicate to Bob, who performs 
the measurement and return the result to Alice a b0i. From this, 
Alice computesbi asb0i ⊕ ri. This process be repeat until all qubits 
have be measured. At the end of the protocol, for any fix 
transcript of the communication (composedofα0 andb0), it be always 
possible to find a choice for α consistent with the transcript for any 
choice of f. In other words, for any of the possible g-flow 
configuration show in Fig. 5, Bob can find an α that would have 
lead to the transcript he recorded, whichmeans any of those g-flows be 
possible. This ambiguity be responsible for partially hiding Alice’s 
computation from Bob. 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-11 



for verification of quantum computer by completely 
classical users. 

ACKNOWLEDGMENTS 

The author thank Rafael Alexander, Niel de Beaudrap, 
Michal Hajdušek, Elham Kashefi, Simon Perdrix, and 
Carlos Pérez-Delgado for interest discussion and 
valuable insights. T. F. D. thanks Yingkai Ouyang for 
carefully reading an early version of this manuscript 
and for his helpful comments. J. F. F. acknowledges 
support from the Air Force Office of Scientific Research 
under Grant No. FA2386-15-1-4082. N. C. M. be support 
by the Australian Research Council under Grant 
No. DE120102204, by the Australian Research Council 
Centre of Excellence for Quantum Computation and 
Communication Technology (Project No. CE170100012), 
and by the U.S. Defense Advanced Research Projects 
Agency (DARPA) Quiness program under Grant 
No.W31P4Q-15-1-0004. This material be base on research 
fund by the Singapore National Research Foundation 
under NRF Award No. NRF-NRFF2013-01. 

A. M. and T. F. D. contribute equally to this work. 

APPENDIX: FULL JOINT PROBABILITY FOR 
THE PROTOCOL AND CONDITIONAL 

ENTROPY BOUND 

Lemma 4. HðB0;A0jA;FÞ ≥ N regardless of Bob’s 
strategy. 
Proof.—We construct the full joint probability for all of 

the variable in Protocol 1 and use it to explicitly derive 
the desire result. Direct dependency in the joint 
probability will be limited by causality and the assump- 
tions that Alice’s and Bob’s laboratory be secure and 
free of each others’ espionage. These limitation be a 
follows: 

(i) The flow bit F and ideal measurement angle A 
directly depend on no other variables. They be 
input to the problem chosen by Alice and can be 
correlated. 

(ii) Each π-shift bit Rj in R be chosen by flip a fair 
coin; thus, it directly depends on no other variables. 

(iii) Alice assigns A0j base directly on the current Aj, all 
flow bit F, the current Rj, and any prior decode 
bit B<j. 

(iv) Each decode bit Bj directly depends only on Rj 
(the π-shift bit) and the bit B0j receive from Bob. 

(v) Each bit B0j that Bob return to Alice directly 
depends only on the information Bob have on hand 
at the time (specifically,B0<j andA 

0 
≤j), a well a any 

(classical or quantum) stochastic strategy he wish 
to employ. 

With these direct-dependency limitations, we can 
immediately write down the form of the full joint 
probability for the entire protocol: 

Prðb0;α0;α; f;b; rÞ 

¼ Prðα; fÞ 
YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ Prðα0jjαj; f;b<j; rjÞ 

× Prðbjjb0j; rjÞ PrðrjÞ: ðA1Þ 

Furthermore, we can explicitly write several of these 
probabilities: 

Prðbjjb0j; rjÞ ¼ δbjb0j⊕rj ; ðA2Þ 

Prðα0jjαj; f;b<j; rjÞ ¼ δ 
α0j 
Gjðαj;f;b<j;rjÞ; ðA3Þ 

PrðrjÞ ¼ 
1 

2 
; ðA4Þ 

with the deterministic function 

Gjðαj; f;b<j; rjÞ 
≔ ð−1Þsxj ðf;b<jÞαj þ πszjðf;b<jÞ þ πrj mod 2π ðA5Þ 

obtain from Eq. (18). These hold for all j. At this point, 
we have the most general form of the full joint probability 
consistent with the protocol: 

Prðb0;α0;α; f;b; rÞ 

¼ Prðα; fÞ 
2N 

δbb0⊕r 
YN 
j¼1 

Prðb0jjb0<j;α0≤jÞδ 
α0j 
Gjðαj;f;b<j;rjÞ; ðA6Þ 

where we have left Bob’s strategy arbitrary but consistent 
with the direct-dependency restriction give above. 
Marginalizing over B give 

Prðb0;α0;α; f; rÞ 
¼ 

X 
b 

Prðb0;α0;α; f;b; rÞ ðA7Þ 

¼ Prðα; fÞ 
2N 

YN 
j¼1 

Prðb0jjb0<j;α0≤jÞδ 
α0j 
Gjðαj;f;b0<j⊕r<j;rjÞ: ðA8Þ 

From this joint probability distribution, we can 
compute 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-12 



Prðb0;α0jα; fÞ ¼ 
X 
r 

Prðb0;α0;α; f; rÞ 
Prðα; fÞ ðA9Þ 

¼ 1 
2N 

X 
r1 

… 
X 
rN−2 

X 
rN−1 

X 
rN 

YN 
j¼1 

Prðb0jjb0<j;α0≤jÞδ 
α0j 
Gjðαj;f;b0<j⊕r<j;rjÞ ðA10Þ 

¼ 1 
2N 

�YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ 
�X 

r1 

… 
X 
rN−2 

X 
rN−1 

�YN−1 
j¼1 

δ 
α0j 
Gjðαj;f;b0<j⊕r<j;rjÞ 

� 

× ðδα0NGjðαN;f;b0<N⊕r<N;0Þ þ δ 
α0N 
GjðαN;f;b0<N⊕r<N;1ÞÞ|fflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflffl{zfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflfflffl} 

at most one term be nonzero 

ðA11Þ 

≤ 
1 

2N 

�YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ 
�X 

r1 

… 
X 
rN−2 

X 
rN−1 

YN−1 
j¼1 

δ 
α0j 
Gjðαj;f;b0<j⊕r<j;rjÞ ðA12Þ 

≤ 
1 

2N 

�YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ 
�X 

r1 

… 
X 
rN−2 

YN−2 
j¼1 

δ 
α0j 
Gjðαj;f;b0<j⊕r<j;rjÞ ðA13Þ 

.. 

. 

≤ 
1 

2N 

�YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ 
�X 

r1 

δ 
α0 
1 

G1ðα1;f;r1Þ ðA14Þ 

≤ 
1 

2N 

YN 
j¼1 

Prðb0jjb0<j;α0≤jÞ ðA15Þ 

≤ 
1 

2N 
: ðA16Þ 

In the above, we have repeatedly use the fact that Gj have 
at most one rj that make it equal to α0j for any give 
ðαj; f;b<jÞ. Therefore, substitute the above bound into 
the conditional entropy formula give 

HðB0;A0jA;FÞ ¼ 
X 
α;f 

Prðα; fÞHðB0;A0jA ¼ α;F ¼ fÞ 

≥ 
X 
α;f 

Prðα; fÞN ¼ N: ðA17Þ 
□ 

[1] P. W. Shor, Polynomial-Time Algorithms for Prime 
Factorization and Discrete Logarithms on a Quantum 
Computer, SIAM Rev. 41, 303 (1999). 

[2] S. Lloyd, Universal Quantum Simulators, Science 273, 
1073 (1996). 

[3] S. Lloyd, M. Mohseni, and P. Rebentrost, Quantum Algo- 
rithms for Supervised and Unsupervised Machine Learning, 
arXiv:1307.0411 [Phys. Rev. X (to be published)]. 

[4] V. Dunjko, J. Fitzsimons, C. Portmann, and R. Renner, 
Advances in Cryptology—ASIACRYPT 2014 (Springer, 
Berlin, Heidelberg, 2014). 

[5] Formal definition of blindness and verifiability can be 
found in [4]. 

[6] A. Childs, Secure Assisted QuantumComputation, Quantum 
Inf. Comput. 5, 456 (2005). 

[7] P. Arrighi and L. Salvail, Blind Quantum Computation, Int. 
J. Quantum. Inform. 04, 883 (2006). 

[8] A. Broadbent, J. Fitzsimons, and E. Kashefi, Universal 
Blind Quantum Computation, in Proceedings of the 50th 
Annual IEEE Symposium on Foundations of Computer 
Science (FOCS) (IEEE, Atlanta, 2009), pp. 517–526. 

[9] T. Morimae and K. Fujii, Blind Topological Measurement- 
Based Quantum Computation, Nat. Commun. 3, 1036 
(2012). 

[10] T. Sueki, T. Koshiba, and T. Morimae, Ancilla-Driven 
Universal Blind Quantum Computation, Phys. Rev. A 87, 
060301 (2013). 

[11] C.-H. Chien, R. V. Meter, and S.-Y. Kuo, Fault-Tolerant 
Operations for Universal Blind Quantum Computation, 
J. Emerg. Technol. Comput. Syst. 12, 26 (2015). 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-13 

https://doi.org/10.1137/S0036144598347011 
https://doi.org/10.1126/science.273.5278.1073 
https://doi.org/10.1126/science.273.5278.1073 
http://arXiv.org/abs/1307.0411 
https://doi.org/10.1142/S0219749906002171 
https://doi.org/10.1142/S0219749906002171 
https://doi.org/10.1038/ncomms2043 
https://doi.org/10.1038/ncomms2043 
https://doi.org/10.1103/PhysRevA.87.060301 
https://doi.org/10.1103/PhysRevA.87.060301 
https://doi.org/10.1145/2700248 


[12] A. Mantri, C. Perez-Delgado, and J. Fitzsimons, Optimal 
Blind Quantum Computation, Phys. Rev. Lett. 111, 230502 
(2013). 

[13] V. Giovannetti, L. Maccone, T. Morimae, and T. Rudolph, 
Efficient Universal Blind Quantum Computation, Phys. 
Rev. Lett. 111, 230501 (2013). 

[14] C. Perez-Delgado and J. Fitzsimons, Iterated Gate 
Teleportation and Blind Quantum Computation, Phys. 
Rev. Lett. 114, 220502 (2015). 

[15] T. Morimae, Continuous-Variable Blind Quantum Compu- 
tation, Phys. Rev. Lett. 109, 230502 (2012). 

[16] V. Dunjko, E. Kashefi, and A. Leverrier, Blind Quantum 
Computing with Weak Coherent Pulses, Phys. Rev. Lett. 
108, 200502 (2012). 

[17] J. Fitzsimons and E. Kashefi, Unconditionally Verifiable 
Blind Computation, arXiv:1203.5217 [Phys. Rev. X (to be 
published)]. 

[18] M. Hajdušek, C. Perez-Delgado, and J. Fitzsimons, Device- 
Independent Verifiable Blind Quantum Computation, 
arXiv:1502.02563v1 [Phys. Rev. X (to be published)]. 

[19] A. Gheorghiu, E. Kashefi, and P. Wallden, Robustness and 
Device Independence of Verifiable Blind Quantum Comput- 
ing, New J. Phys. 17, 083040 (2015). 

[20] T. Morimae and K. Fujii, Blind Quantum Computation 
Protocol in which Alice Only Makes Measurements, Phys. 
Rev. A 87, 050301 (2013). 

[21] T. Morimae, Verification for Measurement-Only Blind 
Quantum Computing, Phys. Rev. A 89, 060302 (2014). 

[22] M. Hayashi and T. Morimae, Verifiable Measurement-Only 
Blind Quantum Computing with Stabilizer Testing, Phys. 
Rev. Lett. 115, 220502 (2015). 

[23] M.Hayashi andM.Hajdusek,Self-GuaranteedMeasurement- 
Based Quantum Computation, arXiv:1603.02195 [Phys. 
Rev. X (to be published)]. 

[24] S. Barz, E. Kashefi, A. Broadbent, J. Fitzsimons, A. 
Zeilinger, and P. Walther, Demonstration of Blind Quantum 
Computing, Science 335, 303 (2012). 

[25] S. Barz, J. Fitzsimons, E. Kashefi, and P. Walther, Exper- 
imental Verification of Quantum Computation, Nat. Phys. 9, 
727 (2013). 

[26] C. Greganti, M.-C. Roehsner, S. Barz, T. Morimae, and P. 
Walther, Demonstration of Measurement-Only Blind 
Quantum Computing, New J. Phys. 18, 013020 (2016). 

[27] D. Aharonov, M. Ben-Or, and E. Eban, in Proceedings of 
Innovations in Computer Science (Tsinghua University 
Press, Beijing, 2010). 

[28] A. Broadbent, How to Verify a Quantum Computation, 
arXiv:1509.09180. 

[29] B. Reichardt, F. Unger, and U. Vazirani, Classical Com- 
mand of Quantum Systems, Nature (London) 496, 456 
(2013). 

[30] M. McKague, Interactive Proofs for BQP via Self-Tested 
Graph States, Theo. Comput. 12, 1 (2016). 

[31] J. F. Fitzsimons and M. Hajdušek, Post Hoc Verification of 
Quantum Computation, arXiv:1512.04375 [Phys. Rev. Lett. 
(to be published)]. 

[32] T. Morimae and J. F. Fitzsimons, Post Hoc Verification with 
a Single Prover, arXiv:1603.06046 [Phys. Rev. Lett. (to be 
published)]. 

[33] P. Hauke, F. M. Cucchietti, L. Tagliacozzo, I. Deutsch, and 
M. Lewenstein, Can One Trust Quantum Simulators?, Rep. 
Prog. Phys. 75, 082401 (2012). 

[34] M. Cramer, M. B. Plenio, S. T. Flammia, R. Somma, 
D. Gross, S. D. Bartlett, O. Landon-Cardinal, D. Poulin, 
and Y.-K. Liu, Efficient Quantum State Tomography, Nat. 
Commun. 1, 149 (2010). 

[35] L. Aolita, C. Gogolin, M. Kliesch, and J. Eisert, Reliable 
Quantum Certification of Photonic State Preparations, Nat. 
Commun. 6, 8498 (2015). 

[36] D. Hangleiter, M. Kliesch, M. Schwarz, and J. Eisert, Direct 
Certification of a Class of Quantum Simulations, Quantum 
Science Technology 2, 015004 (2017). 

[37] M. Walschaers, J. Kuipers, J.-D. Urbina, K. Mayer, M. C. 
Tichy, K. Richter, and A. Buchleitner, Statistical Benchmark 
for Boson Sampling, New J. Phys. 18, 032001 (2016). 

[38] T. Morimae and T. Koshiba, Impossibility of Secure Cloud 
Quantum Computing for Classical Client, arXiv:1407.1636. 

[39] S. Aaronson, A. Cojocaru, A. Gheorghiu, and E. Kashefi, 
On the Implausibility of Classical Client Blind Quantum 
Computing, arXiv:1704.08482v1. 

[40] V. Dunjko and E. Kashefi, Blind Quantum Computing with 
Two Almost Identical States, arXiv:1604.01586. 

[41] R. Raussendorf and H. J. Briegel, A One-Way Quantum 
Computer, Phys. Rev. Lett. 86, 5188 (2001). 

[42] D. Gottesman and I. L. Chuang,Demonstrating the Viability 
of Universal Quantum Computation Using Teleportation 
and Single-Qubit Operations, Nature (London) 402, 390 
(1999). 

[43] X. Zhou, D. W. Leung, and I. L. Chuang, Methodology for 
Quantum Logic Gate Constructions, Phys. Rev. A 62, 
052316 (2000). 

[44] D. Browne, E. Kashefi, M. Mhalla, and S. Perdrix, 
Generalized Flow and Determinism in Measurement-Based 
Quantum Computation, New J. Phys. 9, 250 (2007). 

[45] D. Markham and E. Kashefi, Entanglement, Flow and 
Classical Simulatability in Measurement Based Quantum 
Computation, arXiv:1311.3610. 

[46] M. Nielsen and I. Chuang, Quantum Computation and 
Quantum Information (Cambridge University Press, 
Cambridge, England, 2000). 

[47] V. Danos and E. Kashefi, Determinism in the One-Way 
Model, Phys. Rev. A 74, 052310 (2006). 

[48] V. Danos, E. Kashefi, and P. Panangaden, The Measurement 
Calculus, J. ACM 54, 8 (2007). 

[49] R. Raussendorf, D. E. Browne, and H. J. Briegel, 
Measurement-Based Quantum Computation on Cluster 
States, Phys. Rev. A 68, 022312 (2003). 

[50] T. M. Cover and J. A. Thomas, Elements of Information 
Theory (John Wiley & Sons, New York, 2012). 

[51] D. Gottesman, The Heisenberg Representation of Quantum 
Computers, arXiv:quant-ph/9807006. 

[52] M. Mhalla, M. Murao, S. Perdrix, M. Someya, and P. S. 
Turner, Which Graph States be Useful for Quantum 
Information Processing?, in Theory of Quantum Compu- 
tation, Communication, and Cryptography, edit by D. 
Bacon, M. Martin-Delgado, and M. Roetteler, Lecture 
Notes in Computer Science Vol. 6745 (Springer, Berlin, 
Heidelberg, 2014), p. TQC 2011. 

MANTRI, DEMARIE, MENICUCCI, and FITZSIMONS PHYS. REV. X 7, 031004 (2017) 

031004-14 

https://doi.org/10.1103/PhysRevLett.111.230502 
https://doi.org/10.1103/PhysRevLett.111.230502 
https://doi.org/10.1103/PhysRevLett.111.230501 
https://doi.org/10.1103/PhysRevLett.111.230501 
https://doi.org/10.1103/PhysRevLett.114.220502 
https://doi.org/10.1103/PhysRevLett.114.220502 
https://doi.org/10.1103/PhysRevLett.109.230502 
https://doi.org/10.1103/PhysRevLett.108.200502 
https://doi.org/10.1103/PhysRevLett.108.200502 
http://arXiv.org/abs/1203.5217 
http://arXiv.org/abs/1203.5217 
http://arXiv.org/abs/1502.02563v1 
https://doi.org/10.1088/1367-2630/17/8/083040 
https://doi.org/10.1103/PhysRevA.87.050301 
https://doi.org/10.1103/PhysRevA.87.050301 
https://doi.org/10.1103/PhysRevA.89.060302 
https://doi.org/10.1103/PhysRevLett.115.220502 
https://doi.org/10.1103/PhysRevLett.115.220502 
http://arXiv.org/abs/1603.02195 
http://arXiv.org/abs/1603.02195 
https://doi.org/10.1126/science.1214707 
https://doi.org/10.1038/nphys2763 
https://doi.org/10.1038/nphys2763 
https://doi.org/10.1088/1367-2630/18/1/013020 
http://arXiv.org/abs/1509.09180 
https://doi.org/10.1038/nature12035 
https://doi.org/10.1038/nature12035 
https://doi.org/10.4086/toc.2016.v012a003 
http://arXiv.org/abs/1512.04375 
http://arXiv.org/abs/1512.04375 
http://arXiv.org/abs/1603.06046 
http://arXiv.org/abs/1603.06046 
https://doi.org/10.1088/0034-4885/75/8/082401 
https://doi.org/10.1088/0034-4885/75/8/082401 
https://doi.org/10.1038/ncomms1147 
https://doi.org/10.1038/ncomms1147 
https://doi.org/10.1038/ncomms9498 
https://doi.org/10.1038/ncomms9498 
https://doi.org/10.1088/2058-9565/2/1/015004 
https://doi.org/10.1088/2058-9565/2/1/015004 
https://doi.org/10.1088/1367-2630/18/3/032001 
http://arXiv.org/abs/1407.1636 
http://arXiv.org/abs/1704.08482v1 
http://arXiv.org/abs/1604.01586 
https://doi.org/10.1103/PhysRevLett.86.5188 
https://doi.org/10.1038/46503 
https://doi.org/10.1038/46503 
https://doi.org/10.1103/PhysRevA.62.052316 
https://doi.org/10.1103/PhysRevA.62.052316 
https://doi.org/10.1088/1367-2630/9/8/250 
http://arXiv.org/abs/1311.3610 
https://doi.org/10.1103/PhysRevA.74.052310 
https://doi.org/10.1145/1219092.1219096 
https://doi.org/10.1103/PhysRevA.68.022312 
http://arXiv.org/abs/quant-ph/9807006 


[53] A. Ambainis, A. Nayak, A. Ta-Shma, and U. Vazirani,Dense 
Quantum Coding and a Lower Bound for 1-Way Quantum 
Automata, in Proceedings of the 31st Annual ACM Sympo- 
sium on Theory of Computing, 1999, pp. 376–383. 

[54] A. Nayak, Optimal Lower Bounds for Quantum Automata, 
and Random Access Codes, in Proceedings of the 40th 

Annual Symposium on Foundations of Computer Science 
(FOCS ’99) (IEEE Computer Society, Washington, DC, 
1999), p. 369. 

[55] A. Mantri, T. F. Demarie, and J. F. Fitzsimons, Universality 
of Quantum Computation with Cluster States and (X, Y)- 
Plane Measurements, Sci. Rep. 7, 42861 (2017). 

FLOW AMBIGUITY: A PATH TOWARDS CLASSICALLY … PHYS. REV. X 7, 031004 (2017) 

031004-15 

https://doi.org/10.1038/srep42861 

