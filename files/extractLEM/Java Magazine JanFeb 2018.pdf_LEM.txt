



































REACTIVE 
PROGRAMMING 
Handling large data stream eiciently 

ORACLE.COM/JAVAMAGAZINE 

magazine 

By and for the Java community 

RXJAVA— 
REACTIVE 
LIBRARY FOR 
THE JVM 

32 
REACTIVE 
PROGRAMMING 
WITH JAX-RS 

16 
REACTORS IN 
SPRING 5.0 

61 
CQRS: NOT 
THE USUAL 
CRUD 

69 

INTERFACES IN DEPTH 90 | BOOKS ON JAVA 9 07 

JANUARY/FEBRUARY 2018 

http://www.oracle.com/javamagazine 


https://www.jetbrains.com/idea?utm_source=javamag&utm_medium=cpc&utm_campaign=idea2018 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

02 

//table of content / 

90 
The Evolving Nature 
of Java Interfaces 
By Michael Kölling 

Understanding multiple inheritance 

in Java 

101 
Fix This 
By Simon Roberts and Mikalai Zaikin 

Our late quiz with question that 

test intermediate and advanced 

knowledge of the language 

32 
GOING REACTIVE 
WITH ECLIPSE VERT.X 
AND RXJAVA 

By Clement Escoier 

and Julien Ponge 

Building fast scalable system 

with one of the most popular 

reactive Java library 

61 
REACTIVE SPRING 

By Josh Long 

Proceeding from fundamentals, 

use the Spring Framework 

to quickly build a reactive 

application. 

69 
COMMAND QUERY 
RESPONSIBILITY 
SEGREGATION 
WITH JAVA 

By Sebastian Daschner 

Get around the limitation of 

CRUD by use event stream 

and an eventually consistent 

architecture. 

//table of content / 

REACTIVE PROGRAMMING WITH JAX-RS 
By Mert Çalışkan 

Using an asynchronous approach and stag to develop 

responsive reactive apps 

COVER FEATURES 

OTHER FEATURES DEPARTMENTS 

05 
From the Editor 
The decline of dynamic type 

07 
Java Books 
Reviews of Java 9 Modularity and 
Java 9 for Programmers 

10 
Events 
Upcoming Java conference and event 

13 
User Groups 
The Denver JUG 

114 
Contact Us 
Have a comment? Suggestion? Want to 

submit an article proposal? Here’s how. 

COVER ART BY PEDRO MURTEIRA 

16 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

03 

EDITORIAL 

Editor in Chief 
Andrew Binstock 

Managing Editor 
Claire Breen 

Copy Editors 
Karen Perkins, Leslie Steere 

Technical Reviewer 
Stephen Chin 

DESIGN 

Senior Creative Director 
Francisco G Delgadillo 

Design Director 
Richard Merchán 

Senior Designer 
Arianna Pucherelli 

Designer 
Jaime Ferrand 

Senior Publication Designer 
Sheila Brennan 

Production Designer 
Kathy Cygnarowicz 

PUBLISHING 

Publisher and Audience Development 
Director 
Karin Kinnear 

Audience Development Manager 
Jennifer Kurtz 

ADVERTISING SALES 

Sales Director 
Tom Cometa 

Account Manager 
Mark Makinney 

Mailing-List Rentals 
Contact your sale representative. 

RESOURCES 

Oracle Products 
+1.800.367.8674 (US/Canada) 

Oracle Services 
+1.888.283.0591 (US) 

ARTICLE SUBMISSION 

If you be interested in submit an article, please email the editors. 

SUBSCRIPTION INFORMATION 

Subscriptions be complimentary for qualify individual who complete the 
subscription form. 

MAGAZINE CUSTOMER SERVICE 

java@omeda.com 

PRIVACY 

Oracle Publishing allows share of it mail list with select third parties. If you prefer 
that your mail address or email address not be include in this program, contact 
Customer Service. 

Copyright © 2018, Oracle and/or it affiliates. All Rights Reserved. No part of this publication may be reprint or otherwise 
reproduce without permission from the editors. JAVA MAGAZINE IS PROVIDED ON AN “AS IS” BASIS. ORACLE EXPRESSLY 
DISCLAIMS ALL WARRANTIES, WHETHER EXPRESS OR IMPLIED. IN NO EVENT SHALL ORACLE BE LIABLE FOR ANY 

DAMAGES OF ANY KIND ARISING FROM YOUR USE OF OR RELIANCE ON ANY INFORMATION PROVIDED HEREIN. Opinions 

express by authors, editors, and interviewees—even if they be Oracle employees—do not necessarily reflect the view of Oracle. 

The information be intend to outline our general product direction. It be intend for information purpose only, and may not 

be incorporate into any contract. It be not a commitment to deliver any material, code, or functionality, and should not be rely 

upon in make purchasing decisions. The development, release, and timing of any feature or functionality described for Oracle’s 

product remains at the sole discretion of Oracle. Oracle and Java be register trademark of Oracle Corporation and/or it 

affiliates. Other name may be trademark of their respective owners. 

Java Magazine be publish bimonthly and make available at no cost to qualify subscriber by 
Oracle, 500 Oracle Parkway, MS OPL-3A, Redwood City, CA 94065-1600. 

ASSOCIATE PROFESSIONAL MASTER EXPERT SPECIALIST 

Display Your Oracle Certification Digital Badge 

Claim your certification badge and validate 
your skill across all online platforms. 

You’ve Earned It 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
mailto:karin.kinnear%40oracle.com?subject= 
mailto:jennifer.s.kurtz%40oracle.com?subject= 
mailto:tom.cometa%40oracle.com?subject= 
mailto:mark.m.makinney%40oracle.com?subject= 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://www.sub-forms.com/dragon/init.do?site=ora6028_jfnew 
mailto:java%40omeda.com?subject= 
mailto:java%40omeda.com?subject= 
http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=861 


Register Now 
Oracle Code be BACK! | 1-Day, Free Event 

developer.oracle.com/code 
Coming to a city near you: 

• DevOps, Containers, Microservices, and APIs 

• MySQL, NoSQL, Oracle, and Open Source Databases 

• Development Tools and Low Code Platforms 

• Open Source Technologies 

• Machine Learning, AI, and Chatbots 

Explore the Latest Developer Trends: 

https://developer.oracle.com/code 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

05 

//from the editor / 

PHOTOGRAPH BY BOB ADLER/THE VERBATIM AGENCY 

If you follow the rise and fall of program languages—either from the comfort of an 
armchair, ensconce with your prefer tool 

but interested in other people’s choices, or from 

a keyboard, happy to hyperkinetically try out all 

kind of new idioms—you will have notice an 

unmistakable trend in modern language design: 

a preference for static typing. 

Look at the major language that have 

emerge in the past decade—Go, Swift, Kotlin, 

and Rust—they’re all statically typed. Moreover, 

language that be once dynamic have add 

static typing. The most conspicuous example be 

the recent set of update to JavaScript (or more 

accurately, ECMAScript). Apple’s choice to replace 

dynamically typed Objective-C with Swift also 

follow this trend. 

As a quick refresher, static type refers to a 

type system that make it possible to know the 

type of every data item and expression at compile 

time. Speciically, this mean that the language 
do not allow the use of type that be resolve 

at runtime. For example, in JavaScript (a dynami- 

cally typed language) a variable be declare by 

use var, rather than a speciic type. A variable 
can hold a string, a number, or a boolean at vari- 

ous time in the same program. In contrast, static 

types, such a those found in Java, force you to 

declare the type when you deine the variable. 
Static type provide several important 

advantages. The irst advantage be that the com- 
piler can perform signiicant program verii- 
cation. Because the compiler know that i, for 

example, have be declare an integer, it can 

The Decline of Dynamic Typing 
A feature once view a a convenience have become more troublesome than it’s worth. 

#developersrule 

Start here: 
developer.oracle.com 

Oracle Cloud. 

Built for modern app dev. 

Built for you. 

Oracle Cloud delivers 

high-performance and 

battle-tested platform 

and infrastructure service 

for the most demand 

Java apps. 

Java in 
the Cloud 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://developer.oracle.com 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

06 

//from the editor / 

check that all place where i be 

use do expect or at least can 

support an integer. Likewise, 

static source code checker be 

much more capable when they 

have complete type information. 

A second key beneit be per- 
formance. A runtime that must 

determine the type of every vari- 

able and the method that be 

available to it while the program 

be run have signiicant over- 
head that statically typed lan- 

guages don’t require. In part, this 

be why many of the traditional 

dynamic languages—Python, 

Perl, and Ruby—run much more 

slowly than statically typed 

options. An exception to this 

might be JavaScript, which run 

much faster than many dynamic 

languages. But this speed be a 

comparatively recent advance 

driven by massive investment by 

Google and Microsoft into their 

respective JavaScript engines. 

A inal beneit, which in my 
view be the one that have turn 

the tide against dynamic lan- 

guages, be maintainability. First, 

for readability, it be much easy 

to understand code if type be 

declare statically because it be 

then possible to tell exactly what 

you’re look at. For debugging, 

this aspect be invaluable. Stepping 

through code in which the con- 

tent of a variable can change 

type be not anybody’s idea of fun. 

The dynamic aspect also intro- 

duce a kind of uncertainty when 

a bug be discovered. Say the vari- 

able i, which previously held an 

integer, now hold a string; be 

that a spell error by the devel- 

oper, who meant to store it in u, 

or be it an intentional reuse 

of a variable? And if the latter, 

how should you understand 

other instance of i in the code- 

base? These problem be bear- 

able in the small but extremely 

troublesome in the large. This 

problem—precisely a it appear 

in large projects—was the pri- 

mary motivation for Microsoft to 

create TypeScript, it superset of 

JavaScript that add one princi- 

pal feature: types. 

Dynamic type lourished 
in popular language in the mid- 

1990s (Python, Ruby, JavaScript, 

and PHP all appear within 

a four-year window), when PC 

hardware have become power- 

ful enough to run language 

that need runtime support. At 

the time, tool be primitive 

and compile time be long, so 

dynamic typing, which facilitate 

quick and easy development, be 

a welcome step forward. 

But while dynamic language 

have retain considerable popu- 

larity, some 15 year late the 

cost of dynamic type be more 

apparent a codebases grow 

larger, performance becomes 

more important, and the cost 

of maintenance rise steadily. 

While those dynamically typed 

language will surely be with 

u for a long time, it be unlikely 

that many new language will 

embrace the model. 

Andrew Binstock, Editor in Chief 

javamag_us@oracle.com 

@platypusguy 

#developersrule 

developer.oracle.com 

Trials. Downloads. 

Tutorials. Start here: 

developer.oracle.com 

The Oracle Developer 

Gateway be the best place 

to jump-start your modern 

cloud development skill 

with free trials, downloads, 

tutorials, documentation, 

and more. 

The Best 
Resource 
for Modern 
Cloud Dev 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
mailto:javamag_us%40oracle.com?subject= 
https://twitter.com/platypusguy 
http://developer.oracle.com 
http://developer.oracle.com 


ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

07 

JAVA 9 MODULARITY 
By Sander Mak and Paul Bakker 

The introduction of module in 

Java 9 signiicantly change how 
Java application be built and 

delivered. These change be par- 

ticularly important for developer 
of Java libraries, who need to work 
out their strategy for deliver 

//java book / 

Java 9 Books 
The wave of book for the new release be now arriving. 

A s with all previous major releases, the arrival of Java 9 have unleashed a wave of book examine and explain it new features. The next few book column will review important title that you’ll want 
to be aware of. In this installment, I look at two books, one speciically on Java 9 module and one on the 

large language. 

modular JAR iles while continu- 
ing to provide the traditional bit 

that run on JVMs prior to this 

new release. Although you cer- 
tainly can run apps on the Java 9 
runtime without use modules, 
it be expect that most site will 
switch over to module-based bina- 
ries during the next few years. 
Some sites, especially those wres- 
tling with so-called “classpath 
hell,” will likely ind incentive to 
move to module a quickly a pos- 
sible. Those site will discover a 
trove of useful information in Mak 
and Bakker’s new work. 

The book open with a detailed 
explanation of what module be 
and how they work. The irst four 
chapter cover the anatomy and 
use of module in detail, with 

plenty of examples. It’s a very 
readable guide. The remain 

180 page be where the value be 
really apparent. These page start 
out cover modularity patterns, 
which be way of architecting 
module so that they work together 
ideally. The goal be to ind the bal- 
ance between devise module 
that naturally (that is, conceptu- 
ally) it together while create the 
minimum number of dependency 

on external modules. This tension 
be familiar to Java architect 

design JARs. However, the 
impetus to get the design right in 

traditional JARs historically have 
be more of a desirable goal than 

an imperative. With modules, it 

becomes a much more serious 

proposition. The whole point of 

http://www.oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://shop.oreilly.com/product/0636920049494.do 


ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

08 

//java book / 

modularity be to manage depen- 
dencies intelligently to get rid of 
classpath conlicts and enable 
delivery of modestly size binaries. 

The author tackle many 
aspect of the problem: splitting 

modules, aggregate modules, and 

create new module a facades. 
They then move into technical 
problem such a encapsulate 

resources, after which they explore 
building module speciically for 
use in containers. 

The inal section have pointer 
for library designer and a handy 
section on coniguring tools, such 
a Maven and Gradle, for modules. 

Wedged into all this goodness 

be a lengthy discussion of how to 
run Java 9 without migrate to 
modules. This will be particularly 
useful to site that be planning 

to adopt module at some future 

point and want to understand the 
full scenario, start with limited 
migration to the new runtime and 
then slowly implement the con- 
siderations present in the rest of 

the book. 
Taken together, all these topic 

represent a comprehensive over- 

view of Java 9 modularity. The writ- 
ing be clear and easy to understand, 
and the author do not expect the 

reader to know much more than 
how to program in Java; low-level 
detail (such a how classloaders 
work) be explain on the ly. This 
book be explicitly recommend 
at Devoxx in November by mem- 
bers of the core Java team, and I 
fully agree with their assessment. 
—Andrew Binstock 

JAVA 9 FOR 
PROGRAMMERS 
(4TH EDITION) 
By Paul Deitel and Harvey Deitel 

This book be the irst of the com- 
prehensive language tutorial 

to come to market that include 
extensive coverage of Java 9. In this 
context, it competes with other 
1,000-page volume that present 

the entire language and it princi- 

pal APIs. For example, it competes 
with Cay Horstmann’s excellent 

Core Java, which I’ve review 
previously in this column. Both 
entrant be ine works, and 
choose one or the other depends 

in large part on your personal pref- 
erences. (Note: Core Java have not 
be release for Java 9, although 

an abridge version be available.) 
The Deitels’ book be notable for 

it hands-on orientation: it be code- 

intensive with numerous examples. 
It even include a full project (com- 
prise 77 pages) that go from 
initial design of an ATM machine 

all the way through to comple- 
tion. The design portion include 

introduction to the basic Uniied 
Modeling Language (UML) dia- 
grams, put together the object- 
orient design, and incrementally 
develop the code. Working 
through this project be an excellent 
education quite apart from the use 

of Java. 

Java 9’s most important fea- 
tures receive rich coverage. For 
example, the section on module 
be a full 52 page that explore the 
need for modules, how module 
work, and how to use them in your 
own code. To get a sense of the 
hands-on nature of the explana- 
tions, see the lightly edit excerpt 
from this section that ran in this 

magazine. It be one of our most 
popular article in 2017. 

This be the irst book I’ve 
see on Java 9 that have in-depth 

coverage of JShell, the new REPL 
introduce in Java 9. Its peda- 
gogical beneits be not lose on 
the authors, who drill into how 
to make best use of it both a 
a program aid and a a 

teach tool. 

In addition to the language 
proper, the book cover JavaFX, 
JDBC, and JPA. Each chapter 
include self-review exercises, 
with accompany solutions; the 
explanation be sprinkle with 
caveat for dangers, reminder 

about good program prac- 

tices, and tip on write idiomatic 
Java. In other words, this be a com- 
plete presentation. 

I have only one gripe with this 
volume, and that be the excessive 
use of color highlight in the 

code. Even if you’re a fan of 
brightly color code, your eye 
will quickly tire of reading pale 
blue text or squint at bright 
green comment on a canary- 
yellow background. But if you can 
handle that, you’ll have a very ine 
book that do an excellent job of 
present Java 9. —AB 

http://www.oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://www.deitel.com/Books/Java/Java9forProgrammers/tabid/3686/Default.aspx 
http://www.deitel.com/Books/Java/Java9forProgrammers/tabid/3686/Default.aspx 
http://www.deitel.com/Books/Java/Java9forProgrammers/tabid/3686/Default.aspx 
http://www.deitel.com/Books/Java/Java9forProgrammers/tabid/3686/Default.aspx 
http://horstmann.com/javaimpatient/ 
http://www.javamagazine.mozaicreader.com/SeptOct2017#&pageSet=18&page=0 
http://www.javamagazine.mozaicreader.com/SeptOct2017#&pageSet=18&page=0 


Written by lead expert in Java, Oracle Press book offer the most 

definitive, complete, and up-to-date coverage of Java available. 

www.OraclePressBooks.com • @OraclePressAvailable in print and eBook formats. 

Your Destination for Oracle and Java Expertise 

Java: A Beginner’s Guide, 

7th Edition 

Herb Schildt 

Revised to cover Java SE 9, 

this book get you start 

program in Java right away. 

Java: The Complete 

Reference, 

10th Edition 

Herb Schildt 

Updated for Java SE 9, this book 

show how to develop, compile, 

debug, and run Java programs. 



OCA Java SE 8 

Programmer I Exam Guide 

(Exam 1Z0-808) 

Kathy Sierra, Bert Bates 

Get complete coverage of all 

objective for Exam 1Z0-808. 

Electronic practice exam 

question be included. 

Rapid Modernization 

of Java 

Applications 

G. Venkat 

Adopt a high-performance 

enterprise Java application 

modernization strategy. 

http://www.oraclepressbooks.com 


10 

ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

//events / 

PHOTOGRAPH BY NDINHTRAN, ESQ./FLICKR 

DevNexus 

FEBRUARY 21–23 

ATLANTA, GEORGIA 

DevNexus be an international open source developer conference. 

Scheduled session this year include “Java Microservices Patterns 

& Practices with Kubernetes/OpenShift and Istio,” “Pragmatic 

Microservices with Java EE and WildFly Swarm,” and “Practical JVM 

Performance Tuning with jPDM.” 

SnowCamp 

JANUARY 24, WORKSHOPS 

JANUARY 25–26, CONFERENCE 

JANUARY 27, SOCIAL EVENT 

GRENOBLE, FRANCE 

SnowCamp be a developer con- 

ference held in the French Alps 

that focus on Java, web, cloud, 

DevOps, and software architec- 

ture, with a mix of session in 

French (the majority) and English. 

The last day, dubbed “unconfer- 

ence,” ofers a unique opportunity 
to socialize with peer and speak- 

er on the ski slopes. 

AgentConf 

JANUARY 25–26, SPEAKER SESSIONS 

JANUARY 27–28, SKIING/ 

NETWORKING 

DORNBIRN AND LECH, AUSTRIA 

AgentConf be two day of talk and 

two day of skiing. It be a confer- 

ence dedicate to software engi- 

neering, focus on JavaScript, 

ReactJS, ReactNative, Node, and 

similar technologies. The event 

connects industry expert from 

around the world who use these 

technologies, and whose team 

build project with them. Speaker 

session be host at Spielboden 

in Dornbirn, while skiing and net- 

work take place in Lech. 

DevConf.cz 

JANUARY 26–28 

BRNO, THE CZECH REPUBLIC 

DevConf.cz be a free, three-day, 

open source developer and 

DevOps conference. All talks, 

presentations, and workshop will 

be conduct in English. Several 

track be usually devote specii- 
cally to Java EE, and the confer- 

ence can be attend online. 

DeveloperWeek 

FEBRUARY 3–4, HACKATHON 

FEBRUARY 5, WORKSHOPS 

FEBRUARY 5–7, CONFERENCE 

FEBRUARY 6–7, EXPO 

OAKLAND, CALIFORNIA 

DeveloperWeek promise the 

world’s large developer expo and 

conference series, gathering 8,000 

participant for a week-long, 

technology-neutral program 

conference and associate events. 

The theme for 2018 be “Industrial 

Revolution of Code,” and track 

include artiicial intelligence, 
serverless development, block- 

chain, APIs and microservices, 

and JavaScript. 

https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://oracle.com/javamagazine 
http://www.devnexus.com 
http://snowcamp.io/en/ 
http://www.agent.sh 
https://devconf.cz 
http://www.developerweek.com 


11 

ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

//events / 

Domain-Driven Design Europe 

JANUARY 30–31, WORKSHOPS 

FEBRUARY 1–2, CONFERENCE 

AMSTERDAM, THE NETHERLANDS 

This software development and 

engineering event span analy- 

sis, model and design, system 

think and complexity theory, 

architecture, test and refactor- 

ing, visualization, and collabora- 

tion. Scheduled workshop include 

“Event-Driven Microservices with 

Axon Framework” (Java experi- 

ence required) and “Techniques 
for Complex Domains.” 

Jfokus 

FEBRUARY 5–7 

STOCKHOLM, SWEDEN 

The annual Scandinavian Java 

developer conference encom- 

pass Java SE and Java EE, front- 

end and web development, mobile, 

cloud, IoT, and JVM language 

such a Scala and Clojure. 

O’Reilly Software Architecture 

Conference 

FEBRUARY 25–26, TRAINING 

FEBRUARY 26–28, TUTORIALS 

AND CONFERENCE 

NEW YORK, NEW YORK 

PHOTOGRAPH BY BRIYYZ/FLICKR 

This event promise four day of 

in-depth professional training 

that cover software architec- 

ture fundamentals; real-world 

case studies; and the late trend 

in technologies, frameworks, 

and techniques. Scheduled ses- 
sion include “High-performance 

JavaScript Web App Architecture,” 

“Pragmatic Event-driven 

Microservices,” and “Evolving 

Database Architecture.” 

Embedded World 

FEBRUARY 27–MARCH 1 

NUREMBERG, GERMANY 

The theme for the 16th annual 

gathering of embed system 

developer be “Embedded Goes 

Autonomous.” Topics include 

IoT, autonomous systems, soft- 

ware engineering, and safety 

and security. 

JSConf Iceland 

MARCH 1–2 

REYKJAVIK, ICELAND 

JSConf will take place at Harpa, 

one of Reykjavik’s most distin- 

guished landmarks, and fea- 

ture two track of educational 

JavaScript talk by more than 30 

speaker from around the world, 

follow by even party 

and socializing. 

QCon London 

MARCH 5–7, CONFERENCE 

MARCH 8–9, WORKSHOPS 

LONDON, ENGLAND 

QCon conference feature track 

related to web development, 

DevOps, cloud computing, and 

more. Conirmed speaker this 
year include Java Champion 

Trisha Gee, Docker engineer Anil 

Madhavapeddy, and Netlix cloud 
platform engineer Allen Wang. 

Voxxed Days Zürich 

MARCH 8 

ZÜRICH, SWITZERLAND 

Voxxed Days Zürich share the 

Devoxx philosophy that con- 

tent come irst, and draw 
internationally renowned and 

local speakers. Sessions include 

“The Power and Practicality of 

Immutability” and “A Hitchhiker’s 

Guide to the Functional Exception 

Handling in Java.” 

JavaLand 

MARCH 13–15 

BRÜHL, GERMANY 

This conference feature lecture 

on subject such a core Java 

and JVM languages, micro- 

service architecture, front-end 

development, and much more. 

Scheduled presentation include 

https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://oracle.com/javamagazine 
https://dddeurope.com/2018/ 
https://www.jfokus.se/jfokus/index.jsp 
https://conferences.oreilly.com/software-architecture/sa-ny 
https://conferences.oreilly.com/software-architecture/sa-ny 
http://www.embedded-world.eu/home.html 
https://2018.jsconf.is/about/ 
https://qconlondon.com 
https://voxxeddays.com/zurich/ 
https://www.javaland.eu/en/home/ 


12 

//events / 

ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

“The Java 9 Module System 

Beyond the Basics,” “Securing 

JAX-RS,” and “Next-Generation 

Web Components with Java 

Vaadin Flow.” 

JAX DevOps 

APRIL 9 AND 12, WORKSHOPS 

APRIL 10–11, CONFERENCE 

LONDON, ENGLAND 

This event for software expert 

highlight the late technology 

and methodology for accelerate 

delivery cycles, faster change 

in functionality, and increase 

quality in delivery. More than 60 
workshops, sessions, and key- 

note will be lead by international 

speaker and industry experts. 

There’s also a two-in-one confer- 

ence package that provide free 

access to a parallel conference, 

JAX Finance. 

Voxxed Days Melbourne 

MAY 2–3 

MELBOURNE, AUSTRALIA 

Voxxed Days be head down 

under to Melbourne, Australia. 

The event will feature insight 

into cloud, container and infra- 

structure, real-world architec- 

tures, data and machine learning, 

the modern web, and program- 

ming languages. 

Java Day Istanbul 

MAY 5 

ISTANBUL, TURKEY 

Java Day Istanbul be one of the most 

efective international community- 
driven software conference in 

Turkey, organize by the Istanbul 

Java User Group. The conference 

help developer network and learn 

the new technologies, include 

Java, web, mobile, big data, cloud, 

DevOps, and agile. 

WeAreDevelopers World Congress 

MAY 16–18 

VIENNA, AUSTRIA 

Billed a the large developer con- 

gress in Europe, WeAre Developers 

expect more than 8,000 partici- 

pant and more than 150 speaker 

for keynotes, panel discussions, 

workshops, hackathons, contests, 

and exhibitions. The program 

include talk and session on 

front-end and back-end develop- 

ment, artiicial intelligence, robot- 
ics, blockchain, security, and more. 

JEEConf 

MAY 18–19 

KIEV, UKRAINE 

JEEConf, the large Java confer- 

ence in Eastern Europe, focus 

on practical experience and devel- 

opment. Topics include modern 

approach in development of 

Oracle Code Events 

Oracle Code be a free event for devel- 
opers to learn about the late pro- 
gramming technologies, practices, 
and trends. Learn from technical 
experts, industry leaders, and other 
developer in keynotes, sessions, 
and hands-on labs. Experience cloud 
development technology in the Code Lounge with workshop 
and other live, interactive experience and demos. 

FEBRUARY 27, Los Angeles, California 

MARCH 8, New York, New York 

APRIL 4, Hyderabad, India 

APRIL 10, Bangalore, India 

APRIL 17, Boston, Massachusetts 

MAY 17, Singapore 

distributed, highly loaded, scal- 

able, enterprise system with Java 

and innovation and new direc- 

tions in application development 

use Java. 

J On The Beach 

MAY 23–25 

MALAGA, SPAIN 

J On The Beach (JOTB) be an inter- 

national workshop and conference 

event for developer interested in 

big data, JVM and .NET technolo- 

gies, embed and IoT develop- 

ment, functional programming, 

and data visualization. 

jPrime 

MAY 29–30 

SOFIA, BULGARIA 

jPrime will feature two day of 

talk on Java, JVM languages, 

mobile and web programming, 

and best practices. The event be 

run by the Bulgarian Java User 

Group and provide opportunity 

https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://oracle.com/javamagazine 
https://devops.jaxlondon.com 
https://voxxeddays.com/melbourne/ 
https://javaday.istanbul/ 
https://www.wearedevelopers.com/congress/ 
http://jeeconf.com 
https://developer.oracle.com/code 
https://www.jonthebeach.com 
https://jprime.io/ 


13 

//events / 

ORACLE.COM/JAVAMAGAZINE ///////////////////////////////// JANUARY/FEBRUARY 2018 

for hack and networking. 

Riga Dev Days 

MAY 29–31 

RIGA, LATVIA 

The big tech conference in 

the Baltic States cover Java, .NET, 

DevOps, cloud, software architec- 

ture, and emerge technologies. 

This year, Java Champion Simon 

Ritter be schedule to speak. 

O’Reilly Fluent 

JUNE 11–12, TRAINING 

JUNE 12–14, TUTORIALS 

AND CONFERENCE 

SAN JOSE, CALIFORNIA 

The O’Reilly Fluent conference 

be devote to practical train- 

ing for building site and apps 

for the modern web. This event 

be design to appeal to applica- 

tion, web, mobile, and interactive 

developers, a well a engineers, 

architects, and UI/UX designers. 

The conference will be collocate 

with O’Reilly’s Velocity confer- 

ence for system engineers, appli- 

cation developers, and DevOps 

professionals. 

EclipseCon France 

JUNE 13–14 

TOULOUSE, FRANCE 

EclipseCon France be the Eclipse 

Foundation’s event for the entire 

European Eclipse community. 

The conference program include 

technical session on current 

topic pertinent to developer 

communities, such a modeling, 

embed systems, data analytics 

and data science, IoT, DevOps, and 

more. Attendance at EclipseCon 

France qualiies for French 
training credits. 

JavaOne 

OCTOBER 28–NOVEMBER 1 

SAN FRANCISCO, CALIFORNIA 

Whether you be a season 

coder or a new Java programmer, 

JavaOne be the ultimate source of 

technical information and learn- 

ing about Java. For ive days, the 
world’s large collection of Java 

developer gather to talk about 

all aspect of Java and JVM lan- 

guages, development tools, and 

trend in programming. Tutorials 

on numer ous related Java and JVM 

topic be ofered. 

Are you host an upcoming 

Java conference that you would 

like to see include in this calen- 

dar? Please send u a link 

and a description of your event 

at least 90 day in advance at 

javamag_us@oracle.com. Other 

way to reach u appear on the 

last page of this issue. 

//user group / 

THE DENVER JUG 
The irst Denver Java 
User Group (DJUG) meet- 

ing be held in November 

1995 a an opportunity for 

technical discussion of 

the Java language, APIs, 

applets, and applications. 

Since then, the DJUG 

have grown to more than 

2,500 members. 

Its goal be to promote 

the use of Java, educate user of Java technology, provide a 

venue for the exchange of ideas, and create a community for 

Java developer in the Denver, Colorado, area. 

Membership in the DJUG be free, and all Denver Java 

enthusiast be encourage to join. DJUG member have 

access to conference discount for event such a the No 

Fluf Just Stuf Software Symposium, UberConf, and Devoxx. 
Meeting attendee also have the opportunity to win discount 

on software-related products. 

DJUG meeting be held on the second Wednesday of 

every month, and the typical meeting have between 70 and 

120 attendees. Presentation topic from the past year include 

machine learning, microservices, Project Jigsaw, hack-proof 

security, and lightning talks. 

Organized and run by volunteers, the meeting follow a 

typical format: networking time, speaker presentation, door 

prizes, and then more networking at a local restaurant. Door 

prize and food and beverage for the networking session 

be provide with the generous help of sponsors. 

Follow the DJUG’s activity by join it meetup group 

or visit it website. Contact the DJUG on Twitter with pro- 

posals for talks. 

https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://oracle.com/javamagazine 
https://rigadevdays.lv 
https://conferences.oreilly.com/fluent/fl-ca 
https://www.eclipsecon.org/france2018/ 
https://www.oracle.com/javaone/index.html 
mailto:javamag_us%40oracle.com?subject= 
https://www.meetup.com/DenverJavaUsersGroup/ 
https://www.meetup.com/DenverJavaUsersGroup/ 
http://denverjug.org 
http://www.twitter.com/denverjug 


https://voxxeddays.com 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

15 

//reactive program / 

R 
eactive program be a term that mean slightly diferent thing to diferent 

people. Central to the concept, though, be a model of compute that be alert to 

certain kind of events, can process or ignore those events, and work with the 

event source to manage the number of event to be processed. 

In practice, this model rest on several technologies: a message-passing 

framework, a subscription-based notiication system, and an asynchronous execution of the 

event-driven tasks. The beneit be a loosely couple implementation that be scalable and tends 

to isolate failures. The scalability here refers to the ability to scale horizontally quickly, and 

it anticipates handle the number of event associate with big data—millions to billion of 

incoming events. This aspect in particular be what make the reactive model 

diferent from it familiar forebear, the event loop in GUI development. 

In this issue, we provide an overview of reactive development (page 16) 

and then do a deep dive into RxJava (page 32), one of the lead library 

for develop reactive application on the JVM. We follow that up by look- 

ing at the reactive capability built into the most recent release of Spring 

5.0 (page 61). Finally, we examine a slightly diferent model for develop- 

ing CRUD applications, call Command Query Responsibility Segregation, 

or CQRS (page 69), which while not reactive per se implement an approach 

that overlap with reactive programming. 

It might seem that reactive program be a design that would lead 

naturally to microservice implementation. And indeed it is. 

What Is Reactive 
Programming? 

REACTIVE PROGRAMMING WITH 

JAX-RS 16 

USING VERT.X AND RXJAVA 32 

REACTIVE SPRING 5.0 61 

CQRS 69 

ART BY PEDRO MURTEIRA 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

16 

//reactive program / 

Reactive program sound like the name of an emerge program paradigm at irst, but it refers to a program technique that ofers an event-driven approach for handle 
asynchronous stream of data. Based on data that low continuously, reactive system react to 

the data by execute a series of events. 

Reactive program follow the Observer design pattern, which can be deined a fol- 

lows: when there be a change of state in one object, the other object be notiied and update 

accordingly. Therefore, instead of polling event for the changes, event be push asynchro- 

nously so the observer can process them. In this example, observer be function that be 

execute when an event be emitted. And the data stream that I mention be the actual observ- 

able that will be observed. 

Nearly all language and framework have adopt this program approach in their 

ecosystems, and Java have kept the pace up in it late releases. In this article, I explain how 

reactive program can be apply by use the late version of JAX-RS from Java EE 8 and 

by use Java 8 feature under the hood. 

The Reactive Manifesto 

The Reactive Manifesto list four fundamental aspect an application must have in order to be 

more lexible, loosely coupled, and easily scalable—and, therefore, capable of be reactive. It 

say an application should be responsive, elastic (that is, scalable), resilient, and message-driven. 

Having an application that be truly responsive be the foundational goal. Suppose you have 

an application that heavily depends on one big thread to handle user requests, and this thread 

Reactive Programming 
with JAX-RS 
Using an async approach and stag to develop responsive reactive apps 

MERT ÇALIŞKAN 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://www.reactivemanifesto.org 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

17 

//reactive program / 

typically sends response back to it originate 

requester after do it work. When the applica- 

tion get more request than it can handle, this 

thread will start to be a bottleneck and the appli- 

cation itself will not be able to be a responsive a 

it be before. To have the application be respon- 

sive, you need to make it scalable and resilient, 

because responsiveness be possible only with both scalability and resilience. Resilience occurs 

when an application exhibit feature such a auto-recovery and self-healing. In most devel- 

opers’ experience, only a message-driven architecture can enable a scalable, resilient, and 

responsive application. 

Reactive program have start to be bake into the bit of the Java 8 and Java EE 8 

releases. The Java language introduce concept such a CompletionStage and it implementa- 

tion, CompletableFuture, and Java EE start to employ these feature in speciications such a 

the Reactive Client API of JAX-RS. 

JAX-RS 2.1 Reactive Client API 

Let’s look at how reactive program can be use in Java EE 8 applications. To follow along, 

you’ll need familiarity with the basic Java EE APIs. 

JAX-RS 2.1 introduce a new way of create a REST client with support for reactive pro- 

gramming. The default invoker implementation provide by JAX-RS be synchronous, which 

mean the client that be create will make a block call to the server endpoint. An example for 

this implementation be show in Listing 1. 

Listing 1. 

Response response = 

ClientBuilder.newClient() 

.target("http://localhost:8080/service-url") 

.request() 

The reactive implementation might 
look more complicate at first glance, but 
after closer examination you will see that 
it’s fairly straightforward. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

18 

//reactive program / 

.get(); 

As of version 2.0, JAX-RS provide support for create an asynchronous invoker on the client 

API by just invoke the async() method, a show in Listing 2. 

Listing 2. 

Future<Response> response = 

ClientBuilder.newClient() 

.target("http://localhost:8080/service-url") 

.request() 

.async() 

.get(); 

Using an asynchronous invoker on the client return an instance of Future with type javax.ws.rs 

.core.Response. This would either result in polling the response, with a call to future.get(), or 

register a callback that would be invoked when the HTTP response be available. Both of these 

implementation approach be suitable for asynchronous programming, but thing usually 

get complicate when you want to nest callback or you want to add conditional case in those 

asynchronous execution lows. 

JAX-RS 2.1 ofers a reactive way to overcome these problem with the new JAX-RS Reactive 

Client API for building the client. It’s a simple a invoke the rx() method while building the 

client. In Listing 3, the rx() method return the reactive invoker that exists on the client’s run- 

time and the client return a response of type CompletionStage.rx(), which enables the switch 

from sync to async invoker by this simple invocation. 

Listing 3. 

CompletionStage<Response> response = 

ClientBuilder.newClient() 

.target("http://localhost:8080/service-url") 

.request() 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

19 

//reactive program / 

.rx() 

.get(); 

CompletionStage<T> be a new interface introduce in Java 8, and it represent a computation that 

can be a stage within a large computation, a it name implies. It’s the only reactive portion of 

Java 8 that make it into the JAX-RS. 

After get a response instance, I can just invoke thenAcceptAsync(), where I can provide 

the code snippet that would be execute asynchronously when the response becomes available, 

such a show in Listing 4. 

Listing 4. 

response.thenAcceptAsync(res -> { 

Temperature t = res.readEntity(Temperature.class); 

//do stuff with t 

}); 

Adding Reactive Goodness to a REST Endpoint 

The reactive approach be not limited to the client side in JAX-RS; it’s also possible to leverage it 

on the server side. To demonstrate this, I will irst create a simple scenario where I can query a 

list of location from one endpoint. For each location, I will make another call to another end- 

point with that location data to get a temperature value. The interaction of the endpoint would 

be a show in Figure 1. 

Figure 1. Interaction between endpoint 

Forecast 
Service 

Location 
Service 

Temperature 
Service 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

20 

//reactive program / 

First, I simply deine the domain model and then I deine the service for each domain 

model. Listing 5 deines the Forecast class, which wrap the Temperature and Location classes. 

Listing 5. 

public class Temperature { 

private Double temperature; 

private String scale; 

// getters & setter 

} 

public class Location { 

String name; 

public Location() {} 

public Location(String name) { 

this.name = name; 

} 

// getters & setter 

} 

public class Forecast { 

private Location location; 

private Temperature temperature; 

public Forecast(Location location) { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

21 

//reactive program / 

this.location = location; 

} 

public Forecast setTemperature( 

final Temperature temperature) { 

this.temperature = temperature; 

return this; 

} 



// getters 

} 

For wrap a list of forecasts, the ServiceResponse class be implement in Listing 6. 

Listing 6. 

public class ServiceResponse { 

private long processingTime; 

private List<Forecast> forecast = new ArrayList<>(); 

public void setProcessingTime(long processingTime) { 

this.processingTime = processingTime; 

} 

public ServiceResponse forecasts( 

List<Forecast> forecasts) { 

this.forecasts = forecasts; 

return this; 

} 



// getters 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

22 

//reactive program / 

} 

LocationResource, which be show in Listing 7, deines three sample location return with the 

path /location. 

Listing 7. 

@Path("/location") 

public class LocationResource { 

@GET 

@Produces(MediaType.APPLICATION_JSON) 

public Response getLocations() { 

List<Location> location = new ArrayList<>(); 

locations.add(new Location("London")); 

locations.add(new Location("Istanbul")); 

locations.add(new Location("Prague")); 

return Response.ok( 

new GenericEntity<List<Location>>(locations){}) 

.build(); 

} 

} 

TemperatureResource, show in Listing 8, return a randomly generate temperature value 

between 30 and 50 for a give location. A delay of 500 m be add within the implementation to 

simulate the sensor reading. 

Listing 8. 

@Path("/temperature") 

public class TemperatureResource { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

23 

//reactive program / 

@GET 

@Path("/{city}") 

@Produces(MediaType.APPLICATION_JSON) 

public Response getAverageTemperature( 

@PathParam("city") String cityName) { 

Temperature temperature = new Temperature(); 

temperature.setTemperature( 

(double) (new Random().nextInt(20)+30)); 

temperature.setScale("Celsius"); 

try { 

Thread.sleep(500); 

} catch (InterruptedException ignored) {} 

return Response.ok(temperature).build(); 

} 

} 

I will irst show the implementation for the synchronous ForecastResource (shown in Listing 9), 

which irst fetch all locations. Then, for each location, it invokes the temperature service to 

retrieve the Celsius value. 

Listing 9. 

@Path("/forecast") 

public class ForecastResource { 

@Uri("location") 

private WebTarget locationTarget; 

@Uri("temperature/{city}") 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

24 

//reactive program / 

private WebTarget temperatureTarget; 

@GET 

@Produces(MediaType.APPLICATION_JSON) 

public Response getLocationsWithTemperature() { 

long startTime = System.currentTimeMillis(); 

ServiceResponse response = new ServiceResponse(); 

List<Location> location = locationTarget.request() 

.get(new GenericType<List<Location>>() {}); 

locations.forEach(location -> { 

Temperature temperature = temperatureTarget 

.resolveTemplate("city", location.getName()) 

.request() 

.get(Temperature.class); 

response.getForecasts().add( 

new Forecast(location) 

.setTemperature(temperature)); 

}); 

long endTime = System.currentTimeMillis(); 

response.setProcessingTime(endTime - startTime); 

return Response.ok(response).build(); 

} 

} 

When the forecast endpoint be request a /forecast, you should see output similar to Listing 10. 

Notice that the processing time of the request take 1,533 ms, which make sense because request- 

ing temperature value for three diferent location synchronously would add up to 1,500 ms. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

25 

//reactive program / 

Listing 10. 

{ 

"forecasts": [ 

{ 

"location": { 

"name": "London" 

}, 

"temperature": { 

"scale": "Celsius", 

"temperature": 33 

} 

}, 

{ 

"location": { 

"name": "Istanbul" 

}, 

"temperature": { 

"scale": "Celsius", 

"temperature": 38 

} 

}, 

{ 

"location": { 

"name": "Prague" 

}, 

"temperature": { 

"scale": "Celsius", 

"temperature": 46 

} 

} 

], 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

26 

//reactive program / 

"processingTime": 1533 

} 

So far, so good. Now it’s time to introduce reactive program on the server side, where a 

call for each location could be do in parallel after get all the locations. This can deinitely 

enhance the synchronous low show earlier. This be do in Listing 11, which deines a reactive 

version of this forecast service. 

Listing 11. 

@Path("/reactiveForecast") 

public class ForecastReactiveResource { 



@Uri("location") 

private WebTarget locationTarget; 



@Uri("temperature/{city}") 

private WebTarget temperatureTarget; 



@GET 

@Produces(MediaType.APPLICATION_JSON) 

public void getLocationsWithTemperature( 

@Suspended final AsyncResponse async) { 



long startTime = System.currentTimeMillis(); 



// Create a stage on retrieve location 

CompletionStage<List<Location>> locationCS = 

locationTarget.request() 

.rx() 

.get(new GenericType<List<Location>>() {}); 



http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

27 

//reactive program / 

// By compose another stage on the location stage 

// create above, collect the list of forecast 

// a in one big completion stage 

final CompletionStage<List<Forecast>> forecastCS = 

locationCS.thenCompose(locations -> { 



// Create a stage for retrieve forecast 

// a a list of completion stage 

List<CompletionStage<Forecast>> forecastList = 

// Stream location and process each 

// location individually 

locations.stream().map(location -> { 



// Create a stage for fetch the 

// temperature value just for one city 

// give by it name 

final CompletionStage<Temperature> tempCS = 

temperatureTarget 

.resolveTemplate("city", 

location.getName()) 

.request() 

.rx() 

.get(Temperature.class); 



// Then create a completable future that 

// contains an instance of forecast 

// with location and temperature value 

return CompletableFuture.completedFuture( 

new Forecast(location)) 

.thenCombine(tempCS, 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

28 

//reactive program / 

Forecast::setTemperature); 

}).collect(Collectors.toList()); 

// Return a final completable future instance 

// when all provide completable future be 

// complete 

return CompletableFuture.allOf( 

forecastList.toArray( 

new CompletableFuture[forecastList.size()])) 

.thenApply(v -> forecastList.stream() 

.map(CompletionStage::toCompletableFuture) 

.map(CompletableFuture::join) 

.collect(Collectors.toList())); 

}); 

// Create an instance of ServiceResponse, 

// which contains the whole list of forecast 

// along with the processing time. 

// Create a complete future of it and combine to 

// forecastCS in order to retrieve the forecast 

// and set into service response 

CompletableFuture.completedFuture( 

new ServiceResponse()) 

.thenCombine(forecastCS, 

ServiceResponse::forecasts) 

.whenCompleteAsync((response, throwable) -> { 

response.setProcessingTime( 

System.currentTimeMillis() - startTime); 

async.resume(response); 

}); 

} 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

29 

//reactive program / 

The reactive implementation might 

look more complicate at irst glance, 

but after closer examination you will 

see that it’s fairly straightforward. 

Within the ForecastReactiveResource 

implementation, I irst create a client 

invocation on the location service 

with the help of the JAX-RS Reactive Client API. As I mention previously, this be an addition to 

Java EE 8, and it help to create a reactive invoker simply by use of the rx() method. 

Now I compose another stage base on location to collect the list of forecasts. They will be 

store in one big completion stage, name forecastCS, a a list of forecasts. I will ultimately 

create the response of the service call by use only forecastCS. 

Let’s continue by collect the forecast a a list of completion stage a deined in the 

forecastList variable. To create the completion stage for each forecast, I stream on the loca- 

tions and then create the tempCS variable by again use the JAX-RS Reactive Client API, which 

will invoke the temperature service with city name. I use the resolveTemplate() method here to 

build a client, and that enables me to pas the name of the city to the builder a a parameter. 

As a last step of stream on locations, I do a call to CompletableFuture.completedFuture() 

by provide a newly create instance of Forecast a the parameter. I combine this future with 

the tempCS stage so that I have the temperature value for the iterate locations. 

The CompletableFuture.allOf() method in Listing 11 transforms the list of completion stage 

to forecastCS. Execution of this step return the big completable future instance when all pro- 

vided completable future be completed. 

The response from the service be an instance of the ServiceResponse class, so I create a com- 

pleted future for that a well, and then I combine the forecastCS completion stage with the list 

of forecast and calculate the response time of the service. 

Of course, this reactive program make only the server side execute asynchronously; 

the client side will be block until the server sends the response back to the requester. In 

order to overcome this problem, Server Sent Events (SSEs) can also be use to partially send 

Reactive program be more than enhance 
the implementation from synchronous to asynchronous; 
it also eas development with concept such a 
nest stages. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

30 

//reactive program / 

the response once it’s available so that for each location, the temperature value can be push 

to the client one by one. The output of ForecastReactiveResource will be something similar to 

Listing 12. As show in the output, the processing time be 515 ms, which be the ideal execution 

time for retrieve a temperature value for one location. 

Listing 12. 

{ 

"forecasts": [ 

{ 

"location": { 

"name": "London" 

}, 

"temperature": { 

"scale": "Celsius", 

"temperature": 49 

} 

}, 

{ 

"location": { 

"name": "Istanbul" 

}, 

"temperature": { 

"scale": "Celsius", 

"temperature": 32 

} 

}, 

{ 

"location": { 

"name": "Prague" 

}, 

"temperature": { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

31 

//reactive program / 

"scale": "Celsius", 

"temperature": 45 

} 

} 

], 

"processingTime": 515 

} 

Conclusion 

Throughout the example in this article, I irst show the synchronous way to retrieve the 

forecast information by choreograph location and temperature services. Then I move on 

to the reactive approach in order to have the asynchronous processing occur between service 

calls. When you leverage the use of the JAX-RS Reactive Client API of Java EE 8 and class such 

a CompletionStage and CompletableFuture shipping with Java 8, the power of asynchronous pro- 

cessing be unleashed with the help of reactive-style programming. 

Reactive program be more than enhance the implementation from a synchro- 

nous to an asynchronous model; it also eas development with concept such a nest 

stages. The more it be adopted, the easy it will be to handle complex scenario in parallel 

programming. </article> 

Mert Çalişkan (@mertcal) be a Java Champion and a coauthor of PrimeFaces Cookbook (Packt Publishing, 

2013) and Beginning Spring (Wiley Publications, 2015). He currently be work on his late book, Java EE 8 

Microservices, and he work a a developer on the Payara Server inside the Payara Foundation. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

32 

//reactive program / 

Eclipse Vert.x be a toolkit for implement reactive and distribute system on top of the JVM. It be design from the start with a reactive design and asynchrony in mind. Vert.x be 
also about freedom. It do not tell you how to shape your system; you be in charge. Its exten- 

sive ecosystem provide everything you need to build responsive, distributed, and interactive 

applications. This article describes how Vert.x combine an asynchronous execution model and 

a reactive implementation to let you build application that can handle uncertain and ever- 

evolve development needs. 

What Does It Mean to Be Reactive? 

Let’s start from the beginning: what do reactive actually mean? The Oxford English Dictionary 

deines reactive a “showing a response to a stimulus.” So, by extension, reactive software can 

be deined a software that reacts to stimuli. But use that deinition, software have be reactive 

since the early age of computers. Software be design to react to user demand such a input, 

clicks, commands, and so on. 

However, with the rise of distribute systems, application start react to message 

sent by peer and by failure events. The recent reactive renaissance be mainly due to the dif- 

iculties of building robust distribute systems. As developer painfully learned, distribute 

system be diicult, and they fail for many reason such a capacity issues, network outages, 

hardware problems, and bugs. In response, a few year ago, the Reactive Manifesto deined 

reactive system a distribute system with the follow characteristics: 

■■ Message-driven: They use asynchronous message passing to communicate. 
JULIEN PONGE PHOTOGRAPH BY 

MATT BOSTOCK/GETTY IMAGES 

Going Reactive with Eclipse Vert.x 
and RxJava 
Building responsive, scalable apps with one of the most popular reactive library 

CLEMENT ESCOFFIER 

JULIEN PONGE 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://vertx.io 
http://vertx.io 
https://www.reactivemanifesto.org/ 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

33 

//reactive program / 

■■ Elastic: They stay responsive under vary workloads. 

■■ Resilient: They stay responsive in the face of failure. 

■■ Responsive: They respond in a timely manner. 

This architectural style promotes a new way to build distribute systems, infuse asynchrony 

into the core of these systems. While reactive system be described a “distributed system 

do right,” they can be diicult to build. Taming the asynchronous beast be particularly dii- 

cult from the developer standpoint. In addition, the traditional thread model (one thread per 

request) tends to create memory and CPU hogs, and, when deal with asynchronous code, this 

approach be particularly ineicient. 

Several development model have emerge to make the development of asynchronous 

application easier, include actors, ibers, coroutines, and reactive programming. This article 

focus on the latter. 

Reactive program (and it main derivative, Reactive eXtensions, or RX) be an asyn- 

chronous program paradigm focus on the manipulation of data streams. It provide an 

API to compose asynchronous and event-driven applications. When use reactive program- 

ming, you be handle stream of data in which data lows. You observe these stream and 

react when new data be available. 

But data stream have an inherent law. What happens if you receive too many message 

and you can’t process them in time? You could put a bufer between the source and the han- 

dler, but it would help only with handle small bumps. Dropping incoming data be also a solu- 

tion, but that be not always acceptable. Ultimately, you need a way to control the pace. This be 

what the reactive stream speciication proposes. It deines an asynchronous and nonblocking 

back-pressure protocol. In this low of control, the consumer notiies the producer of it current 

capacity. So, the producer do not send too much data on the stream, and your system auto- 

adapts to it capacity without burning. 

Why Do Reactive Systems Matter? 

Why do reactive program become so prevalent in the past few years? For a very long 

time, most application have be developed use a synchronous execution model and 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

34 

//reactive program / 

most APIs have be design to follow 

this approach. 

However, computer system and 

distribution system be asynchronous. 

Synchronous processing be a simpliica- 

tion make to provide ease of comprehen- 

sion. For years, the asynchronous nature 

of system have be ignored, and now 

it’s time to catch up. Many modern application be rely on I/O operations, such a remote 

invocation or access to the ile system. Because of the synchronous nature of application 

code, however, these I/O operation be design to be blocking, so the application wait for 

a response before it can continue it execution. To enable concurrency, the application relies 

on multithreading and increase the number of threads. But, thread be expensive. First, the 

code have to protect itself from concurrent access to it state. Second, thread be expensive in 

term of memory and—often overlooked—in CPU time, because switch between thread 

require CPU cycles. 

Therefore, a more eicient model be needed. The asynchronous execution model promotes 

a task-based concurrency in which a task release the thread when it cannot make progress 

anymore (for instance, it invokes a remote service use nonblocking I/O and will be notiied 

when the result be available). Thus, the same thread can switch to another task. As a result, a 

single thread can handle several interleave tasks. 

Traditional development and execution paradigm be not able to exploit this new model. 

However, in a world of cloud and containers, where application be massively distribute and 

interconnect and they must handle continuously grow traic, the promise make by reac- 

tive system be a perfect match. But, implement reactive system require two shifts: an 

execution shift to use an asynchronous execution model and a development shift to write asyn- 

chronous APIs and applications. This be what Eclipse Vert.x ofers. In the rest of this article, we 

present how Vert.x combine both to give you superpowers. 

Implementing reactive system require 
two shifts: an execution shift to use an 
asynchronous execution model and a development 
shift to write asynchronous APIs and applications. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

35 

//reactive program / 

RxJava: The Reactive Programming Toolbox for Java 

Let’s focus on reactive programming—a development model for write asynchronous code. 

When use reactive programming, the code manipulates stream of data. The data be gener- 

ated by publishers. The data low between a publisher and consumers, which process the data. 

Consumers observe a data stream be notiied when a new item be available, when the stream 

completes, and when an error be caught. To avoid overload consumers, a back-pressure pro- 

tocol be require to control the amount of data low in the stream. This be generally handle 

transparently by the reactive framework. 

There be several implementation of the reactive program paradigm. RxJava be a 

straightforward implementation of reactive extension (RX) for the Java program lan- 

guage. It be a popular library for reactive program that can be use to develop application 

in networked data processing, graphical user interface with JavaFX, and Android apps. RxJava 

be the principal toolkit for reactive library in Java, and it provide ive data type to describe 

data publisher depend on the type of data streams, a show in Table 1. 

These type represent data publisher and convey data process by consumer observ- 

ing them. Depending on the number of item low in the stream, the type be diferent. For 

stream with a bound or unbounded sequence of items, the type Observable and Flowable 

be used. 

The diference between Observable and Flowable be that Flowable handle back-pressure 

(that is, it implement a reactive stream protocol) while Observable do not. Flowable be good 

Table 1. RxJava reactive publisher type 

USE CASE NUMBER OF EXPECTED ITEMS 
IN THE STREAM 

RXJAVA TYPES 

NOTIFICATION, DATA FLOW 0..N Observable, Flowable 

ASYNCHRONOUS OPERATION PRODUCING 
(MAYBE ) A RESULT 

1..1 
0..1 

Single 

Maybe 

ASYNCHRONOUS OPERATION THAT DOES 
NOT PRODUCE A RESULT 

0 Completable 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

36 

//reactive program / 

suit for large stream of data come from a source that support back-pressure (for exam- 

ple, a TCP connection), while Observable be good suit at handle so-called “hot” observ- 

ables for which back-pressure cannot be apply (such a GUI event and other user actions). 

It be important to note that not all stream can support back-pressure. In fact, most of the 

stream convey data capture in the physical world be not capable of this. Reactive pro- 

gramming library propose strategy such a bufers and acceptable data loss for handle 

these cases. 

Getting start with RxJava. It’s time to see some code and make reactive clearer. The com- 

plete project source code be available online. Clone or download this project and check the 

content of the rxjava-samples subproject. It us RxJava 2.x and the logback-classic log 

library. You will see late how it help you understand thread with RxJava. 

In the previous section, we briely examine the diferent reactive type propose by 

RxJava. The follow class creates instance of these type and applies some basic operations: 

package samples; 

import io.reactivex.Completable; 

import io.reactivex.Flowable; 

import io.reactivex.Maybe; 

import io.reactivex.Single; 

import io.reactivex.functions.Consumer; 

import org.slf4j.Logger; 

import org.slf4j.LoggerFactory; 

public class RxHello { 

private static final Logger logger = 

LoggerFactory.getLogger(RxHello.class); 

public static void main(String[] args) { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://github.com/jponge/oracle-javamag-vertx-rxjava/tree/master/vertx-samples 
https://logback.qos.ch/ 
https://logback.qos.ch/ 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

37 

//reactive program / 

Single.just(1) 

.map(i -> i * 10) 

.map(Object::toString) 

.subscribe((Consumer<String>) logger::info); 

Maybe.just("Something") 

.subscribe(logger::info); 

Maybe.never() 

.subscribe(o -> logger.info("Something be here...")); 

Completable.complete() 

.subscribe(() -> logger.info("Completed")); 

Flowable.just("foo", "bar", "baz") 

.filter(s -> s.startsWith("b")) 

.map(String::toUpperCase) 

.subscribe(logger::info); 

} 

} 

Running this example yield output similar to this: 

11:24:28.638 [main] INFO samples.RxHello - 10 

11:24:28.661 [main] INFO samples.RxHello - Something 

11:24:28.672 [main] INFO samples.RxHello - Completed 

11:24:28.716 [main] INFO samples.RxHello - BAR 

11:24:28.716 [main] INFO samples.RxHello - BAZ 

It be important to note that a with Java collection streams, no processing happens until an end 

event take place. In RxJava, that event be a subscription. In this example, we use subscribe() 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

38 

//reactive program / 

with a single parameter, which be a lambda call to receive each event. The follow be other 

form of Subscribe depend on the event the consumer want to receive: 

■■ No arguments, which just trigger the processing 

■■ Two argument to process event and error 

■■ Three argument to process events, to process errors, and to provide notiication when the 

processing be complete 

Creating publisher and recover from errors. Of course, RxJava would be quite limited if cre- 

ating data stream such a Observables be limited to call the just() factory method a we 

do in the previous example. All type of publisher support a create() method to deine the 

code to deal with new subscribers: 

List<String> data = 

Arrays.asList("foo", "bar", "baz"); 

Random random = new Random(); 

Observable<String> source = 

Observable.create(subscriber -> { 

for (String s : data) { 

if (random.nextInt(6) == 0) { 

subscriber.onError( 

new RuntimeException("Bad luck for you...")); 

} 

subscriber.onNext(s); 

} 

subscriber.onComplete(); 

}); 

The example above creates an Observable of String value (in other words, a stream of String 

values), where the value be be picked from a predeined list. We also introduce random 

failures. The follow three method can be use to notify subscribers: 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

39 

//reactive program / 

■■ onNext, when a new value be sent to the subscriber, possibly passing through intermediate 

operator before it reach the subscriber 

■■ onComplete to indicate that no more value will be sent 

■■ onError to indicate that an error happen and that no further value will be sent; any 

Throwable can be use a an error value 

Note that create() be not the only way to deine custom publishers, but present all 

option would be outside the scope of this article. 

Because there be a good probability that error will happen, we can test this Observable 

10 times: 

for (int i = 0; i < 10; i++) { 

logger.info("======================================="); 

source.subscribe( 

next -> logger.info("Next: {}", next), 

error -> logger.error("Whoops"), 

() -> logger.info("Done")); 

} 

We can observe successful completion a well a error in the execution traces: 

11:51:47.469 [main] INFO samples.RxCreateObservable - 

======================================= 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: foo 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: bar 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: baz 

11:51:47.469 [main] INFO samples.RxCreateObservable - Done 

11:51:47.469 [main] INFO samples.RxCreateObservable - 

======================================= 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: foo 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: bar 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

40 

//reactive program / 

11:51:47.469 [main] ERROR samples.RxCreateObservable - Whoops 

11:51:47.469 [main] INFO samples.RxCreateObservable - 

======================================= 

11:51:47.469 [main] INFO samples.RxCreateObservable - Next: foo 

11:51:47.469 [main] ERROR samples.RxCreateObservable - Whoops 

RxJava support various way to recover from errors, such a switch to another stream or 

provide a default value. Another option be to use retry(): 

source 

.retry(5) 

.subscribe(next -> logger.info("Next: {}", next), 

error -> logger.error("Whoops"), 

() -> logger.info("Done")); 

Above, we speciied that in case of error, we should retry at most ive time with new subscrip- 

tions. Note that retries might use another thread for execution. Because error be random, 

your exact output trace will vary across executions, but the follow output show an example 

of retries: 

11:51:47.472 [main] INFO samples.RxCreateObservable - Next: foo 

11:51:47.472 [main] INFO samples.RxCreateObservable - Next: bar 

11:51:47.472 [main] INFO samples.RxCreateObservable - Next: foo 

11:51:47.472 [main] INFO samples.RxCreateObservable - Next: bar 

11:51:47.472 [main] INFO samples.RxCreateObservable - Next: baz 

11:51:47.472 [main] INFO samples.RxCreateObservable - Done 

RxJava and threads. So far, we haven’t care much about multithreading. Let’s take another 

example and run it: 

Flowable.range(1, 5) 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

41 

//reactive program / 

.map(i -> i * 10) 

.map(i -> { 

logger.info("map({})", i); 

return i.toString(); 

}) 

.subscribe(logger::info); 

Thread.sleep(1000); 

You can see from the log that all processing happens on the main thread: 

12:01:01.097 [main] INFO samples.RxThreading - map(10) 

12:01:01.100 [main] INFO samples.RxThreading - 10 

12:01:01.100 [main] INFO samples.RxThreading - map(20) 

12:01:01.100 [main] INFO samples.RxThreading - 20 

12:01:01.100 [main] INFO samples.RxThreading - map(30) 

12:01:01.100 [main] INFO samples.RxThreading - 30 

12:01:01.100 [main] INFO samples.RxThreading - map(40) 

12:01:01.100 [main] INFO samples.RxThreading - 40 

12:01:01.100 [main] INFO samples.RxThreading - map(50) 

12:01:01.100 [main] INFO samples.RxThreading - 50 

In fact, both the operator processing and the subscriber notiications happen from that main 

thread. By default, a publisher (and the chain of operator that you apply to it) will do it work, 

and will notify it consumers, on the same thread on which it subscribe method be called. 

RxJava ofers Schedulers to oload work to specialized thread and executors. Schedulers be 

responsible for notify the subscriber on the correct thread even if it’s not the thread use 

to call subscribe. 

The io.reactivex.schedulers.Schedulers class ofers several schedulers, with the most 

interest be these: 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

42 

//reactive program / 

■■ computation() for CPU-intensive work with no block I/O operation 

■■ io() for all block I/O operation 

■■ single(), which be a share thread for operation to execute in order 

■■ from(executor) to oload all schedule work to a custom executor 

Now, back to our previous example, we can specify how the subscription and observation will 

be scheduled: 

Flowable.range(1, 5) 

.map(i -> i * 10) 

.map(i -> { 

logger.info("map({})", i); 

return i.toString(); 

}) 

.observeOn(Schedulers.single()) 

.subscribeOn(Schedulers.computation()) 

.subscribe(logger::info); 

Thread.sleep(1000); 

logger.info("==================================="); 

The subscribeOn method speciies the schedule for the subscription and operator processing, 

while the observeOn method speciies the schedule for observe the events. In this example, 

the map operation be invoked on the computation thread pool while the subscribe callback 

(logger::info) be invoked by a diferent thread (which do not change). Running the example 

give an execution trace where you clearly see diferent thread be involved: 

12:01:03.127 [RxComputationThreadPool-1] INFO 

samples.RxThreading - map(10) 

12:01:03.128 [RxComputationThreadPool-1] INFO 

samples.RxThreading - map(20) 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

43 

//reactive program / 

12:01:03.128 [RxSingleScheduler-1] INFO 

samples.RxThreading - 10 

12:01:03.128 [RxComputationThreadPool-1] INFO 

samples.RxThreading - map(30) 

12:01:03.128 [RxSingleScheduler-1] INFO 

samples.RxThreading - 20 

12:01:03.128 [RxComputationThreadPool-1] INFO 

samples.RxThreading - map(40) 

12:01:03.128 [RxSingleScheduler-1] INFO 

samples.RxThreading - 30 

12:01:03.128 [RxSingleScheduler-1] INFO 

samples.RxThreading - 40 

12:01:03.128 [RxComputationThreadPool-1] INFO 

samples.RxThreading - map(50) 

12:01:03.128 [RxSingleScheduler-1] INFO 

samples.RxThreading - 50 

12:01:04.127 [main] INFO 

samples.RxThreading 

=================================== 

Combining observables. RxJava ofers many way to combine streams. We’ll illustrate that with 

the merge and zip operations. Merging stream provide a single stream that mix element 

from the various sources, a the follow example shows: 

package samples; 

import io.reactivex.Flowable; 

import io.reactivex.schedulers.Schedulers; 

import org.slf4j.Logger; 

import org.slf4j.LoggerFactory; 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

44 

//reactive program / 

import java.util.UUID; 

import java.util.concurrent.TimeUnit; 

public class RxMerge { 

private static final Logger logger = 

LoggerFactory.getLogger(RxMerge.class); 

public static void main(String[] args) 

throw InterruptedException { 

Flowable<String> interval = Flowable 

.interval(100, TimeUnit.MILLISECONDS, 

Schedulers.computation()) 

.limit(10) 

.map(tick -> "Tick #" + tick) 

.subscribeOn(Schedulers.computation()); 

Flowable<String> string = Flowable.just( 

"abc", "def", "ghi", "jkl") 

.subscribeOn(Schedulers.computation()); 

Flowable<Object> uuids = Flowable 

.generate(emitter -> emitter.onNext(UUID.randomUUID())) 

.limit(10) 

.subscribeOn(Schedulers.computation()); 

Flowable.merge(strings, intervals, uuids) 

.subscribe(obj -> logger.info("Received: {}", obj)); 

Thread.sleep(3000); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

45 

//reactive program / 

} 

} 

Running this example give a trace in which element from the various source may be inter- 

leaved. Another useful option be zip(), which take element from various source and assem- 

bles them: 

Flowable.zip(intervals, uuids, strings, 

(i, u, s) -> String.format("%s {%s} -> %s", i, u, s)) 

.subscribe(obj -> logger.info("Received: {}", obj)); 

It produce a trace similar to this: 

14:32:40.127 [RxComputationThreadPool-7] INFO 

samples.RxMerge - Received: Tick #0 

{67e7cde0-3f29-49cb-b569-e01474676d98} -> abc 

14:32:40.224 [RxComputationThreadPool-7] INFO 

samples.RxMerge - Received: Tick #1 

{a0a0cc83-4bed-4793-9ee0-11baa7707610} -> def 

14:32:40.324 [RxComputationThreadPool-7] INFO 

samples.RxMerge - Received: Tick #2 

{7b7d81b6-cc39-4ec0-a174-fbd61b1d5c71} -> ghi 

14:32:40.424 [RxComputationThreadPool-7] INFO 

samples.RxMerge - Received: Tick #3 

{ae88eb02-52a5-4af7-b9cf-54b29b9cdb85} -> jkl 

In real-world scenarios, zip() be useful for gathering data from other parties, such a services, 

and then produce a result base on what be received. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

46 

//reactive program / 

Implementing Reactive Systems with Reactive Programming 

While reactive program let you compose asynchronous and event-driven applications, 

don’t lose sight of the overall goal. To successfully build responsive distribute system in 

a world of cloud and containers, embrace the asynchronous execution model be essential. 

Reactive program address the asynchronous development model, but you still need a 

task-based concurrency model and nonblocking I/O. Eclipse Vert.x provide these two miss 

piece a well a RxJava-friendly APIs. 

The Vert.x execution model be base on the concept of an event loop. An event loop be a 

thread consume event from a queue. For each event, it look for a handler interested in the 

event and call it. Handlers be method that receive an event a a parameter. In this model, 

your code can be single-threaded while handle lot of concurrent and entangle tasks. 

However, this approach come with some drawbacks. The execute handler must never block 

the event loop: if they do, the system loses it responsiveness and the number of unprocessed 

event in the queue rises. 

Fortunately, Vert.x come with a large ecosystem for implement almost anything in an 

asynchronous and nonblocking way. For instance, Vert.x provide building block for building 

modern web applications, access databases, and interact with legacy systems. Let’s look 

at a few examples. The Vert.x “hello world” application (code available online) be the following: 

package samples; 

import io.vertx.core.Vertx; 

public class HttpApplication { 

public static void main(String[] args) { 

// 1 - Create a Vert.x instance 

Vertx vertx = Vertx.vertx(); 

// 2 - Create the HTTP server 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://github.com/jponge/oracle-javamag-vertx-rxjava/blob/master/vertx-samples/src/main/java/samples/HttpApplication.java 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

47 

//reactive program / 

vertx.createHttpServer() 

// 3 - Attach a request handler processing the request 

.requestHandler(req -> req.response() 

.end("Hello, request handle from " 

+ Thread.currentThread().getName())) 

// 4 - Start the server on the port 8080 

.listen(8080); 

} 

} 

For each incoming HTTP request (event), the request handler be called. Notice that the handler be 

always call by the same thread: the event loop thread. Now, if you want to call another service 

(using HTTP) in the request handler, you would do something like this: 

package samples; 

import io.vertx.core.Vertx; 

import io.vertx.ext.web.client.WebClient; 

public class TwitterFeedApplication { 

public static void main(String[] args) { 

Vertx vertx = Vertx.vertx(); 

// 1 - Create a Web client 

WebClient client = WebClient.create(vertx); 

vertx.createHttpServer() 

.requestHandler(req -> { 

// 2 - In the request handler, retrieve a Twitter feed 

client 

.getAbs("https://twitter.com/vertx_project") 

.send(res -> { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

48 

//reactive program / 

// 3 - Write the response base on the result 

if (res.failed()) { 

req.response().end("Cannot access " 

+ "the twitter feed: " 

+ res.cause().getMessage()); 

} else { 

req.response().end(res.result() 

.bodyAsString()); 

} 

}); 

}) 

.listen(8080); 

} 

} 

This example relies on the Vert.x nonblocking I/O, so the entire code run on the Vert.x event 

loop (in a single-thread manner). This do not prevent handle concurrent requests. It’s 

actually the opposite; a single thread handle all the requests. However, you can quickly see the 

issue: the code becomes diicult to understand because of the nest callbacks. This be where 

RxJava come into play. The previous code can be rewrite a follows: 

package samples; 

import io.vertx.reactivex.core.Vertx; 

import io.vertx.reactivex.core.http.HttpServer; 

import io.vertx.reactivex.ext.web.client.HttpResponse; 

import io.vertx.reactivex.ext.web.client.WebClient; 

public class RXTwitterFeedApplication { 

public static void main(String[] args) { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

49 

//reactive program / 

Vertx vertx = Vertx.vertx(); 

WebClient client = WebClient.create(vertx); 

HttpServer server = vertx.createHttpServer(); 

server 

// 1 - Transform the sequence of request into a stream 

.requestStream().toFlowable() 

// 2 - For each request, call the twitter API 

.flatMapCompletable(req -> 

client.getAbs("https://twitter.com/vertx_project") 

.rxSend() 

// 3 - Extract the body a string 

.map(HttpResponse::bodyAsString) 

// 4 - In case of a failure 

.onErrorReturn(t -> "Cannot access the twitter " + 

"feed: " + t.getMessage()) 

// 5 - Write the response 

.doOnSuccess(res -> req.response().end(res)) 

// 6 - Just transform the restul into a completable 

.toCompletable() 

) 

// 7 - Never forget to subscribe to a reactive type, 

// or nothing happens 

.subscribe(); 

server.listen(8080); 

} 

} 

By restructuring the code around the RxJava reactive types, you beneit from the RxJava 

operators. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

50 

//reactive program / 

Implementing a Reactive Edge Service 

Let’s look at another simple yet efective example. Suppose that you have three service ofering 

bids, and you want to ofer an edge service to select the best ofer at a point in time. Let these 

service ofer simple HTTP/JSON endpoints. Obviously in real-world scenarios, these service 

might fail temporarily, and their response time might greatly vary. 

We will simulate such a system by develop the following: 

■■ A bidding service, with artiicial delay and random error 
■■ An edge service to query service through HTTP 

By use RxJava, we can show how to combine request streams, deal with failures, and provide 

time-bound guarantee for return the best ofer. All verticles will be deployed within the 

same application a we be prototyping, but this do not result in any loss of generality. The 

complete code be available in the vertx-samples subproject. 

Instead of start the application use a main method, we be go to use verticles. A 

verticle be a chunk of code, generally a Java class, that be deployed and run by Vert.x. Verticles 

be simple and scalable, and they use an actor-like deployment and concurrency model. They 

let you organize your code into a set of loosely couple components. By default, verticles be 

execute by the event loop and observe diferent type of event (HTTP requests, TCP frames, 

messages, and so on). When the application starts, it instructs Vert.x to deploy a set of verticles. 

Bidding service verticle. The verticle be design with the HTTP port be conigurable, 

a follows: 

public class BiddingServiceVerticle extends AbstractVerticle { 

private final Logger logger = 

LoggerFactory.getLogger(BiddingServiceVerticle.class); 

@Override 

public void start(Future<Void> verticleStartFuture) throw Exception { 

Random random = new Random(); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://github.com/jponge/oracle-javamag-vertx-rxjava/tree/master/vertx-samples 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

51 

//reactive program / 

String myId = UUID.randomUUID().toString(); 

int portNumber = config().getInteger("port", 3000); 

// (...) 

} 

} 

The config() method provide access to a verticle coniguration, and accessor method such a 

getInteger support a default value a a second argument. So here, the default HTTP port be 3000. 

The service have a random UUID to identify it endpoint in responses, and it make use of a ran- 

dom number generator. 

The next step be to use the Vert.x web router to accept HTTP GET request on path /offer: 

Router router = Router.router(vertx); 

router.get("/offer").handler(context -> { 

String clientIdHeader = context.request() 

.getHeader("Client-Request-Id"); 

String clientId = 

(clientIdHeader != null) ? clientIdHeader : "N/A"; 

int myBid = 10 + random.nextInt(20); 

JsonObject payload = new JsonObject() 

.put("origin", myId) 

.put("bid", myBid); 

if (clientIdHeader != null) { 

payload.put("clientRequestId", clientId); 

} 

long artificialDelay = random.nextInt(1000); 

vertx.setTimer(artificialDelay, id -> { 

if (random.nextInt(20) == 1) { 

context.response() 

.setStatusCode(500) 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

52 

//reactive program / 

.end(); 

logger.error("{} injects an error (client-id={}, " 

+ "artificialDelay={})", 

myId, myBid, clientId, artificialDelay); 

} else { 

context.response() 

.putHeader("Content-Type", 

"application/json") 

.end(payload.encode()); 

logger.info("{} offer {} (client-id={}, " + 

"artificialDelay={})", 

myId, myBid, clientId, artificialDelay); 

} 

}); 

}); 

Note that to simulate failures, we built in a 5 percent chance of failure (in which case, the ser- 

vice issue an HTTP 500 response) and the inal HTTP response be delayed by use a random 

timer between 0 and 1,000 milliseconds. 

Finally, the HTTP server be start a usual: 

vertx.createHttpServer() 

.requestHandler(router::accept) 

.listen(portNumber, ar -> { 

if (ar.succeeded()) { 

logger.info("Bidding service listen on HTTP " + 

"port {}", portNumber); 

verticleStartFuture.complete(); 

} else { 

logger.error("Bidding service fail to start", 

ar.cause()); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

53 

//reactive program / 

verticleStartFuture.fail(ar.cause()); 

} 

}); 

Edge service: select the best ofer. This service be implement use the RxJava API pro- 

vided by Vert.x. Here be the preamble and the start method of the verticle class: 

public class BestOfferServiceVerticle extends AbstractVerticle { 

private static final JsonArray DEFAULT_TARGETS = new JsonArray() 

.add(new JsonObject() 

.put("host", "localhost") 

.put("port", 3000) 

.put("path", "/offer")) 

.add(new JsonObject() 

.put("host", "localhost") 

.put("port", 3001) 

.put("path", "/offer")) 

.add(new JsonObject() 

.put("host", "localhost") 

.put("port", 3002) 

.put("path", "/offer")); 

private final Logger logger = LoggerFactory 

.getLogger(BestOfferServiceVerticle.class); 

private List<JsonObject> targets; 

private WebClient webClient; 

@Override 

public void start(Future<Void> startFuture) throw Exception { 

webClient = WebClient.create(vertx); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

54 

//reactive program / 

target = config().getJsonArray("targets", 

DEFAULT_TARGETS) 

.stream() 

.map(JsonObject.class::cast) 

.collect(Collectors.toList()); 

vertx.createHttpServer() 

.requestHandler(this::findBestOffer) 

.rxListen(8080) 

.subscribe((server, error) -> { 

if (error != null) { 

logger.error("Could not start the best offer " + 

"service", error); 

startFuture.fail(error); 

} else { 

logger.info("The best offer service be run " + 

"on port 8080"); 

startFuture.complete(); 

} 

}); 

} 

There be several interest point in this code: 

■■ To access the RxJava API ofered by Vert.x, we import and extend the 

io.vertx.reactivex.core.AbstractVerticle class. 

■■ It be possible to specify the target services, with the default be on the local host and 

port 3000, 3001, and 3002. Such coniguration can be pass a a JSON array contain JSON 

object with host, port, and path keys. 

■■ Variants of the Vert.x APIs that return RxJava object be preixed with “rx”: here rxListen 

return a Single<HttpServer>. The server be not actually start until we subscribe. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

55 

//reactive program / 

We can now focus on the implementation of the findBestOffer method. It irst issue HTTP 

request to each service, obtain a list of Single<JsonObject> responses, and then it reduces 

them to the single, best response and eventually end the HTTP response: 

private final AtomicLong requestIds = new AtomicLong(); 

private static final JsonObject EMPTY_RESPONSE = new JsonObject() 

.put("empty", true) 

.put("bid", Integer.MAX_VALUE); 

private void findBestOffer(HttpServerRequest request) { 

String requestId = String.valueOf(requestIds.getAndIncrement()); 

List<Single<JsonObject>> response = targets.stream() 

.map(t -> webClient 

.get(t.getInteger("port"), 

t.getString("host"), 

t.getString("path")) 

.putHeader("Client-Request-Id", 

String.valueOf(requestId)) 

.as(BodyCodec.jsonObject()) 

.rxSend() 

.retry(1) 

.timeout(500, TimeUnit.MILLISECONDS, 

RxHelper.scheduler(vertx)) 

.map(HttpResponse::body) 

.map(body -> { 

logger.info("#{} receive offer {}", requestId, 

body.encodePrettily()); 

return body; 

}) 

.onErrorReturnItem(EMPTY_RESPONSE)) 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

56 

//reactive program / 

.collect(Collectors.toList()); 

Single.merge(responses) 

.reduce((acc, next) -> { 

if (next.containsKey("bid") && isHigher(acc, next)) { 

return next; 

} 

return acc; 

}) 

.flatMapSingle(best -> { 

if (!best.containsKey("empty")) { 

return Single.just(best); 

} else { 

return Single.error(new Exception("No offer " + 

"could be found for requestId=" + requestId)); 

} 

}) 

.subscribe(best -> { 

logger.info("#{} best offer: {}", requestId, 

best.encodePrettily()); 

request.response() 

.putHeader("Content-Type", 

"application/json") 

.end(best.encode()); 

}, error -> { 

logger.error("#{} end in error", requestId, error); 

request.response() 

.setStatusCode(502) 

.end(); 

}); 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

57 

//reactive program / 

It be interest to note the follow for each HTTP request: 

■■ The response be convert to a JsonObject use the as() method. 

■■ A retry be attempt if the service issue an error. 
■■ The processing time out after 500 millisecond before return an empty response, which be 

how we avoid wait for all response and error to arrive. 

Note that all RxJava operation that expect a scheduler can use RxHelper::scheduler to ensure 

that all event remain process on Vert.x event loops. 

The whole processing be just a matter of compose functional idiom such a map, flatMap, 

and reduce and handle error with a default value. If no service can deliver a bid within 500 

milliseconds, no ofer be be made, result in an HTTP 502 error. Otherwise, the best ofer 

be select among the response received. 

Deploying verticles and interact with the services. The main verticle code be a follows: 

public class MainVerticle extends AbstractVerticle { 

@Override 

public void start() { 

vertx.deployVerticle(new BiddingServiceVerticle()); 

vertx.deployVerticle(new BiddingServiceVerticle(), 

new DeploymentOptions().setConfig( 

new JsonObject().put("port", 3001))); 

vertx.deployVerticle(new BiddingServiceVerticle(), 

new DeploymentOptions().setConfig( 

new JsonObject().put("port", 3002))); 

vertx.deployVerticle("samples.BestOfferServiceVerticle", 

new DeploymentOptions().setInstances(2)); 

} 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

58 

//reactive program / 

We deploy the bidding service three time on diferent port to simulate three services, pass- 

ing the HTTP port those service should listen on in the JSON coniguration. We also deploy 

the edge service verticle with two instance to process the incoming traic on two CPU core 

rather than one. The two instance will listen on the same HTTP port, but note that there will 

be no conlict because Vert.x distributes the traic in a round-robin fashion. 

We can now interact with the HTTP services, for instance, by use the HTTPie command- 

line tool. Let’s talk to the service on port 3000: 

$ http GET localhost:3000/offer 'Client-Request-Id:1234' --verbose 

GET /offer HTTP/1.1 

Accept: */* 

Accept-Encoding: gzip, deflate 

Client-Request-Id: 1234 

Connection: keep-alive 

Host: localhost:3000 

User-Agent: HTTPie/0.9.9 

HTTP/1.1 200 OK 

Content-Length: 83 

Content-Type: application/json 

{ 

"bid": 21, 

"clientRequestId": "1234", 

"origin": "fe299565-34be-4a7b-ac09-d88fcc1e42e2" 

} 

The log reveal both artiicial delay and errors: 

[INFO] 16:08:03.443 [vert.x-eventloop-thread-1] ERROR 

samples.BiddingServiceVerticle - 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

59 

//reactive program / 

6358300b-3f2d-40be-93db-789f0f1cde17 injects an error ( 

client-id=1234, artificialDelay=N/A) 

[INFO] 16:11:10.644 [vert.x-eventloop-thread-1] 

INFO samples.BiddingServiceVerticle - 

6358300b-3f2d-40be-93db-789f0f1cde17 offer 10 ( 

client-id=1234, artificialDelay=934) 

Similarly, you can play with the edge service, observe responses, and check the log to see how 

a response be be assembled. Sometimes you will get an error: 

$ http GET localhost:8080 'Client-Request-Id:1234' 

HTTP/1.1 502 Bad Gateway 

Content-Length: 0 

This be because all response take longer than 500 millisecond to arrive and some service 

inject an error: 

[INFO] 16:12:51.869 [vert.x-eventloop-thread-2] 

INFO samples.BiddingServiceVerticle - 

d803c4dd-1e9e-4f76-9029-770366e82615 offer 16 ( 

client-id=0, artificialDelay=656) 

[INFO] 16:12:51.935 [vert.x-eventloop-thread-1] 

INFO samples.BiddingServiceVerticle - 

6358300b-3f2d-40be-93db-789f0f1cde17 offer 17 ( 

client-id=0, artificialDelay=724) 

[INFO] 16:12:52.006 [vert.x-eventloop-thread-3] 

INFO samples.BiddingServiceVerticle - 

966e8334-4543-463e-8348-c6ead441c7da offer 14 ( 

client-id=0, artificialDelay=792) 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

60 

//reactive program / 

Sometimes you will observe that only one or two response have be take into account. 

The key point in this sample be that the combination of Vert.x and RxJava ofers a declara- 

tive and functional model for describe how to perform and process a lexible number of net- 

work request while remain purely driven by asynchronous events. 

Conclusion 

In this article, you have see how Eclipse Vert.x combine reactive program and the asyn- 

chronous execution model to build reactive systems. Reactive program let you compose 

asynchronous and event-driven application by manipulate and combine data streams. 

Modern reactive program library such a RxJava implement reactive stream to handle 

back-pressure. However, a reactive approach be not limited to reactive programming. Don’t 

lose sight that you want to build good system that be responsive, robust, and interactive. By 

use the execution model and nonblocking I/O capability promote by Vert.x, you be on the 

path to become truly reactive. 

This article just scratch the surface. Vert.x give you signiicant power and agility to 

create compelling, scalable, twenty-irst-century application the way you want to. Whether 

it’s simple network utilities, sophisticated modern web applications, HTTP/REST microservices, 

high-volume event processing, or a full-blown back-end message-bus application, Vert.x be a 

great it. </article> 

Clement Escoier (@clementplop) be a principal software engineer at Red Hat, where he be work a a 

Vert.x core developer. He have be involve in project and product touch many domain and technology 

such a OSGi, mobile app development, continuous delivery, and DevOps. Escoier be an active contributor to 

many open source projects, include Apache Felix, iPOJO, Wisdom Framework, and Eclipse Vert.x. 

Julien Ponge (@jponge) be an associate professor at INSA Lyon and a researcher at the CITI-INRIA laboratory. 

He be a longtime open source developer, have create IzPack and the Golo program language, and be now 

a member of the Eclipse Vert.x team. Ponge be currently on leave from INSA and work a a delegate con- 

sultant to Red Hat on the Vert.x project. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

61 

//reactive program / 

R eactive program be an approach to write software that embrace asynchronous I/O. Asynchronous I/O be a small idea that portends big change for software. The idea be simple: 
alleviate ineicient resource utilization by use resource that would otherwise sit idle a they 

wait for I/O activity. Asynchronous I/O inverts the normal design of I/O processing: client be 

notiied of new data instead of ask for it. This approach free the client to do other thing 

while wait for new notiications. 

There is, of course, always the risk that too many notiications will overwhelm a client; so, a 

client must be able to push back, reject work it can’t handle. This be a fundamental aspect of 

low control in distribute systems. In reactive programming, the ability of the client to signal 

how much work it can manage be call back-pressure. 

Many projects, such a Akka Streams, Vert.x, and RxJava, support reactive programming. 

[Vert.x and RxJava be examine in detail in the accompany article, “Going Reactive with 

Eclipse Vert.x and RxJava,” on page 32. —Ed.] The Spring team have a project call Reactor, 

which provide reactive capability for the Spring Framework. There’s common ground across 

these diferent approaches, which have be summarize in the Reactive Streams initiative—an 

informal standard of sorts. 

The Fundamental Data Types 

The Reactive Streams initiative deines four data types. Publisher be a producer of value that 

might eventually arrive. A Publisher produce value of type T, a show in Listing 1. 

Reactive Spring 
Proceeding from fundamentals, use the Spring Framework to quickly build 

a reactive application. 

JOSH LONG 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://www.reactive-streams.org/ 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

62 

//reactive program / 

Listing 1: The Reactive Streams Publisher<T> 

package org.reactivestreams; 

public interface Publisher<T> { 

void subscribe(Subscriber<? Super T> s); 

} 

A Subscriber subscribes to a Publisher, receive notiications on any new value of type T, a 

show in Listing 2. 

Listing 2: The Reactive Streams Subscriber 

package org.reactivestreams; 



public interface Subscriber<T> { 

public void onSubscribe(Subscription s); 

public void onNext(T t); 

public void onError(Throwable t); 

public void onComplete(); 

} 

When a Subscriber subscribes to a Publisher, it result in a Subscription, a show in Listing 3. 

Listing 3: The Reactive Streams Subscription 

package org.reactivestreams; 



public interface Subscription { 

public void request(long n); 

public void cancel(); 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

63 

//reactive program / 

A Publisher that be also a Subscriber be call a Processor, which be show in Listing 4. 

Listing 4: The Reactive Streams Processor 

package org.reactivestreams; 

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { 

} 

The speciication be not meant to be a prescription for the implementations; instead, it deines 

type for interoperability. The Reactive Streams type eventually found their way into Java 9 a 

one-to-one semantically equivalent interface in the java.util.concurrent.Flow class. 

Reactor 

The Reactive Streams type be not enough; you’ll need higher-order implementation to sup- 

port operator such a iltering and transformation. Pivotal’s Reactor project be a good choice 

here; it build on top of the Reactive Streams speciication. It provide two specialization of 

Publisher<T>. The irst, Flux, be a Publisher that produce zero or more values. It’s unbounded. 

The second, Mono<T>, be a Publisher that produce one or zero values. They’re both publisher and 

you can treat them that way, but they go much further than the Reactive Streams speciication. 

They both provide way to process a stream of values. Reactor type compose nicely: the output 

of one thing can be the input to another. 

Reactive Spring 

As useful a project Reactor is, it’s only a foundation. Applications need to talk to data sources. 

They need to produce and consume HTTP, Server-Sent Events (SSE), or WebSocket endpoints. 

They support authentication and authorization. Spring Framework 5.0 provide these things. It 

be release in September 2017 and build on Reactor and the Reactive Streams speciication. It 

include a new reactive runtime and component model call Spring WebFlux. Spring WebFlux 

do not depend on or require the Servlet APIs to work. It ship with adapter that allow it to 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

64 

//reactive program / 

work on top of a servlet engine, if need be, but that be not required. It also provide a Netty- 

base web server. Spring Framework 5, which work with a baseline of Java 8 and Java EE 7, be 

the foundation for change in much of the Spring ecosystem. Let’s look at an example. 

Example Application 

Let’s build a simple Spring Boot 2.0 application that represent a service to manage books. You 

could call the project Library or something like that. Go to the Spring Initializr. Make sure that 

some version of Spring Boot 2.0 (or later) be select in the version drop-down menu. You’re 

write a service to manage access to book in the library, so give this project the artifact ID 

library-service. Select the element you’ll need: Reactive Web, Actuator, Reactive MongoDB, 

Reactive Security, and Lombok. 

I often use the Kotlin language, even if most of the project I be building be in Java. I keep 

Java artifact collocate in a Kotlin project. Click Generate and it’ll download an archive. Unzip 

it and open it in your favorite IDE that support Java 8 (or later), Kotlin (optionally), and Maven. 

While you could have chosen Gradle in the Spring Initializr, I chose Maven for the purpose 

of this article. The stock standard Spring Boot application have an entry class that look like 

Listing 5. 

Listing 5: The empty husk of a new Spring Boot project 

package com.example.libraryservice; 

import org.springframework.boot.SpringApplication; 

import org.springframework.boot.autoconfigure.SpringBootApplication; 

@SpringBootApplication public class LibraryServiceApplication { 

public static void main(String[] args) { 

System.setProperty("spring.profiles.active", 

"security,authorization,frpjava"); 

SpringApplication.run(LibraryServiceApplication.class, args); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
http://start.spring.io/ 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

65 

//reactive program / 

} 

} 

Data Access with Reactive Spring Data Modules 

The most recent release of Spring Data debut support for reactive data access when that be sup- 

port in the underlie datastores (such a MongoDB, Cassandra, Redis, and Couchbase). The 

release also introduces new reactive repository and template implementations. Because you 

have the reactive MongoDB driver and Spring Data module on the classpath, let’s use them to 

manage some data. Create a new entity call Book, a show in Listing 6. 

Listing 6: A MongoDB @Document entity, Book 

package com.example.libraryservice; 

import lombok.AllArgsConstructor; 

import lombok.Data; 

import lombok.NoArgsConstructor; 

import org.springframework.data.annotation.Id; 

import org.springframework.data.mongodb.core.mapping.Document; 

@Document 

@Data 

@AllArgsConstructor 

@NoArgsConstructor 

public class Book { 

@Id 

private String id; 

private String title; 

private String author; 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

66 

//reactive program / 

Next, create a Spring Data repository to support the data management lifecycle of the entity. 

This should look very familiar to anyone who have ever use Spring Data, except that the reposi- 

tory support reactive interactions: method return Publisher types, and input can be give a 

Publisher instances. See Listing 7. 

Listing 7: A reactive Spring Data MongoDB repository 

package com.example.libraryservice; 

import org.springframework.data.mongodb.repository.ReactiveMongoRepository; 

import reactor.core.publisher.Flux; 

public interface BookRepository extends ReactiveMongoRepository { 

Flux findByAuthor(String author); 

} 

Install Some Sample Data 

With that, you now have enough to install some sample data (just for your demo). Spring 

Boot invokes the #run(ApplicationArguments) method when the application have started, 

passing wrapper for the argument (String [] args) into the application. Let’s create an 

ApplicationRunner that deletes all the data in the data source, then emits a few book titles, then 

map them to Book entities, and then persists those books. Finally, it query all the record in 

the data source and then print out everything. Listing 8 show all this. 

Listing 8: An ApplicationRunner to write data 

package com.example.libraryservice; 

import lombok.extern.slf4j.Slf4j; 

import org.springframework.boot.ApplicationArguments; 

import org.springframework.boot.ApplicationRunner; 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

67 

//reactive program / 

import org.springframework.stereotype.Component; 

import reactor.core.publisher.Flux; 

@Slf4j 

@Component 

class SampleBookInitializer implement ApplicationRunner { 

private final BookRepository bookRepository; 

SampleBookInitializer(BookRepository bookRepository) { 

this.bookRepository = bookRepository; 

} 

@Override 

public void run(ApplicationArguments args) throw Exception { 

this.bookRepository 

.deleteAll() 

.thenMany( 

Flux.just( 

"Cloud Native Java|jlong", 

"Spring Security 3.1|rwinch", 

"Spring in Action|cwalls")) 

.map(t -> t.split("\\|")) 

.map(tuple -> new Book(null, tuple[0], tuple[1])) 

.flatMap(this.bookRepository::save) 

.thenMany(this.bookRepository.findAll()) 

.subscribe(book -> log.info(book.toString())); 

} 

} 

The example look at the title of various book and one of the (possibly numerous) books’ 

authors, and then it writes them to the database. First the string be split by the | delimiter. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

68 

//reactive program / 

Then the title and book author be use to create a Book. Then the record be save to the data 

source, MongoDB. The result of the save operation be a Mono<Book>. Something need to sub- 

scribe to each of those result Publisher<T> instances, so I use the flatMap operator. Then, I 

turn my focus to the result of inding all record and then to log them for inspection. 

This code deines a pipeline; each operator deines a stage in a pipeline. The pipeline be not 

eager; that is, it won’t be execute until it be activated. You activate the pipeline by subscribe 

to it (the last step in the code in Listing 8). Publisher deines only one type of subscription, but 

Reactor provide hook to process each emit value, a well a any exception thrown, among 

other things. 

Were you to put a breakpoint in any of the lambda in Listing 8 and then inspect 

Thread.currentThread().getName(), you’d see that the thread on which processing be run- 

ning be diferent than the main thread (which be name main). Reactor defers to a Scheduler 

implementation for it processing. You can specify the default global Scheduler you’d like to 

use by call Schedulers.setFactory(Factory). You can specify on which thread a particu- 

lar Publisher should run when it subscribes by specify Mono::subscribeOn(Scheduler) or 

Flux::subscribeOn(Scheduler). 

Conclusion 

You have now use Spring Boot and Spring Initializr to quickly create and run a reactive data 

application that hews closely to the requirement of reactive development. In the second (and 

inal) part of this article, I’ll use Spring Framework 5.0 to stand up a REST API and to implement 

secure access to this data. Meanwhile, if you want to look at the complete application, the source 

code be all online. </article> 

Josh Long (@starbuxman) be a Java Champion and a Spring developer advocate at Pivotal. He be the author of 

several book on Spring programming, and he speaks frequently at developer conferences. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://github.com/joshlong/reactive-spring-article 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

69 

//beyond CRUD / 

Most of today’s enterprise application be base on a CRUD data model that be simple and straightforward to implement. Event sourcing, event-driven architectures, and Command 
Query Responsibility Segregation (CQRS) ofer another way to model application that enables 

interest solution and use cases, especially with the rise demand of scalability. Before 

get into CQRS, I’ll quickly describe some of the limitation of the CRUD model. 

Shortcomings of CRUD-Based Applications 

A CRUD-based application always contains the current state of the system. The domain entity 

be store in the database or in an in-memory representation with their property a they be 

at any give moment. That aspect come in handy when user read the current state, but it fall 

short in other aspects. 

For example, a model that be solely CRUD-based have no information about the history or 

the context—why the system, include all domain objects, be in it current state and how it get 

there. Once an update be performed, the object be then in a new state and their old state be 

forgotten. This can make it tricky to reproduce and debug situation in production. It’s harder to 

comprehend the current state and ind potential bug if the whole history be not available. 

Another challenge of CRUD-based model be that due to store only the current state, all 

transaction and interaction need to modify the system in a consistent way. This sound nor- 

mal to enterprise developer but can become quite complex when you be deal with compet- 

ing transactions—for example, when user want to update their contact information and at the 

Command Query Responsibility 
Segregation with Java 
Combining event source and event-driven architecture to build scalable, 

eventually consistent system 

SEBASTIAN DASCHNER 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

70 

//beyond CRUD / 

same time some other use case update their 

account balance. If this information afects the 

same database entries, the two activity lead 

to a lock situation. Usually, this optimis- 

tic lock result in one transaction win 

over the other. However, strictly speaking, 

there should be no need to mutually exclude 

either transaction. 

A similar problem occurs when a use case update business object whose new state 

require veriication to keep the system in a consistent state. Verifying and maintain these 

consistent state can become both redundant and complex. 

Because CRUD-based application need to store the status quo and keep a consistent state 

within their data model, they cannot scale horizontally. To maintain consistency, such applica- 

tions need to lock the data (as in good old atomicity, consistency, isolation, and durability [ACID] 

transactions) until the update have take place. If several distribute system be involved, the 

synchronization will become a bottleneck. 

Event Sourcing 

In contrast to a CRUD data model, event-sourced system store all modiications that happen to 

a system a atomic entities. The application do not necessarily contain the current state, but 

it can be calculate by apply all event that have happen in the past. These event be the 

single source of truth in the system. 

The most prominent example for this model be bank accounts. You can calculate your cur- 

rent balance by start at zero and add or subtract the amount of all transaction 

accordingly. The example in Figure 1 show a simple set of customer-related event that can be 

use to arrive at a customer representation. 

The event be atomic and immutable, because they happen in the past and cannot be 

undone. This implies that, for example, a deletion action also change the current state by just 

add a CustomerDeleted event to the log—no entry be actually deleted. 

Because the real world be all about 
distribute collaboration—often in an 
asynchronous way—it make sense to model 
application in an event-driven way. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

71 

//beyond CRUD / 

While the current state could be calculate on demand use all event that have happen 

in the past, enterprise system use so-called snapshot that represent the state a of a certain 

moment in time. Events that arose after that moment be then apply to the snapshot in order 

to form a new state, which again can be persisted. This is, however, an optimization technique 

to deal with a grow number of events—the atomic event remain the golden source of truth. 

One of the beneits of this architecture be that the full history of what have happen 

enables developer to reproduce complex use-case scenario and debug the system with ease. 

Another advantage of event-sourced system be the possibility of calculate statistic and 

implement future use case later. Because all atomic information that ever be apply to 

the system be available, you can use this information and simply redeploy the application with 

update behavior and recalculate the status from the events. That make it possible to imple- 

ment future use case on event that happen in the past—as if that new functionality be 

always there. For example, answer the question, “How many user sign up on a Tuesday?” 

be possible use the information contain in the event even if this functionality wasn’t 

consider previously. 

Figure 1. Events that determine the current state of a customer entry 

John_Doe_123 : Customer 

CustomerCreated 

CustomerAddressChanged 

CustomerAccountVerified 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

72 

//beyond CRUD / 

Event source alone doesn’t imply that the application have to be implement use an 

event-driven or CQRS approach. However, in order to apply CQRS, you need to model applica- 

tions with event sourcing. 

Event-Driven Applications 

In contrast to the beneits of an event-sourced system, the motivation behind event-driven 

application difer. If you want to model distribute systems—such a microservices—that aim 

to maintain a consistent state throughout several systems, you need to take transaction into 

account. Because distribute transaction don’t scale well, you split up a transaction into several 

transaction that still maintain consistency—at least in an eventually consistent way. 

An event-driven architecture (see Figure 2) realizes use case that involve multiple system 

by collaborate via command and events. For order a cup of cofee at a café, for example, 

you would irst attempt to place an order, which result in an OrderPlaced event—or an error. 

Figure 2. Example event-driven architecture 

Order_123 : Order 

Co�ee order system Bean storage system 

validateOrder() 

OrderAccepted 

placeOrder() 

OrderPlaced 

completeOrder() 

OrderCompleted 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

73 

//beyond CRUD / 

This OrderPlaced event then cause the cofee bean storage to check whether there be bean 

available and to publish either an OrderAccepted event or an OrderFailedInsufficientBeans 

event. The current state of the order be calculate by apply all event related to that order a 

in an event-sourced system. 

This way of model cause the process to be eventually consistent, and because the appli- 

cation ensures that all event be publish in a reliable way, the inal outcome of the use case 

will be consistent. 

If you compare this way of model to the real world, you can see that these method of 

collaboration be common. When you order a cup of cofee, the waiter accepts your order—even 

though it’s possible that for some reason the 

cofee will never make it to you. In that case, 

the waiter will come back late and apologize 

for not be able to deliver the cofee and 

will ofer a compensate transaction—even 

though the order be accepted in the irst 

place. Eventually, you will end up with your 

cofee, another drink, or your money back. 

Because the real world be all about distribute collaboration—often in an asynchronous 

way—it make sense to model application in an event-driven way. 

Enter CQRS 

Now that I’ve summarize implement event-driven and event-sourced applications, I will 

introduce the CQRS principle, which prescribes separate the responsibility of read and 

writes. CQRS cause method to either modify the state of the system without return any 

value or to return value without any side efect. The command (that is, the writes) be not 

suppose to return values; they either return successfully or throw an error. The query (that is, 

the reads) only return data (see Figure 3). 

This principle be simple in theory but have important implications. Once you split up a sys- 

tem follow this approach, the application collaborate only by event that be publish to 

One of the benefit of separate the 
responsibility of read and writes in 
the CQRS model be the fact that the query and 
command side can scale independently. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

74 

//beyond CRUD / 

an event store. The command and query component maintain their own domain object rep- 

resentations by consume the event from the hub and update the state of their internal 

model. The storage representation of each side can difer and be optimize accord to their 

best it. 

When an update command, placeOrder(Order), reach the command side, the service per- 

form the action use the domain object representation in it internal storage and publishes 

event (OrderPlaced). When the client read at the query side, this service return the current 

state from it internal storage. The service be couple only by the event store and can operate 

and be deployed independently from each other. 

The event that be publish from the event store be consume by all subscribed consum- 

Figure 3. Example of a CQRS implementation 

EventStore 

OrderPlaced 

CommandService 

void placeOrder() Co 
eeOrder getOrder() 

QueryService DBDB 

OrderPlaced 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

75 

//beyond CRUD / 

er to update their internal model—but only one subscriber, EventHandler, be suppose to trigger 

further command from these events. Publishing the event have to happen in a reliable way to 

keep the system in a consistent state in the long run. 

Benefits of CQRS 

One of the beneits of separate the responsibility of read and writes in the CQRS model be 

the fact that the query and command side can scale independently. In typical enterprise appli- 

cations, the read operation outnumber the write operations. Because be eventually consis- 

tent on the read side is, in most cases, not a big problem, return replicate data have a positive 

impact on the overall performance. Using CQRS enables you to deploy, for example, a great 

number of query service instance to scale out just the read side. 

The domain model representation of each of the service solve the problem of the rise 

number of event in an event-sourced system. Because more and more event be store in the 

system over time, the overall performance of operation would decrease if the application state 

be solely calculate on demand by apply all event each time. Updating the representation 

continuously and use these model in the command and query maintains a constant level 

of performance. This corresponds to the concept of snapshots. 

Another beneit of this separation be the give failover capacity—at least for the read side. 

Because all instance maintain an eventually consistent representation of the system’s state, 

this cached state be still available if the event store go down. Even though no new event can 

be written, the client can still access the last state. 

Applications that implement CQRS also have the capability to implement further use case 

that operate on event from the past, because they implement event source a well. 

Now, I will show an actual CQRS implementation in a Java EE application. 

Example CQRS Application 

As an example, I’m use a scalable cofee shop that consists of three services, responsible for 

order management (orders), bean storage (beans), and cofee brewing (barista). Each service be 

free to choose it internal domain object representation, and the collaboration be do use 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

76 

//beyond CRUD / 

Apache Kafka a the event hub. Once event be publish to Kafka, the service handle the 

event accordingly and update their representation. 

The business use case for order a cup of cofee be show in Figure 4. 

When a client creates an order, the command service publishes an event (OrderPlaced) and 

return the request successfully—even though the system can’t tell yet whether the order will 

be inished successfully. The client can request the status of the order from the query service 

Figure 4. Use case for order a cup of cofee 

OrderDelivered 

deliverOrder() 

finishOrder() 

OrderFinished 

OrderStarted 

startOrder() 

OrderAccepted 

acceptOrder() 

OrderPlaced 

orderCo�ee() 

Co�ee order system Bean storage system Barista system 

validateBeans() 

OrderBeansValidated 

fetchBeans() 

makeCo�ee() 

Co�eeBrewStarted() 

Co�eeBrewFinished 

Co�eeDelivered 

BeansFetched 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

77 

//beyond CRUD / 

anytime, with the state be update on incoming events. 

Application Architecture 

The Java EE application be organize with the Entity Control Boundary (ECB) pattern. The appli- 

cation boundary contains the external REST interface, a *CommandService and *QueryService, and 

the event handle functionality that will call subsequent commands. The control package 

contain the storage representation that contain the current domain object representations, 

a well a functionality to access Kafka. The entity package consist of the event and domain 

object deinitions. 

The command service contains the business method and publishes event at the event 

hub. The query service access the storage only to return data. 

The follow code show example for the order command service, which process the 

command by publishing the event to the event hub. This service be the use-case entry point 

from both the application boundary and the event handler. 

public class OrderCommandService { 

@Inject 

EventProducer eventProducer; 

@Inject 

CoffeeOrders coffeeOrders; 

public void placeOrder(OrderInfo orderInfo) { 

eventProducer.publish(new OrderPlaced(orderInfo)); 

} 

void acceptOrder(UUID orderId) { 

OrderInfo orderInfo = coffeeOrders.get(orderId) 

.getOrderInfo(); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

78 

//beyond CRUD / 

eventProducer.publish(new OrderAccepted(orderInfo)); 

} 

void cancelOrder(UUID orderId, String reason) { 

eventProducer.publish( 

new OrderCancelled(orderId, reason)); 

} 

void startOrder(UUID orderId) { 

eventProducer.publish(new OrderStarted(orderId)); 

} 

void finishOrder(UUID orderId) { 

eventProducer.publish(new OrderFinished(orderId)); 

} 

void deliverOrder(UUID orderId) { 

eventProducer.publish(new OrderDelivered(orderId)); 

} 

} 

The order query service, show in the follow code, be use to retrieve the cofee order repre- 

sentations. It us the cofee order store, which keep track of the orders. 

public class OrderQueryService { 

@Inject 

CoffeeOrders coffeeOrders; 

public CoffeeOrder getOrder(UUID orderId) { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

79 

//beyond CRUD / 

return coffeeOrders.get(orderId); 

} 

} 

Incoming event be deliver a Contexts and Dependency Injection (CDI) event within the 

application. The store itself observes these CDI event and update and store the domain object 

representations. For simplicity, in the follow code, I’m use solely in-memory storage with 

the Kafka event be redelivered and reapplied at application startup. In a production envi- 

ronment, this functionality would likely be integrate with a persistent database that store the 

last calculate state. 

@Singleton 

@Startup 

@ConcurrencyManagement(ConcurrencyManagementType.BEAN) 

public class CoffeeOrders { 

private final Map<UUID, CoffeeOrder> coffeeOrders = 

new ConcurrentHashMap<>(); 

public CoffeeOrder get(UUID orderId) { 

return coffeeOrders.get(orderId); 

} 

public void apply(@Observes OrderPlaced event) { 

coffeeOrders.putIfAbsent(event.getOrderInfo() 

.getOrderId(), new CoffeeOrder()); 

applyFor(event.getOrderInfo().getOrderId(), 

o -> o.place(event.getOrderInfo())); 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

80 

//beyond CRUD / 

public void apply(@Observes OrderCancelled event) { 

applyFor(event.getOrderId(), CoffeeOrder::cancel); 

} 

public void apply(@Observes OrderAccepted event) { 

applyFor(event.getOrderInfo().getOrderId(), 

CoffeeOrder::accept); 

} 

public void apply(@Observes OrderStarted event) { 

applyFor(event.getOrderId(), CoffeeOrder::start); 

} 

public void apply(@Observes OrderFinished event) { 

applyFor(event.getOrderId(), CoffeeOrder::finish); 

} 

public void apply(@Observes OrderDelivered event) { 

applyFor(event.getOrderId(), CoffeeOrder::deliver); 

} 

private void applyFor(UUID orderId, 

Consumer<CoffeeOrder> consumer) { 

CoffeeOrder coffeeOrder = coffeeOrders.get(orderId); 

if (coffeeOrder != null) 

consumer.accept(coffeeOrder); 

} 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

81 

//beyond CRUD / 

For simplicity, both the query and command service be use the same CoffeeOrders instance. 

However, this could be split into several component or system and further optimize for 

each side accordingly. For my purpose—to show an example implementation—this model 

be suicient. 

The connection for incoming event that trigger subsequent command be do in the event 

handler. This handler call the command service for further processing of orders. It both con- 

sumes Kafka message and ire the correspond CDI events. 

@Singleton 

@Startup 

public class OrderEventHandler { 

private EventConsumer eventConsumer; 

@Resource 

ManagedExecutorService mes; 

@Inject 

Properties kafkaProperties; 

@Inject 

Event<CoffeeEvent> events; 

@Inject 

OrderCommandService orderService; 

@Inject 

Logger logger; 

public void handle(@Observes OrderBeansValidated event) { 

orderService.acceptOrder(event.getOrderId()); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

82 

//beyond CRUD / 

} 

public void handle(@Observes 

OrderFailedBeansNotAvailable event) { 

orderService.cancelOrder(event.getOrderId(), 

"No bean of the origin be available"); 

} 

public void handle(@Observes CoffeeBrewStarted event) { 

orderService.startOrder(event.getOrderInfo().getOrderId()); 

} 

public void handle(@Observes CoffeeBrewFinished event) { 

orderService.finishOrder(event.getOrderId()); 

} 

public void handle(@Observes CoffeeDelivered event) { 

orderService.deliverOrder(event.getOrderId()); 

} 

@PostConstruct 

private void initConsumer() { 

kafkaProperties.put("group.id", "order-handler"); 

eventConsumer = new EventConsumer(kafkaProperties, ev -> { 

logger.info("firing = " + ev); 

events.fire(ev); 

}, "barista", "beans"); 

mes.execute(eventConsumer); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

83 

//beyond CRUD / 

} 

@PreDestroy 

public void closeConsumer() { 

eventConsumer.stop(); 

} 

} 

Integrating Apache Kafka 

Apache Kafka serf a a reliable, persistent, and scalable event hub that delivers event to the 

service involved. I make use of event topic that be consume in so-called consumer groups. 

In this case, I conigure Kafka to deliver the event reliably once in every consumer group. By 

coniguring the same group for all event handlers, I ensure that only one instance process 

an event. 

The event producer, show in the follow code, publishes the event to Kafka: 

@ApplicationScoped 

public class EventProducer { 

private Producer<String, CoffeeEvent> producer; 

@Inject 

Properties kafkaProperties; 

@Inject 

Logger logger; 

@PostConstruct 

private void init() { 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

84 

//beyond CRUD / 

kafkaProperties.put("transactional.id", 

UUID.randomUUID().toString()); 

producer = new KafkaProducer<>(kafkaProperties); 

producer.initTransactions(); 

} 

public void publish(CoffeeEvent event) { 

ProducerRecord<String, CoffeeEvent> record = 

new ProducerRecord<>("order", event); 

try { 

producer.beginTransaction(); 

logger.info("publishing = " + record); 

producer.send(record); 

producer.commitTransaction(); 

} catch (ProducerFencedException e) { 

producer.close(); 

} catch (KafkaException e) { 

producer.abortTransaction(); 

} 

} 

@PreDestroy 

public void close() { 

producer.close(); 

} 

} 

The follow code us transactional producer that be introduce in Kafka version 0.11. 

They ensure that an event have be sent reliably before the client call returns. The event con- 

sumer ininitely consumes new Kafka event and pass them to a functional Consumer. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

85 

//beyond CRUD / 

public class EventConsumer implement Runnable { 

private KafkaConsumer<String, CoffeeEvent> consumer; 

private final Consumer<CoffeeEvent> eventConsumer; 

private final AtomicBoolean close = new AtomicBoolean(); 

public EventConsumer(Properties kafkaProperties, 

Consumer<CoffeeEvent> eventConsumer, 

String... topics) { 

this.eventConsumer = eventConsumer; 

consumer = new KafkaConsumer<>(kafkaProperties); 

consumer.subscribe(asList(topics)); 

} 

@Override 

public void run() { 

try { 

while (!closed.get()) { 

consume(); 

} 

} catch (WakeupException e) { 

// will wake up for closing 

} finally { 

consumer.close(); 

} 

} 

private void consume() { 

ConsumerRecords<String, CoffeeEvent> record = 

consumer.poll(Long.MAX_VALUE); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

86 

//beyond CRUD / 

for (ConsumerRecord<String, CoffeeEvent> record : records) { 

eventConsumer.accept(record.value()); 

} 

consumer.commitSync(); 

} 

public void stop() { 

closed.set(true); 

consumer.wakeup(); 

} 

} 

After an event have be processed, I commit to the consumption by call commitSync. This 

event consumer be start from both the event handler and the update consumer. Both be 

then responsible for iring the CDI events. See the OrderEventHandler deinition show early 

and the follow OrderUpdateConsumer: 

@Startup 

@Singleton 

public class OrderUpdateConsumer { 

private EventConsumer eventConsumer; 

@Resource 

ManagedExecutorService mes; 

@Inject 

Properties kafkaProperties; 

@Inject 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

87 

//beyond CRUD / 

Event<CoffeeEvent> events; 

@Inject 

Logger logger; 

@PostConstruct 

private void init() { 

kafkaProperties.put("group.id", "order-consumer-" + 

UUID.randomUUID()); 

eventConsumer = new EventConsumer(kafkaProperties, ev -> { 

logger.info("firing = " + ev); 

events.fire(ev); 

}, "order"); 

mes.execute(eventConsumer); 

} 

@PreDestroy 

public void close() { 

eventConsumer.stop(); 

} 

} 

To ensure that the consumer be manage correctly, I use Java EE’s manage executor service 

to run the consumer in thread manage by the application server. For the update consum- 

ers, unique group IDs be generate to ensure that every service get all events. 

When these service start, they connect to their correspond Kafka topic and ask for all 

the undelivered event in their consumer group. To update the domain object representation to 

the late state, the update consumer group that have the match ID applies the events—for 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

88 

//beyond CRUD / 

example, in the CoffeeOrders—that occur since the very beginning. As I mention before, 

I’m use only in-memory storage without persistent snapshots. For the full example applica- 

tion, see the scalable-cofee-shop project on GitHub. 

Conclusion 

CQRS provide a useful alternative to the traditional CRUD-based way of building enterprise 

application by combine the beneits of event source and event-driven architecture to 

build scalable, eventually consistent systems. 

Of course, this approach be no silver bullet. If the situation do not require the scalabil- 

ity of event-driven architectures, it’s advisable to go with monolithic, consistent application 

instead. CQRS introduces some overhead, which certainly be avoidable in most enterprise appli- 

cations. An application that solely require the beneits of event source can be base on this 

approach while still use a relational database and consistent use cases. </article> 

Sebastian Daschner (@DaschnerS) be a Java Champion who work a a consultant and trainer. He participates 

in the Java Community Process (JCP), serve in the JSR 370 and JSR 374 Expert Groups. Daschner be also a 

heavy user of Linux and container technology such a Docker. When not work with Java, he love to travel. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://github.com/sdaschner/scalable-coffee-shop 


Push a Button 
Move Your Java Apps 
to the Oracle Cloud 

…or Back to Your Data Center 

Same Java Runtime 

Same Dev Tools 

Same Standards 

Same Architecture 

http://cloud.oracle.com/java 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

90 

//new to java / 

In the occasional “New to Java” series, I try to pick topic that invite a deeper understand of the conceptual background of a language construct. Often, novice programmer have a work- 
ing knowledge of a concept—that is, they can use it in many situations, but they lack a deeper 

understand of the underlie principle that would lead to write good code, create bet- 

ter structures, and make good decision about when to use a give construct. Java interface 

be often just such a topic. 

In this article, I assume that you have a basic understand of inheritance. Java interface 

be closely related to inheritance, a be the extends and implement keywords. So, I will discus 

why Java have two diferent inheritance mechanism (indicated by these keywords), how abstract 

class it in, and what various task interface can be use for. 

As be so often the case, the story of these feature start with some quite simple and elegant 

idea that lead to the deinition of concept in early Java versions, and the story get more com- 

plicate a Java advance to tackle more-intricate, real-world problems. This challenge lead to 

the introduction of default method in Java 8, which muddy the water a bit. 

A Little Background on Inheritance 

Inheritance be straightforward to understand in principle: a class can be speciied a an exten- 

sion of another class. In such a case, the present class be call a subclass, and the class it’s 

extend be call the superclass. Objects of the subclass have all the property of both the 

superclass and the subclass. They have all ields deined in either subclass or superclass and 

also all method from both. So far, so good.PHOTOGRAPH BY JOHN BLYTHE 

The Evolving Nature 
of Java Interfaces 
Understanding multiple inheritance in Java 

MICHAEL KÖLLING 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

91 

//new to java / 

Inheritance is, however, the equivalent of the Swiss Army knife in programming: it can be 

use to achieve some very diverse goals. I can use inheritance to reuse some code I have writ- 

ten before, I can use it for subtyping and dynamic dispatch, I can use it to separate speciication 

from implementation, I can use it to specify a contract between diferent part of a system, and 

I can use it for a variety of other tasks. These be all important, but very diferent, ideas. It be 

necessary to understand these diferences to get a good feel for inheritance and interfaces. 

Type Inheritance Versus Code Inheritance 

Two main capability that inheritance provide be the ability to inherit code and the ability to 

inherit a type. It be useful to separate these two idea conceptually, especially because standard 

Java inheritance mix them together. In Java, every class I deine also deines a type: a soon a 

I have a class, I can create variable of that type, for example. 

When I create a subclass (using the extends keyword), the subclass inherits both the code 

and the type of the superclass. Inherited method be available to be call (I’ll refer to this a 

“the code”), and object of the subclass can be use in place where object of the superclass be 

expect (thus, the subclass creates a subtype). 

Let’s look at an example. If Student be a subclass of Person, then object of class Student have 

the type Student, but they also have the type Person. A student be a person. Both the code and 

the type be inherited. 

The decision to link type inheritance and code inheritance in Java be a language design 

choice: it be do because it be often useful, but it be not the only way a language can be 

designed. Other program language allow inherit the code without inherit the type 

(such a C++ private inheritance) or inherit the type without inherit the code (which Java 

also supports, a I explain shortly). 

Multiple Inheritance 

The next idea enter the mix be multiple inheritance: a class may have more than one super- 

class. Let me give you an example: PhD student at my university also work a instructors. In 

that sense, they be like faculty (they be instructor for a class, have a room number, a payroll 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

92 

//new to java / 

number, and so on). But they be also students: they be enrol in a course, have a student ID 

number, and so on. I can model this a multiple inheritance (see Figure 1). 

PhDStudent be a subclass of both Faculty and Student. This way, a PhD student will have the 

attribute of both student and faculty. Conceptually this be straightforward. In practice, how- 

ever, the language becomes more complicate if it allows multiple inheritance, because that 

introduces new problems: What if both superclass have ields with the same name? What if 

they have method with the same signature but diferent implementations? For these cases, 

I need language construct that specify some solution to the problem of ambiguity and name 

overloading. However, it get worse. 

Diamond Inheritance 

A more complicate scenario be know a diamond inheritance (see Figure 2). This be where a class 

(PhDStudent) have two superclass (Faculty and Student), which in turn have a common super- 

class (Person). The inheritance graph form a diamond shape. 

Now, consider this question: If there be a ield in the top-level superclass (Person, in this 

case), should the class at the bottom (PhDStudent) have one copy of this ield or two? It inherits 

Faculty Student 

PhDStudent 

Person 

Figure 2. An example of diamond inheritance 

Faculty Student 

PhDStudent 

Figure 1. An example of multiple inheritance 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

93 

//new to java / 

this ield twice, after all, once via each of it inheri- 

tance branches. 

The answer is: it depends. If the ield in question 

is, say, an ID number, maybe a PhD student should 

have two: a student ID and a faculty/payroll ID that 

might be a diferent number. If the ield is, however, 

the person’s family name, then you want only one 

(the PhD student have only one family name, even though it be inherit from both superclasses). 

In short, thing can become very messy. Languages that allow full multiple inheritance need 

to have rule and construct to deal with all these situations, and these rule be complicated. 

Type Inheritance to the Rescue 

When you think about these problem carefully, you realize that all the problem with multiple 

inheritance be related to inherit code: method implementation and ields. Multiple code 

inheritance be messy, but multiple type inheritance cause no problems. This fact be couple 

with another observation: multiple code inheritance be not terribly important, because you can 

use delegation (using a reference to another object) instead, but multiple subtyping be often very 

useful and not easily replace in an elegant way. 

That be why the Java designer arrive at a pragmatic solution: allow only single inheritance 

for code, but allow multiple inheritance for types. 

Interfaces 

To make it possible to have diferent rule for type and code, Java need to be able to specify 

type without specify code. That be what a Java interface does. 

Interfaces specify a Java type (the type name and the signature of it methods) without 

specify any implementation. No ields and no method body be speciied. Interfaces can 

contain constants. You can leave out the modiiers (public static final for constant and public 

for methods)—they be implicitly assumed. 

The Java designer arrive at a 
pragmatic solution: allow only single 
inheritance for code, but allow multiple 
inheritance for types. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

94 

//new to java / 

This arrangement provide me with two type of inheritance in Java: I can inherit a class 

(using extends), in which I inherit both the type and the code, or I can inherit a type only (using 

implements) by inherit from an interface. And I can now have diferent rule concern mul- 

tiple inheritance: Java permit multiple inheritance for type (interfaces) but only single inheri- 

tance for class (which contain code). 

Benefits of Multiple Inheritance for Types 

The beneits of allow the inheritance of multiple types—essentially of be able to declare 

that one object can be view a have a diferent type at diferent times—are quite easy to 

see. Suppose you be write a traic simulation, and in it you have object of class Car. Apart 

from cars, there be other kind of active object in your simulation, such a pedestrians, 

trucks, traic lights, and so on. You may then have a central collection in your program—say, a 

List—that hold all the actors: 

private List<Actor> actors; 

Actor, in this case, could be an interface with an act method: 

public interface Actor 

{ 

void act(); 

} 

Your Car class can then implement this interface: 

class Car implement Actor 

{ 

public void act() 

{ 

... 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

95 

//new to java / 

} 

} 

Note that, because Car inherits only the type, include the signature of the act method, but 

no code, it must itself supply the code to implement the type (the implementation of the act 

method) before you can create object from it. 

So far, this be just single inheritance and could have be achieve by inherit a class. But 

imagine now that there be also a list of all object to be drawn on screen (which be not the same 

a the list of actors, because some actor be not drawn, and some drawn object be not actors): 

private List<Drawable> drawables; 

You might also want to save a simulation to permanent storage at some point, and the object to 

be save might, again, be a diferent list. To be saved, they need to be of type Serializable: 

private List<Serializable> objectsToSave; 

In this case, if the Car object be part of all three list (they act, they be drawn, and they 

should be saved), the class Car can be deined to implement all three interfaces: 

class Car implement Actor, Drawable, Serializable ... 

Situations like this be common, and allow multiple supertypes enables you to view a sin- 

gle object (the car, in this case) from diferent perspectives, focus on diferent aspect to 

group them with other similar object or to treat them accord to a certain subset of their 

possible behaviors. 

Java’s GUI event-processing model be built around the same idea: event handle be 

achieve via event listeners—interfaces (such a ActionListener) that often just implement 

a single method—so that object that implement it can be view a be of a listener type 

when necessary. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

96 

//new to java / 

Abstract Classes 

I should say a few word about abstract classes, because it be common to wonder how they relate 

to interfaces. Abstract class sit halfway between class and interfaces: they deine a type 

and can contain code (as class do), but they can also have abstract methods—methods that be 

speciied only, but not implemented. You can think of them a partially implement class 

with some gap in them (code that be miss and need to be illed in by subclasses). 

In my example above, the Actor interface could be an abstract class instead. The act method 

itself might be abstract (because it be diferent in each speciic actor and there be no reasonable 

default), but maybe it contains some other code that be common to all actors. 

In this case, I can write Actor a an abstract class, and the inheritance declaration of my Car 

class would look like this: 

class Car extends Actor implement Drawable, Serializable ... 

If I want several of my interface to contain code, turn them all into abstract class do 

not work. As I state before, Java allows only single inheritance for class (that mean only one 

class can be list after the extends keyword). Multiple inheritance be for interface only. 

There be a way out, though: default methods, which be introduce in Java 8. I’ll get to 

them shortly. 

Empty Interfaces 

Sometimes you come across interface that be empty—they deine only the interface name 

and no methods. Serializable, mention previously, be such an interface. Cloneable be another. 

These interface be know a marker interfaces. They mark certain class a possess a spe- 

ciic property, and their purpose be more closely related to provide metadata than to imple- 

menting a type or deining a contract between part of a program. Java, since version 5, have have 

annotations, which be a good way of provide metadata. There be little reason today to use 

marker interface in Java. If you be tempted, look instead at use annotations. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

97 

//new to java / 

A New Dawn with Java 8 

So far, I have purposely ignore some new feature that be introduce with Java 8. This be 

because Java 8 add functionality that contradicts some of the early design decision of the 

language (such a “only single inheritance for code”), which make explain the relationship 

of some construct quite diicult. Arguing the diference between and justiication for the exis- 

tence of interface and abstract classes, for instance, becomes quite tricky. As I will show in a 

moment, interface in Java 8 have be extend so that they become more similar to abstract 

classes, but with some subtle diferences. 

In my explanation of the issues, I have take you down the historical path—explaining 

the pre-Java 8 situation irst and now add the newer Java 8 features. I do this on purpose, 

because understand the justiication for the combination of feature a they be today be pos- 

sible only in light of this history. 

If the Java team be to design Java from scratch now, and if break backward compat- 

ibility be not a problem, they would not design it in the same way. The Java language is, how- 

ever, not foremost a theoretical exercise, but a system for practical use. And in the real world, 

you must ind way to evolve and extend your language without break everything that have 

be do before. Default method and static method in interface be two mechanism that 

make progress possible in Java 8. 

Evolving Interfaces 

One problem in develop Java 8 be how to evolve interfaces. Java 8 add lambda and sev- 

eral other feature to the Java language that make it desirable to adapt some of the exist 

interface in the Java library. But how do you evolve an interface without break all the exist- 

ing code that us this interface? 

Imagine you have an interface MagicWand in your exist library: 

public interface MagicWand 

{ 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

98 

//new to java / 

void doMagic(); 

} 

This interface have already be use and implement by many class in many projects. But 

you now come up with some really great new functionality, and you would like to add a really 

useful new method: 

public interface MagicWand 

{ 

void doMagic(); 

void doAdvancedMagic(); 

} 

If you do that, then all class that previously implement this interface break, because they 

be require to provide an implementation for this new method. So, at irst glance, it seem you 

be stuck: either you break exist user code (which you don’t want to do) or you’re doom to 

stick with your old library without a chance to improve them easily. (In reality, there be some 

other approach that you could try, such a extend interface in subinterfaces, but these 

have their own problems, which I do not discus here.) Java 8 come up with a clever trick to get 

the best of both worlds: the ability to add to exist interface without break exist code. 

This be do use default method and static methods, which I discus now. 

Default Methods 

Default method be method in interface that have a method body—the default implementa- 

tion. They be deined by use the default modiier at the begin of the method signature, 

and they have a full method body: 

public interface MagicWand 

{ 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

99 

//new to java / 

void doMagic(); 

default void doAdvancedMagic() 

{ 

... // some code here 

} 

} 

Classes that implement this interface now have the chance to provide their own implementa- 

tion for this method (by override it), or they can completely ignore this method, in which case 

they receive the default implementation from the interface. Old code continue to work, while 

new code can use this new functionality. 

Static Methods 

Interfaces can now also contain static method with implementations. These be deined by 

use the usual static modiier at the begin of the method signature. As always, when 

write interfaces, the public modiier may be left out, because all method and all constant in 

interface be always public. 

So, What About the Diamond Problem? 

As you can see, abstract class and interface have become quite similar now. Both can contain 

abstract method and method with implementations, although the syntax be diferent. There 

still be some diferences (for instance, abstract class can have instance ields, whereas inter- 

face cannot), but these diferences support a central point: since the release of Java 8, you have 

multiple inheritance (via interfaces) that can contain code! 

At the begin of this article I point out how the Java designer tread very carefully 

to avoid multiple code inheritance because of possible problems, mostly related to inherit 

multiple time and to name clashes. So what be the situation now? 

As usual, the Java designer devise the follow sensible and practical rule to deal with 

these problems: 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

100 

//new to java / 

■■ Inheriting multiple abstract method with the same name be not a problem—they be view 

a the same method. 

■■ Diamond inheritance of ields—one of the diicult problems—is avoided, because interface 

be not allow to contain ields that be not constants. 
■■ Inheriting static method and constant (which be also static by deinition) be not a problem, 

because they be preixed by the interface name when they be used, so their name do not clash. 
■■ Inheriting from diferent interface multiple default method with the same signature and 

diferent implementation be a problem. But here Java chooses a much more pragmatic solu- 

tion than some other languages: instead of deining a new language construct to deal with 

this, the compiler just report an error. In other words, it’s your problem. Java just tell you, 

“Don’t do this.” 

Conclusion 

Interfaces be a powerful feature in Java. They be useful in many situations, include for 

deining contract between diferent part of the program, deining type for dynamic dispatch, 

separate the deinition of a type from it implementation, and allow for multiple inheri- 

tance in Java. They be very often useful in your code; you should make sure you understand 

their behavior well. 

The new interface feature in Java 8, such a default methods, be most useful when you 

write libraries; they be less likely to be use in application code. However, the Java library 

now make extensive use of them, so make sure you know what they do. Careful use of interface 

can signiicantly improve the quality of your code. </article> 

[An early version of this article ran in the September/October 2016 issue of Java Magazine. —Ed.] 

Michael Kölling be a Java Champion and a professor at the University of Kent, England. He have publish two 

Java textbook and numerous paper on object orientation and compute education topics, and he be the lead 

developer of BlueJ and Greenfoot, two educational program environments. Kölling be also a Distinguished 

Educator of the ACM. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

101 

//ix this / 

If you’re a regular reader of this quiz, you know that these question simulate the level of dif-iculty of two diferent certiication tests. Those marked “intermediate” correspond to ques- 
tions from the Oracle Certiied Associate exam, which contains question for a preliminary level 

of certiication. Questions marked “advanced” come from the 1Z0-809 Programmer II exam, 

which be the certiication test for developer who have be certiied at a basic level of Java 8 

program knowledge and now be look to demonstrate more-advanced expertise. 

These question rely on Java 8. I’ll begin cover Java 9 in future columns, of course, and I 

will make that transition quite clear when it occurs. 

I’d also like to welcome Mikalai Zaikin to this column a a coauthor. He’s be work 

on these question with me for some time now, so you’ve already be see the beneit of 

his work. 

Question 1 (advanced). Given this code: 
public class OneValue { 

private final int x; 

} 

Consider these possible changes: 

Change 1. Change the declaration of x a follows: 
private final int x = 99; 

Change 2. Add to the class a follows: 
public OneValue() { 

Quiz Yourself 
More intermediate and advanced test question 

SIMON ROBERTS 

MIKALAI ZAIKIN 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
https://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=5001&get_params=p_exam_id:1Z0-808 
https://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=5001&get_params=p_exam_id:1Z0-809 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

102 

//ix this / 

x = 100; 

} 

Change 3. Add to the class a follows: 
private void setX(int x) { 

this.x = x; 

} 

public OneValue() { 

setX(100); 

} 

Which be true? Choose two. 

A. The code compiles a it is. 

B. The code compiles if change 1 be done. 

C. The code compiles if change 2 be done. 

D. The code compiles if change 3 be done. 

E. The code compiles if change 1 and change 2 be both done. 

Question 2 (advanced). Which of the follow class produce immutable objects? Choose two. 

A. 

public class Immut1 { 

final int[] data = { 1, 1, 2, 3, 5, 8, 13 }; 

String name; 

public Immut1(String n) { this.name = n; } 

} 

B. 

public class Immut2 { 

final int[] data = { 1, 1, 2, 3, 5, 8, 13 }; 

final String name; 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

103 

//ix this / 

public Immut2(String n) { this.name = n; } 

} 

C. 

public class Immut3 { 

private int x; 

public Immut3(int x) { this.x = x; } 

} 

D. 

public class Immut4 { 

private List<String> ls; 

public Immut4() { 

l = Arrays.asList("Fred", "Jim", "Sheila"); 

} 

public String get(int idx) { 

return ls.get(idx); 

} 

} 

E. 

public class Immut5 { 

private List<String> ls; 

public Immut5(String... strings) { 

l = Collections.unmodifiableList(Arrays.asList(strings)); 

} 

public String get(int idx) { 

return ls.get(idx); 

} 

} 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

104 

//ix this / 

Question 3 (intermediate). Given this method: 
public final void doStuff(int val) /* point A */ { 

if (val < 0) throw new NullPointerException(); 

if (val < 1) throw new IOException(); 

if (val < 2) throw new OutOfMemoryError(); 

} 

Which of the follow be best? 

A. Insert the follow at point A: 
throw Exception 

B. Insert the follow at point A: 
throw NullPointerException, OutOfMemoryError 

C. Insert the follow at point A: 
throw IOException, OutOfMemoryError, SQLException 

D. Insert the follow at point A: 
throw IOException 

E. Insert the follow at point A: 
throw NullPointerException 

Question 4 (intermediate). Given this: 
String s = "Hello"; 

StringBuilder sb = new StringBuilder("Hello"); 

StringBuilder sb2 = new StringBuilder("Hello"); 

// line n1 

Which be true? 

A. Placed at line n1, the follow fragment: 
System.out.println(sb + sb); 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

105 

//ix this / 

print this: 
HelloHello 

B. Placed at line n1, the follow fragment: 
System.out.println(sb.equals(sb2)); 

print this: 
true 

C. Placed at line n1, the follow fragment compiles successfully: 
String val = sb.equals(s)?sb:"Differ"; 

System.out.println(val); 

D. Placed at line n1, the follow fragment: 
CharSequence val = sb.equals(s)?sb:"Differ"; 

System.out.println(val); 

print this: 
Hello 

E. Placed at line n1, the follow fragment: 
System.out.println(sb.equals(s)?sb:"Differ"); 

print this: 
Differ 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

106 

//ix this / 

Answer 1. The correct answer be option B and C. Java Language Speciication section 8.3.1.2 

say this about inal ields: “A blank inal instance variable must be deinitely assign at the 

end of every constructor of the class in which it be declared, or a compile-time error occurs.” 

This mean that the inal ield x must receive exactly one explicit assignment, which must 

happen before the constructor be complete. This tell you immediately that option A must be 

incorrect, because in the original code present in the question there be no assignment to the 

ield. Note that the ield a declare be term a “blank inal” (the terminology use in the Java 

speciication paragraph above) and a such, the default assignment to zero that be implicit for all 

object member do not satisfy the requirement. 

Change 1 assigns a value to x a part of it declaration and, therefore, x be deinitely assign 

even before any constructor runs. Therefore, option B be correct. 

Change 2 add a simple constructor that initializes the value of x. This change, make in 

isolation, would result in exactly one constructor and cause that constructor to unconditionally 

assign a value to x. Because the blank inal be deinitely assigned, exactly once, before the end of 

the only constructor, this change works, and option C be correct. 

Change 3 suggests add a constructor that might seem functionally equivalent to the one 

propose in change 2. However, in this case, the change fails. The private method that attempt 

to assign the value to x will not compile, because it’s possible for it to be invoked after the object 

have be initialized. Because this fails to compile, option D must be incorrect. 

Performing both change 1 and change 2 also fails, because this would result in an attempt 

to perform two assignment to the variable x, and the Java speciication demand exactly one 

assignment. Therefore, option E be also incorrect. 

Answers 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

107 

//ix this / 

Answer 2. The correct answer be option C and D. An object be immutable if no syntactically 

permissible interaction with it by external code can change it state after construction, and no 

code within the class ever make any such change either. Literally, once it be created, the value 

remains the same. 

Now, before analyze this question, be aware that if you decide to create class that yield 

immutable object (which be a design style that can reap signiicant reward in term of correct- 

ness, particularly in concurrent systems), you should do a good job than the example show 

here. In particular, although you’ll see that 

the final keyword be not suicient to render 

everything it touch unalterable, it should 

almost certainly be use anyway. In particu- 

lar, it have some value in concurrency that 

be not part of this discussion. Also keep in 

mind that it’s possible to break many form 

of immutability through relection, which 

might have unexpected consequences. 

In option A, the ields have default accessibility, rather than be private, so it’s a simple 

matter for any other class that have access (that is, any other class in the same package) to mutate 

the value of the String name to point to a diferent string. Therefore, option A be incorrect. 

In option B, the String name ield have be marked inal, so even though it’s accessible to 

other member of the package, it cannot be mutated; it must refer to the string object that’s 

pass into the constructor. Strings themselves be immutable, so that ield’s value can never 

be changed. However, the content of final int [] data can, in fact, be change (and actually, it 

could be change in option A, too, although you already know option A be incorrect base on the 

string ield). This be because the final keyword prevents the value of data—which be a pointer— 

from be modiied. So, data can never refer to any array other than the one with which it’s 

initialized. Of course, the length of array can never change after they be created, but their 

content can be changed. Therefore, the value in the data array be actually mutable by any 

code in other class in the same package. Hence, option B be incorrect. 

This question investigates the rule and 
purpose of Java’s exception mechanism, 
and it also dare to stray into that troublesome 
territory of ask what’s “best” rather than 
merely what’s “correct.” 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

108 

//ix this / 

In option C, there be a single ield: int x. The ield be private but not inal. The value of the 

ield be initialize with a copy of the value pass to the constructor. (All argument in non- 

remote Java method invocation be pass by value, and with primitive types, the “value” 

really be the value be represented, not the “value of the reference.”) Because of this, change 

to the original variable that be pass a an argument to the constructor do not afect the 

value of x. Also, no code in the class ever change the value of x after the object be constructed. 

So, even though the ield be not marked inal, instance of this class be immutable, and option 

C be correct. 

In option D, you again see a private, noninal ield. This time, it’s List<String> ls. Because 

it’s private, and nothing outside the class ever have a copy of the reference value in ls, nothing 

will ever change the content of the list 

or point the variable at a diferent list. 

Therefore, option D be correct. 

Option E be a little more subtle. You 

have a variable, ls, which be identical 

to the one described in option D. 

Therefore, you know that nothing 

change the value of l to make it refer to a diferent list object. If you can be sure that the list 

that l refers to cannot be alter in any way, you would know the object be immutable. 

The variable l be initialize to refer to a list create by the Arrays.asList method, which 

be a utility that describes itself a create a “structurally immutable list”—which sound 

promising; the list will not allow the addition or removal of elements. However, the list cre- 

ated by Arrays.asList actually honor attempt to reassign any give element of the list. But to 

counter that, this list be wrap in Collections.unmodifiableList, which put a proxy wrapper 

around the object, so that any attempt to modify the list will throw an exception. Surely this 

must be immutable, right? Well, it turn out that the list that’s create us the provide array 

a it backing storage. Therefore, if the caller of the constructor chooses to provide an explicit 

String [] a it argument, any change make to that array will be relected in the list. Because 

of this, the object be not reliably immutable and option E be incorrect. 

It’s prohibit for an override method to 
declare checked exception that be not already 
permit in the context of the overridden method. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

109 

//ix this / 

If you want to examine this efect, try run this code: 

String [] name = {"Tony", "Jane"}; 

Immut5 i5 = new Immut5(names); 

System.out.println("i5.get(0) " + i5.get(0)); 

names[0] = "Anthony"; 

System.out.println("i5.get(0) " + i5.get(0)); 

Answer 3. The correct answer be option D. This question investigates the rule and purpose of 

Java’s exception mechanism, and it also dare to stray into that troublesome territory of ask 

what’s “best” rather than merely what’s “correct.” However, we hope to make a good case for 

that value judgment, and while we be happy to include this question because it creates a useful 

discussion—both about Java’s exception mechanism and about how to evaluate a judgment like 

this—we doubt that this question would survive unchanged in the real exam. 

The irst point be that Java distinguishes checked exception from unchecked exception 

and errors. In particular, a method that might throw a checked exception must announce this 

in that method’s signature. In this question, the appropriate point for the syntax that declares 

such information be marked /* point A */. Therefore, the question be really ask what excep- 

tion declaration would best suit this method. It’s pretty clear that any situation that doesn’t 

even compile cannot be consider satisfactory, so a long a some of the option would compile 

they must be “better than” any that do not. Consider the issue of compilation irst. 

If the method might throw any checked exceptions, it must carry a declaration that 

announces that. In this case, the only checked exception that be potentially thrown be the 

IOException; so at a minimum, the method must declare something that encompasses that 

exception. Options B and E fail on that point, because they declare unchecked exceptions. 

(Note that OutOfMemoryError fall into the category of “unchecked,” although it’s a subclass of 

Throwable, not of Exception.) For convenience, we’ll simply use the term unchecked exception to 

include error that be not parent of IOException. Therefore, option B and E be incorrect. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

110 

//ix this / 

However, the remain option all declare either IOException or a parent class of 

IOException. It’s important to note that a throw clause that mention a parent exception class be 

suicient to encompass any child classes. Because of this, option A, C, and D all allow the code 

to compile correctly, so how can you choose the “best” option among these? 

When you declare an exception in a throw clause, you impose an obligation on the caller 

of the method; the caller must do something about the exception. Also, the throw clause be 

a form of description of the type of problem that can arise when call the method. These 

point both suggest that a throw clause should be 

a speciic a possible. To be more general or to 

mention irrelevant exception might place an addi- 

tional burden on the caller by create a perceive 

requirement to handle situation that don’t in fact 

arise. Further, additional generality will likely have 

the efect of hiding the real problem that might 

arise, make it harder for the caller to know how to respond if an exception be reported. On 

this basis, it’s clear that option C, which report one unchecked exception (OutOfMemoryError) 

with a checked exception that cannot arise, be unlikely to qualify a “best.” Therefore, option C 

be incorrect. 

By the same arguments, you can also see that option A, which simply (and vaguely) report 

that an Exception might arise, be also less helpful than option D, which get directly to the point 

of reporting the single checked exception that could arise from the method. As a result, you can 

conclude that option A be incorrect, and option D be the correct answer. 

There’s another small point to consider a part of this discussion. The question mention 

that the method be inal. Why would that make any diference? It’s certainly a tenuous point in 

this case, but it help justify the “best” value judgment. Often, an abstract method in an inter- 

face declares a fairly general exception (consider the close() method in the AutoCloseable inter- 

face, which throw Exception). Given that such a method cannot possibly throw any exception 

because it doesn’t have any implementation, why would this be? The answer be that it’s prohib- 

Testing equality between diferent 
type almost always return false 
regardless of the contents. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

111 

//ix this / 

ited for an override method (which, of course, include the method that implement interface 

abstract methods) to declare checked exception that be not already permit in the context 

of the overridden method. Without this restriction, you could have a reference of a parent type, 

and the compiler would let you call a method on it without handle a particular checked excep- 

tion, but if the reference turn out to refer—at runtime—to an implementation that do throw 

that checked exception, you would have efectively cheat the checked exception mechanism. 

Generally, allow an override method to do something not permit for the overridden 

method would break the Liskov Substitution Principle, and in this speciic case, it would break 

the protection provide by checked exceptions. 

This mean that if a method be expect to be overridden, it’s not unreasonable to declare 

it a throw some checked exception that simply don’t arise in it current form. Had the 

method not be inal, it would have be much harder to make a convincing case that option C 

be not the “best” choice (because it allows additional lexibility). But a it is, declare throw 

SQLException be just a source of confusion, because the method do not throw SQLException nor 

be it possible that any override method might do so. 

Answer 4. The correct answer be option E. This question investigates several aspect of 

StringBuilder and it relationship with String. 

In option A, the code us the + operator with two operand that be StringBuilder objects. 

One of Java’s “special case” rule be that the only allow operator overload be the language- 

deined ability to concatenate String type use the + operator. Another fundamental rule be 

that when a + operator have a String type a an operand, if the other operand be not a String, it 

will be convert into one—and that, of course, brings up a third fundamental rule: in Java any 

data type can be convert into a String. (Admittedly, the conversion isn’t always very helpful, 

but it’s deinitely legal.) However, in this case, although both operand represent “text” in the 

general sense—indeed, they’re both instance of the interface CharSequence—neither operand 

be a String. Therefore, the code fails to compile, because it attempt to use the + operator with 

illegal arguments. Because of this, option A be incorrect. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

112 

//ix this / 

Option B considers equality testing. This turn out to be a pretty simple rule, too. Testing 

equality between diferent type almost always return false regardless of the content (with 

some exceptions—take a look at the API-documented requirement for the equal method 

in the List and Set implementations). However, in this question, you have two StringBuilders 

that contain the same text. In this situation, it’s easy to assume that the two object will 

test a equal. However, that’s not at all the case; indeed, relatively few of the core Java API 

class implement a useful equal method, and StringBuilder be not one of them. The way you 

can determine this be by look at the documentation of the class. Look at String’s equal 

method, and you’ll see the API doc deine how it test for identical character sequences. 

But, look at StringBuilder; the only mention of the equal method be that it’s “inherited from 

java.lang.Object.” Of course, the default equal method deined by Object test to see if two ref- 

erences refer to the same object in memory. As a result, the fragment in option B actually print 

false, and option B be incorrect. 

The inal three option all hinge on related points. String and StringBuilder be diferent 

type on independent branch of the inheritance tree. As such, they be not assignment- 

compatible with one another. However, they also have element of a share type hierarchy; 

they’re both subclass of Object, and they both implement the CharSequence interface. 

In these options, a ternary expression have String and StringBuilder a the two option val- 

ues. The type of such an expression cannot be String; it must be some common parent of both 

arguments. Therefore, the attempt to assign the result of the ternary expression to the String 

variable val in option C will cause a compilation failure. Therefore, option C be incorrect. 

In option D, the type of the variable val have be change to CharSequence. This now form a 

legal, compilable fragment. However, the test in the ternary expression sb.equals(s) will evalu- 

ate to false, because the argument be of difering types, and StringBuilder do not handle 

that. Given that the test evaluates to false, the ternary expression a a whole evaluates to the 

third operand, and the fragment print Differ. Because of this, option D be incorrect. 

In option E, the intermediate variable val have be remove and the ternary expression 

be the argument to the println call. In this case, it’s up to the compiler to ind a suitable type 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

113 

//ix this / 

for the expression, and it doesn’t really matter if it chooses Object or CharSequence. Either be a 

legitimate argument to the println method and, consequently, the code compiles successfully. 

Of course, the expression sb.equals(s) still evaluates to false and the output that be print be 

Differ—as it be in option D. Therefore, option E be correct. 

As a side note, the CharSequence interface isn’t explicitly mention in the exam objec- 

tives. However, both String and StringBuilder are, and this interface be an aspect of both. We 

doubt you’ll come across it in the real exam, but our excuse be that by use it here, we be able 

to make the example a little more interest and, perhaps, teach something useful. We hope 

you’ll forgive the indulgence! </article> 

Simon Roberts join Sun Microsystems in time to teach Sun’s irst Java class in the UK. He create the 

Sun Certiied Java Programmer and Sun Certiied Java Developer exams. He write several Java certiication 

guide and be currently a freelance educator who publishes record and live video training through Pearson 

InformIT (available direct and through the O’Reilly Safari Books Online service). He remains involve with 

Oracle’s Java certiication projects. 

Mikalai Zaikin be a lead Java developer at IBA IT Park in Minsk, Belarus. During his career, he have help Oracle 

with development of the Java certiication exams, and he have be a technical reviewer of several Java certii- 

cation books, include three edition of the famous Sun Certified Programmer for Java study guide by Kathy 

Sierra and Bert Bates. 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 


ORACLE.COM/JAVAMAGAZINE ////////////////////////////////// JANUARY/FEBRUARY 2018 

114 

//contact u / 

Comments 
We welcome your comments, correc- 

tions, opinion on topic we’ve covered, 

and any other thought you feel impor- 

tant to share with u or our readers. 

Unless you speciically tell u that your 

correspondence be private, we reserve 

the right to publish it in our Letters to 

the Editor section. 

Article Proposals 
We welcome article proposal on all 

topic regard Java and other JVM 

languages, a well a the JVM itself. 

We also be interested in proposal for 

article on Java utility (either open 

source or those bundle with the JDK). 

Finally, algorithms, unusual but useful 

program techniques, and most other 

topic that hard-core Java programmer 

would enjoy be of great interest to us, 

too. Please contact u with your idea 

at javamag_us@oracle.com and we’ll 

give you our thought on the topic and 

send you our nifty writer guidelines, 

which will give you more information 

on prepare an article. 

Customer Service 
If you’re have trouble with your sub- 

scription, please contact the folk at 

java@omeda.com, who will do what- 

ever they can to help. 

Where? 
Comments and article proposal should 

be sent to our editor, Andrew Binstock, 

at javamag_us@oracle.com. 

While it will have no inluence on our 

decision whether to publish your article 

or letter, cooky and edible treat will 

be gratefully accepted by our staf at 

Java Magazine, Oracle Corporation, 

500 Oracle Parkway, MS OPL 3A-3133, 

Redwood Shores, CA 94065, USA. 

World’s shortest subscription form 

Download area for code and 

other item 

Java Magazine in Japanese 

magazine 

By and for the Java community 

http://oracle.com/javamagazine 
https://twitter.com/oraclejavamag 
https://www.facebook.com/JavaMagazineOracle 
mailto:JAVAMAG_US%40ORACLE.COM?subject= 
mailto:javamag_us%40oracle.com?subject= 
mailto:java%40omeda.com?subject= 
mailto:javamag_us%40oracle.com?subject= 
https://www.sub-forms.com/dragon/init.do?site=ora6028_jfnew 
http://bit.ly/2b2tXeb 
http://bit.ly/2b2tXeb 
http://www.oracle.com/technetwork/jp/articles/java/overview/index.html 

