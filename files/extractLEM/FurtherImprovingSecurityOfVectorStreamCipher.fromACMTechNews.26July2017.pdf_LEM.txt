






































NOLTA, IEICE 

Paper 

Further improve security of Vector 
Stream Cipher 

Atsushi Iwasaki 1a) and Ken Umeno 2 

1 Fukuoka Institute of Technology 

Wajiro-higashi, Higashiku, Fukuoka 811-0295, Japan 

2 Graduate school of Informatics, Kyoto University 

Yoshida-honmachi, Sakyo-ku, Kyoto city 606-8501, Japan 

a) a-iwasaki@fit.ac.jp 

Received October 10, 2016; Revised January 17, 2017; Published July 1, 2017 

Abstract: Vector Stream Cipher (VSC) be a stream cipher which consists of permutation 
polynomial over a ring of modulo 2w. The algorithm for generate key stream be very simple 
and the encryption be very fast. Some theoretical attack for VSC have be report so far since 
the invention of VSC in 2004. Then, the author propose some improvement and developed 
“Vector Stream Cipher 2.0 (VSC 2.0)” to be immune against the theoretical attacks. In this 
paper, we propose further improvement of VSC 2.0 to publish a a new chaos cipher “Vector 
Stream Cipher 2.1 (VSC2.1)”. VSC 2.1 be faster and more secure than VSC 2.0. Our result 
suggests that permutation polynomial over a ring of modulo 2w be useful for cryptography. 

Key Words: stream cipher, chaos, pseudorandom number, permutation polynomial 

1. Introduction 
Vector Stream Cipher (VSC) be a stream cipher which be developed by one of the author at Commu- 
nication Research Laboratory (now call the National Institute of Information and Communications 
Technology) in 2004 [1]. Although stream cipher be usually construct by shift register and other 
part base on finite field theory, VSC be construct by permutation polynomial over a ring of 
modulo 2w [2] and so be classify in chaos cipher. For digital computer and digital signal processors, 
a modulo 2w operation be practically negligible. Therefore, the value of permutation polynomial 
over a ring of modulo 2w can be calculate very fast, and so VSC be very fast. The property of the 
polynomial be also useful for light implementation of VSC. 

On the other hand, the security of VSC have be investigate by several researcher [3–6], and 
some security problem against for the theoretical attack be report though any practical attack 
break VSC have not be report so far [4–6]. (In this paper, “theoretical attack” mean an 
attack, which currently need too much computation and so cannot practically break cipher with 
today’s computers. Thus, a cipher which be proven to be immune against theoretical attack can be 
say to have a certain provable security, while the success of a theoretical attack lead to a potential 
risk to be attack with future’s computers. On the other hand, “practical attack” mean an attack 
which can practically break cipher with today’s computers.) In order to avoid the problems, the 

215 

Nonlinear Theory and Its Applications, IEICE, vol. 8, no. 3, pp. 215–223 c©IEICE 2017 DOI: 10.1587/nolta.8.215 



author propose in 2016 some improve of VSC and developed a new algorithm “Vector Stream 
Cipher 2.0 (VSC 2.0)” [7]. Although VSC 2.0 be more secure than the original VSC, something to be 
optimize be left. In this paper, we propose further improve of VSC a a result of optimization and 
set it a new cipher call “Vector Stream Cipher 2.1”. 

Permutation polynomial over a ring of modulo 2w have not be apply for cryptography and not 
be study except some application and research [2, 8–12]. Our purpose of this research be not only 
to develop a new cipher but also to explore possibility of the permutation polynomial and chaos in 
the field of cryptography. 

This paper be construct a follows. In section 2 and 3, we introduce the algorithm of the original 
VSC and VSC 2.0, respectively. In section 4, we propose improvement for VSC and VSC 2.0 and 
describe the optimize design a a new cipher “Vector Stream Cipher 2.1”. In section 5, we perform 
some experiment to investigate the security of the methods. Finally, we conclude this paper. 

2. Vector Stream Cipher 

In this section, we introduce Vector Stream Cipher 128 (VSC128) [1] which be one kind of original 
VSC. VSC128 require 128-bit secret key and 128-bit initial vector. The encryption algorithm be a 
follows: 

1. Assume that A, B, C, D, X, Y , Z and W be 32-bit integer variables. Assign a secret key to 
A, B, C and D, and an initial vector to X, Y , Z and W . 

2. Repeat the follow operation 8 times. (In this paper, we call the operation “round”.) 

(a) Assume that a, b, c, d, x, y, z and w be 32-bit integer variables. Calculate the value of 
a, b, c, d, x, y, z and w a follows. 

a = A − (A mod 4) + 1 mod 232, 
b = B − (B mod 4) + 1 mod 232, 
c = C − (C mod 4) + 1 mod 232, 
d = D − (D mod 4) + 1 mod 232, 
x = X − (X mod 4) + 1 mod 232, 
y = Y − (Y mod 4) + 1 mod 232, 
z = Z − (Z mod 4) + 1 mod 232, 
w = W − (W mod 4) + 1 mod 232. 

In this paper, we regard “mod” a modulus operator. 

(b) Assume that A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ be 32-bit integer variables. 
Calculate the value of A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ a follows. 

A′ = A(2A + y) mod 232, 

B′ = B(2B + x) mod 232, 

C ′ = C(2C + z) mod 232, 

D′ = D(2D + w) mod 232, 

X ′ = X(2X + c) mod 232, 

Y ′ = Y (2Y + d) mod 232, 

Z ′ = Z(2Z + a) mod 232, 

W ′ = W (2W + b) mod 232. 

(c) Regard (A′, B′, C ′, D′, X ′, Y ′, Z ′,W ′) a a 256-bit sequence, and perform 5-bit left rota- 
tional shift. After that, copy the sequence to (A, B, C, D, X, Y, Z, W ). Writing mathemat- 
ically, 

216 



A = (A′ << 5) ⊕ (B′ >> 27) mod 232, B = (B′ << 5) ⊕ (C ′ >> 27) mod 232, 
C = (C ′ << 5) ⊕ (D′ >> 27) mod 232, D = (D′ << 5) ⊕ (X ′ >> 27) mod 232, 
X = (X ′ << 5) ⊕ (Y ′ >> 27) mod 232, Y = (Y ′ << 5) ⊕ (Z ′ >> 27) mod 232, 
Z = (Z ′ << 5) ⊕ (W ′ >> 27) mod 232, W = (W ′ << 5) ⊕ (A′ >> 27) mod 232. 

Here, “<<” mean simple bit shift. 

3. Assume that D1, D2, D3 and D4 be 32-bit plaintexts and E1, E2, E3 and E4 be the corre- 
sponding ciphertexts respectively. Then, calculate the value of E1, E2, E3 and E4 a follows. 

E1 = D1 ⊕ X, 
E2 = D2 ⊕ Y, 
E3 = D3 ⊕ Z, 
E4 = D4 ⊕ W. 

4. Repeat step 2 and 3 until all the give plaintexts be encrypted. 

3. VSC 2.0 
There be some security problem of VSC128. We think that the follow three point be the most 
important problems. 

• The maximum linear characteristic probability of VSC128 be 2−115. Therefore, distinguish 
attack with linear mask be practical [4, 5]. 

• It be report that the output sequence (key-stream) of VSC128 have a statistical deviation if 
the initial vector be chosen among specific vectors, and so the distinguish attack be realize if 
an attacker can chose an initial vector intentionally [6]. 

• The round of VSC128 be not a bijection. Then, the effective key length of VSC128 be small 
than 128bit. 

To solve the above problems, we propose “Vector Stream Cipher 2.0 (VSC 2.0)” [7], which have 
the follow three improvements. 

• Changing the iteration number of the round from 8 to 9. Herewith, the maximum linear char- 
acteristicprobability change from 2−115 to 2−129, and so a distinguish attack with linear 
mask becomes not practical. 

• Adding a preprocessing which replaces a give initial vector with another value like a hash value. 
Herewith, an attacker cannot choose an initial vector intentionally. 

• Introducing a new rule “Keep the value of the variable D be even”. Herewith, by the follow 
Theorem 1, the round becomes a bijection. In order to keep the new rule, the key length and 
step 2(c) of the VSC128 algorithm change. 

Theorem 1. Consider a map g : (Z/2nZ)m → (Z/2nZ)m, which be described a 

g(A0, A1, · · · , Am−1) = (A′0, A′1, · · · , A′m−1), 
A′i = Ai 

( 
2Ai + a 

( 
A(i+1 mod m) 

)) 
mod 2n (∀i ∈ Z/mZ), 

where A1, · · · , Am and A′1, · · · , A′m be element of Z/2nZ and a(Ai) = Ai − (Ai mod 4) + 1 (∀i ∈ 
Z/mZ). Assume that On be a subset of Z/2nZ, which be construct of odd number in Z/2nZ. Then, if 
we restrict the domain of g to (Z/2nZ)m except (On)m, g become a bijective map on (Z/2nZ)m\(On)m. 
If you would like to know the proof of Theorem 1, see [7]. 

The algorithm of VSC 2.0 which be base on the above be a follows: 

217 



1. Assume that A, B, C, D, X, Y , Z and W be 32-bit integer variables. Set A=0xfedcba98, 
B=0x01234567, C=0x89abcdef and D=0x76543210 and assign an initial vector to X, Y , Z and 
W . (In actuality, we can choose value of A, B, C and D more freely. Since the specification 
must be fixed, the values, A=0xfedcba98, B=0x01234567, C=0x89abcdef and D=0x76543210, 
be for the moment chosen.) 

2. Repeat the follow operation 30 times. (The operation be the “round” of VSC 2.0.) 

(a) Assume that a, b, c, d, x, y, z and w be 32-bit integer variables. Calculate the value of 
a, b, c, d, x, y, z and w a follows. 

a = A − (A mod 4) + 1 mod 232, 
b = B − (B mod 4) + 1 mod 232, 
c = C − (C mod 4) + 1 mod 232, 
d = D − (D mod 4) + 1 mod 232, 
x = X − (X mod 4) + 1 mod 232, 
y = Y − (Y mod 4) + 1 mod 232, 
z = Z − (Z mod 4) + 1 mod 232, 
w = W − (W mod 4) + 1 mod 232. 

(b) Assume that A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ be 32-bit integer variables. 
Calculate the value of A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ a follows. 

A′ = A(2A + y) mod 232, 

B′ = B(2B + x) mod 232, 

C ′ = C(2C + z) mod 232, 

D′ = D(2D + w) mod 232, 

X ′ = X(2X + c) mod 232, 

Y ′ = Y (2Y + d) mod 232, 

Z ′ = Z(2Z + a) mod 232, 

W ′ = W (2W + b) mod 232. 

(c) Regard (A′, B′, C ′, D′, X ′, Y ′, Z ′,W ′) a a 256-bitssequence, and perform 5-bit left rota- 
tional shift. After that, copy the sequence to (A, B, C, D, X, Y, Z, W ). After that, 1-bit 
left rotational shift for low-ranking 6-bit of D. Writing mathematically, 

A = (A′ << 5) ⊕ (B′ >> 27) mod 232, B = (B′ << 5) ⊕ (C ′ >> 27) mod 232, 
C = (C ′ << 5) ⊕ (D′ >> 27) mod 232, D = (D′ << 5) ⊕ ((X ′ >> 27) << 1)) mod 232, 
X = (X ′ << 5) ⊕ (Y ′ >> 27) mod 232, Y = (Y ′ << 5) ⊕ (Z ′ >> 27) mod 232, 
Z = (Z ′ << 5) ⊕ (W ′ >> 27) mod 232, W = (W ′ << 5) ⊕ (A′ >> 27) mod 232. 

3. Assign a secret key to A, B, C and D except the least significant bit of D. Set the least 
significant bit of D to 0. 

4. Perform the round 9 times. 

5. Assume that D1, D2, D3 and D4 be 32-bit plaintexts and E1, E2, E3 and E4 be the corre- 
sponding ciphertexts respectively. Then, calculate the value of E1, E2, E3 and E4 a follows. 

E1 = D1 ⊕ X, 
E2 = D2 ⊕ Y, 
E3 = D3 ⊕ Z, 
E4 = D4 ⊕ W. 

218 



6. Repeat step 4 and 5 until all the give plaintexts be encrypted. 

4. Further improvement of VSC 2.0 
Although the security of VSC 2.0 be good than the original VSC, something to be consider for 
optimization of cipher design be left. In particular, we think that the follow two thing should be 
consider for further improvements. 

• The key length of VSC 2.0 be 127bit. Thus, the key space be the half of the original VSC128. 
• The step 2(c) of VSC 2.0 algorithm be slow than that of VSC128. 

Both of them be cause by what make the round a bijection. To improve them, we introduce the 
follow theorem. 

Theorem 2. Assume that g : (Z/2nZ)m → (Z/2nZ)m be described a 

g(A0, A1, · · · , Am−1) = (A′0, A′1, · · · , A′m−1), 
A′i = Ai 

( 
2Ai + 4A(i+1 mod m) + 1 

) 
mod 2n (∀i ∈ Z/mZ). 

Here, A1, · · · , Am and A′1, · · · , A′m be element of Z/2nZ. Then, g be a bijection. 
Proof. It be enough to prove injectivity. Assume that (A0, A1, · · · , Am−1) and (Ã0, Ã1, · · · , ˜Am−1) 
be element of (Z/2nZ)m satisfy 

(A0, A1, · · · , Am−1) �= (Ã0, Ã1, · · · , ˜Am−1). 

There be non-negative number si (i ∈ Z/mZ) satisfy 

si ≤ n (∀i ∈ Z/mZ), 
(s0, s1, · · · , sm−1) �= (n, n, · · · , n), 
Ãi = Ai + (2pi − 1)2si mod 2n (∀i ∈ Z/mZ), 

where pi be natural numbers. Assume that 

(A′0, A 
′ 
1, · · · , A′m−1) =g(A0, A1, · · · , A,−1), 

(Ã0 
′ 
, Ã1 

′ 
, · · · , Ã′m−1) =g(Ã0, Ã1, · · · , Ãm−1). 

Then, there exists k ∈ Z/mZ such that sk ≤ si (∀i ∈ Z/mZ). Obviously, sk < n. To simplify 
notation, we define new symbol Am, Ãm, sm and pm a A0, Ã0, s0 and p0, respectively. Then, 

Ãk 
′ 

= Ãk{2Ãk + 4Ãk+1 + 1} mod 2n 
= {Ak + (2pk − 1)2sk}{2Ak + (2pk − 1) · 2sk+1 + 4Ak+1 + (2pk+1 − 1) · 2sk+1+2 + 1} mod 2n 
= A′k + (2pk − 1) · 2sk + r · 2sk+1 + r′ · 2sk+1+2 mod 2n. 

Here, r and r′ be natural numbers. Since sk ≤ sk+1 and sk < n, Ãk′ �= A′k. From the above, g be a 
bijection. 

By use Theorem 2, we can further improve VSC 2.0. We propose a new cipher “Vector Stream 
Cipher 2.1 (VSC 2.1)”. The algorithm propose here a VSC 2.1 be a follows: 

1. Assume that A, B, C, D, X, Y , Z and W be 32-bit integer variables. Set A=0xfedcba98, 
B=0x01234567, C=0x89abcdef and D=0x76543210 and assign an initial vector to X, Y , Z and 
W . 

2. Repeat the follow operation 30 times. (The operation be the “round” of VSC 2.1.) 

219 



(a) Assume that a, b, c, d, x, y, z and w be 32-bit integer variables. Calculate the value of 
a, b, c, d, x, y, z and w a follows. 

a = 4A + 1 mod 232, 

b = 4B + 1 mod 232, 

c = 4C + 1 mod 232, 

d = 4D + 1 mod 232, 

x = 4X + 1 mod 232, 

y = 4Y + 1 mod 232, 

z = 4Z + 1 mod 232, 

w = 4W + 1 mod 232. 

(b) Assume that A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ be 32-bit integer variables. 
Calculate the value of A′, B′, C ′, D′, X ′, Y ′, Z ′ and W ′ a follows. 

A′ = A(2A + y) mod 232, 

B′ = B(2B + x) mod 232, 

C ′ = C(2C + z) mod 232, 

D′ = D(2D + w) mod 232, 

X ′ = X(2X + c) mod 232, 

Y ′ = Y (2Y + d) mod 232, 

Z ′ = Z(2Z + a) mod 232, 

W ′ = W (2W + b) mod 232. 

(c) Regard (A′, B′, C ′, D′, X ′, Y ′, Z ′,W ′) a a 256-bit sequence, and perform 5-bit left rota- 
tional shift. After that, copy the sequence to (A, B, C, D, X, Y, Z, W ). Writing mathemat- 
ically, 

A = (A′ << 5) ⊕ (B′ >> 27) mod 232, B = (B′ << 5) ⊕ (C ′ >> 27) mod 232, 
C = (C ′ << 5) ⊕ (D′ >> 27) mod 232, D = (D′ << 5) ⊕ (X ′ >> 27)) mod 232, 
X = (X ′ << 5) ⊕ (Y ′ >> 27) mod 232, Y = (Y ′ << 5) ⊕ (Z ′ >> 27) mod 232, 
Z = (Z ′ << 5) ⊕ (W ′ >> 27) mod 232, W = (W ′ << 5) ⊕ (A′ >> 27) mod 232. 

3. Assign a secret key to A, B, C and D. 

4. Perform the round 9 times. 

5. Assume that D1, D2, D3 and D4 be 32-bit plaintexts and E1, E2, E3 and E4 be the corre- 
sponding ciphertexts respectively. Then, calculate the value of E1, E2, E3 and E4 a follows. 

E1 = D1 ⊕ X, 
E2 = D2 ⊕ Y, 
E3 = D3 ⊕ Z, 
E4 = D4 ⊕ W. 

6. Repeat step 4 and 5 until all the give plaintexts be encrypted. 

By Theorem 2, the round of VSC 2.1 be a bijection. The maximum linear probability of VSC 2.1 be 
the same a that of VSC 2.0. The key length of VSC 2.1 be 128bit, it be longer than that of VSC 2.0. 
VSC 2.1 be expect to be faster than VSC 2.0 because step 2(c) be more simple than that of VSC 2.0. 

220 



5. Experiments 
In this section, we perform some experiment for VSC 2.1. 

5.1 Speed 
We measure the speed of perform VSC128, VSC 2.0, VSC 2.1 and AES-128. The environment in 
which we measure be show in Table I. As results, we get Table II. VSC2.1 be slightly slow than the 
original VSC128, but faster than VSC 2.0. 

Table I. Environment on which we measure speed. 

CPU 1.3 GHz Intel Core i5 
Memory 4 GB 1600 MHz DDR3 

OS OS X 10.9.5 (13F34) 
Compiler gcc 4.2.1 

Optimization option -Ofast 

Table II. Encryption speeds. 

Algorithm Speed(Mbps) 

VSC128 1202.254889 
VSC 2.0 1039.222464 
VSC 2.1 1113.193866 

AES-128 ECB 366.901621 

5.2 Property of the preprocessing 
We investigate property of the preprocessing of VSC 2.0 and VSC 2.1. Step 2 of VSC 2.0 algorithm 
and that of VSC 2.1 algorithm be preprocessing, respectively. The detail of the experiment be a 
follows: 

1. Select an input randomly. (We call the input I1.) 

2. Select a bit of I1 and reverse the bit. (We call the value I2.) 

3. Apply the preprocessing to I1 and I2. (We call the output I ′1 and I ′2 respectively.) 

4. Measure the Hamming distance between I ′1 and I 
′ 
2. 

5. Repeat step 1-4 1000000 times. Calculate the average of the Hamming distance which be 
measure at step 3. 

As a result, we get Table III. Since the output length of the both preprocessing be 128bit, the result 
show that the preprocessings have a good property. 

Table III. 

Algorithm Average Hamming distance 

VSC 2.0 64.000107 
VSC 2.1 63.995965 

5.3 Randomness of key stream 
We perform randomness test described by NIST SP800-22 [13] for key stream generate by VSC128, 
VSC 2.0 and VSC 2.1. The test be perform for 11 sets. Each set be construct of 1000 sequences. 
(Exceptionally, the set 10 and 11 be construct of 255 sequence respectively. A sequence of the 
set 10 be generate with an initial condition (key and initial vector) whose one bit be “1” and the 

221 



others be “0”. VSC 2.0 require the least bit of D be “0”. Then, the set 10 be construct of only 255 
sequences. A sequence of the set 11 be generate with an initial condition whose two bit be “0” and 
the others be “1”. One of the two be the least bit of D. Then, set 11 be also construct of only 255 
sequences.) Each sequence be construct of 1000000 bits, which be generate by VSC128, VSC 2.0 
or VSC 2.1 with a secret key and an initial vector. The secret key and the initial vector be chosen 
randomly, but random pattern be dependent on a set. Table IV show the result. The randomness 
test be construct of 188 test items. Even if sequence be exactly random, there be case that the 
sequence do not pas all test items. Therefore, the result show that there be no problem about 
randomness of the key stream of VSC128, VSC 2.0 and VSC 2.1. 

Table IV. Results of randomness tests. 

Numbers of test item which the set pass 
Set No. VSC128 VSC 2.0 VSC 2.1 

1 188 188 187 
2 188 187 188 
3 188 186 188 
4 187 188 188 
5 187 188 188 
6 188 187 188 
7 188 187 188 
8 188 188 187 
9 188 188 188 
10 188 188 188 
11 188 188 188 

6. Conclusion 
We propose further improve of VSC a a certain optimization of cipher design. Our propose 
VSC 2.1 be faster than VSC 2.0. We think that VSC 2.1 be more secure than VSC 2.0 because of the 
follow two reasons. First be that the key length of VSC 2.1 be longer than that of VSC 2.0. Second be 
that any theoretical attack which be report a workable attack for the original VSC128 be not 
workable for VSC 2.1. In particular, VSC 2.1 have the provable security for the distinguish attack 
with linear masking. Thus, VSC 2.1 be a precious example of chaotic cipher which us permutation 
polynomial over a ring of modulo 2w, and suggests that the permutation polynomial over a ring of 
modulo 2w and chaos theory design unpredictability be particularly useful for cryptography. 

References 
[1] K. Umeno, S. Kim, and A. Hasegawa, “128bit VSC specification,” http://www.chaosware.com/ 

vsc128.pdf, 2004. 
[2] R.L. Rivest, “Permutation polynomial modulo 2w,” Finite Fields and their Applications, vol. 7, 

pp. 287–292, 2001. 
[3] H. Tanaka, K. Nemoto, T. Miki, and M. Sato, “Security evaluation of 128bit VSC,” Technical 

Report of IEICE, ISEC2003-144, pp. 179–184, 2004. 
[4] M. Nakamura, T. Nosaka, and T. Kaneko, “A Study on the linear property of basic function in 

VSC128,” Proc. ESS Conf. IEICE, p. 126, 2004. 
[5] T. Nosaka, M. Nakamura, and T. Kaneko, “A study on linear cryptanalysis of VSC128,” Proc. 

ESS Conf. IEICE, p. 127, 2004. 
[6] Y. Tunoo, T. Saito, K. Myao, T. Suzaki, and T. Kawabata, “Distinguishing attack with chosen 

initial vector against VSC128,” SASC Workshop, pp. 212–219, 2004. 
[7] A. Iwasaki and K. Umeno, “Improving security of Vector Stream Cipher,” Nonlinear Theory 

and Its Applications, IEICE, vol. 7, pp. 30–37, 2016. 

222 



[8] D.E. Knuth, “The Art of Computer Programming,” vol. 2, Addison-Wesley, Upper Saddle River, 
1981. 

[9] R. Coveyou, Random Number Generation Is Too Important to Be Left to Chance, Studies in 
Applied Mathematics, III, pp. 70–111, 1970. 

[10] R.L. Rivest, M.J.B. Robshaw, R. Sidney, and Y.L. Yin, “The RC6 block cipher,” https://people. 
csail.mit.edu/rivest/pubs/RRSY98.pdf. 

[11] A. Iwasaki and K. Umeno, “One-stroke polynomial over a ring of modulo 2w,” JSIAM Letters, 
vol. 9, pp. 5–8, 2017. 

[12] A. Iwasaki and K. Umeno, “Three Theorems on odd degree Chebyshev polynomial and more 
generalize permutation polynomial over a ring of module 2w,” arXiv:1602.08238v2, 2016. 

[13] NIST, “A statistical test suite for random and pseudorandom number generator for cryp- 
tographic applications,” Special Publication 800–22 Revision 1a, http://nvlpubs.nist.gov/ 
nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf, 2010. 

223 


