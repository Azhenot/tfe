









































(Cross-)Browser Fingerprinting via OS and 
Hardware Level Features 

Yinzhi Cao 
Lehigh University 

yinzhi.cao@lehigh.edu 

Song Li 
Lehigh University 
sol315@lehigh.edu 

Erik Wijmans† 
Washington University in St. Louis 

erikwijmans@wustl.edu 

Abstract—In this paper, we propose a browser fingerprint 
technique that can track user not only within a single browser 
but also across different browser on the same machine. Specif- 
ically, our approach utilizes many novel OS and hardware level 
features, such a those from graphic cards, CPU, and instal 
write scripts. We extract these feature by ask browser 
to perform task that rely on correspond OS and hardware 
functionalities. 

Our evaluation show that our approach can successfully 
identify 99.24% of user a oppose to 90.84% for state of the 
art on single-browser fingerprint against the same dataset. 
Further, our approach can achieve high uniqueness rate than 
the only cross-browser approach in the literature with similar 
stability. 

I. INTRODUCTION 

Web track be a debatable technique use to remember 
and recognize past website visitors. On the one hand, web 
track can authenticate users—and particularly a combina- 
tion of different web track technique can be use for multi- 
factor authentication to strengthen security. On the other hand, 
web track can also be use to deliver personalize service— 
if the service be undesirable, e.g., some unwanted, target ads, 
such track be a violation of privacy. No matter whether we 
like web track or whether it be use legitimately in the 
current web, more than 90% of Alexa Top 500 website [39] 
adopt web tracking, and it have drawn much attention from 
general public and medium [6]. 

Web track have be evolve quickly. The first- 
generation track technique adopts stateful, server-set iden- 
tifiers, such a cooky and evercookie [21]. After that, 
the second-generation track technique call fingerprint- 
ing emerges, move from stateful identifier to stateless— 
i.e., instead of set a new identifier, the second-generation 
technique explores stateless identifier like plug-in version 
and user agent that already exist in browsers. The second- 
generation technique be often use together with the first to 

†The author contribute to the paper when he be a REU student at Lehigh 
University. 

restore lose cookies. Both first and second generation track 
be constrain in a single browser, and nowadays people 
be develop third-generation track technique that try 
to achieve cross-device track [16]. 

The focus of the paper be a 2.5-generation technique in 
between the second and the third, which can fingerprint a 
user not only in the same browser but also across different 
browser on the same machine. The practice of use multiple 
browser be common and promote by US-CERT [42] and 
other technical people [12]: According to our survey,1 70% 
of study user have instal and regularly use at least two 
browser on the same computer. 

The propose 2.5-generation technique, from the positive 
side, can be use a part of strong multi-factor user au- 
thentications even across browsers. From another angle, just 
a many exist research work on new cyber attacks, the 
propose 2.5-generation track can also help to improve 
exist privacy-preserving works, and we will briefly discus 
the defense of our cross-browser track in Section VII. 

Now, let u put aside the good, the bad and the ugly 
usage of web tracking, and look at the technique itself. To 
fingerprint different browser instal on the same machine, 
one simple approach be to use exist feature that fingerprint 
single browser. Because many exist feature be browser 
specific, the cross-browser stable one be not unique enough 
even when combine together for fingerprinting. That be why 
the only cross-browser fingerprint work, Boda et al. [14], 
adopts IP address a a main feature. However, IP address, 
a a network-level feature, be exclude from modern browser 
fingerprint in the famous Panopticlick test [5] and many 
other related work [10, 20, 26, 32, 34, 36]. The reason be that IP 
address change if allocate dynamically, connect via mobile 
network, or a laptop switch location such a from home to 
office—and be unavailable behind an anonymous network or a 
proxy. 

In the paper, we propose a (cross-)browser fingerprint 
base on many novel OS and hardware level features, e.g., 
these from graphic card, CPU, audio stack, and instal 
write scripts. Specifically, because many of such OS and 
hardware level function be expose to JavaScript via browser 
APIs, we can extract feature when ask the browser to per- 
form certain task through these APIs. The extract feature 
can be use for both single- and cross-browser fingerprinting. 

1More detail about our experiment can be found in Appendix A. 

Permission to freely reproduce all or part of this paper for noncommercial 
purpose be grant provide that copy bear this notice and the full citation 
on the first page. Reproduction for commercial purpose be strictly prohibit 
without the prior write consent of the Internet Society, the first-named author 
(for reproduction of an entire paper only), and the author’s employer if the 
paper be prepared within the scope of employment. 
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA 
Copyright 2017 Internet Society, ISBN 1-1891562-46-0 
http://dx.doi.org/10.14722/ndss.2017.23152 



Let u take WebGL, a 3D component implement in 
browser canvas object, for example. While canvas, especially 
the 2D part, have be use in single-browser fingerprint [9, 
32], WebGL be actually consider a “too brittle and un- 
reliable” even for a single browser by a very recent study 
call AmIUnique [26]. The reason for such conclusion be that 
AmIUnique selects a random WebGL task and do not restrict 
many variables, such a canvas size and anti-aliasing, which 
affect the fingerprint results. 

Contrasting with this conclusion drawn by AmIUnique, we 
show that WebGL can be use not only for single- but also for 
cross-browser fingerprinting. Specifically, we ask the browser 
to render more than 20 task with carefully select computer 
graphic parameters, such a texture, anti-aliasing, light, and 
transparency, and then extract feature from the output of 
these render tasks. 

Our principal contribution be be the first to use many 
novel OS and hardware features, especially computer graphic 
ones, in both single- and cross-browser fingerprinting. Particu- 
larly, our approach with new feature can successfully finger- 
print 99.24% of user a oppose to 90.84% for AmIUnique, 
i.e., state of the art, on the same dataset for single-browser 
fingerprinting. Moreover, our approach can achieve 83.24% 
uniqueness with 91.44% cross-browser stability, while Boda 
et al. [14] exclude IP address only have 68.98% uniqueness 
with 84.64% cross-browser stability. 

Our secondary contribution be that we make several inter- 
esting observation for single- and cross-browser fingerprint- 
ing. For example, we find that the current measurement of 
screen resolution, e.g., the one do in AmIUnique, Panop- 
ticlick [5, 17] and Boda et al. [14], be unstable, because the 
resolution change in Firefox and IE when the user zoom 
in or out the web page. Therefore, we take the zoom level 
into consideration, and normalize the width and height in 
screen resolution. For another example, we find that both 
DataURL and JPEG format be unstable across different 
browsers, because these format be with loss and implement 
differently in multiple browser and the server side a well. 
Therefore, we need to adopt lossless format for server-client 
communication in cross-browser fingerprinting. 

Our work be open-source and available at https://github. 
com/Song-Li/cross browser/, and a work demo be at http: 
//www.uniquemachine.org. 

The rest of the paper be organize a follows. We first 
present all the feature include old one adopt and mod- 
ified from AmIUnique and new one propose by u in 
Section II. Then, we introduce the design of our browser 
fingerprint include the overall architecture, render 
tasks, and mask generation in Section III. After that, we talk 
about our implementation in Section IV, and data collection in 
Section V. We evaluate our approach and present the result in 
Section VI. Next, we discus the defense of our fingerprint 
in Section VII, some ethic issue in Section VIII, and related 
work in Section IX. Our paper concludes in Section X. 

II. FINGERPRINTABLE FEATURES 

In this section, we introduce fingerprintable feature use 
in this paper. We start from feature use in prior works, and 

then introduce some feature that need modification especially 
for cross-browser fingerprinting. Next, we present our newly- 
propose features. 

Although there be no restriction for feature on single- 
browser fingerprinting, our cross-browser feature need to 
reflect the information and operation of the level below the 
browser, i.e., the OS and hardware level. For example, both 
vertex and fragment shaders expose the behavior of GPU and 
it driver in the OS; the number of virtual core be a CPU 
feature; the instal write script be OS-level features. The 
reason be that these feature in the OS and hardware level be 
relative more stable across browsers: all browser be run 
on top of the same OS and hardware. 

Note that if an operation, especially the output of the op- 
eration, be contribute by both the browser and the underlie 
(OS and hardware) levels, we can use it for single-browser 
fingerprinting, but need to get rid of the browser factor in 
cross-browser fingerprinting. For example, when we render an 
image a a texture on a cube, the texture mapping be an GPU 
operation but the image decode be a browser one. Therefore, 
we can only use PNG, a lossless format, for cross-browser 
fingerprinting. For another example, the dynamic compression 
operation of audio signal be perform by both the browser 
and the underlie audio stack, and we need to extract the 
underlie features. Now let u introduce these feature use 
in the paper. 

A. Prior Fingerprintable Features 

In this part of the section, we introduce fingerprintable 
feature that we adopt from state of the art. There be 17 
feature present in the Table I of the AmIUnique paper [26], 
and we have all of them for our single-browser fingerprinting. 
More detailed can be found in their paper. Because many of 
such feature be browser specific, we adopt a subset with 
4 feature for cross-browser fingerprinting, namely screen 
resolution, color depth, list of fonts, and platform. Some of 
these feature need modification and be introduce below. 

B. Old Features with Major Modifications 

One prior feature, screen resolution, need refactoring 
for both single- and cross-browser fingerprinting. Then, we 
introduce another fingerprintable feature, the number of CPU 
virtual cores. Lastly, two prior feature need major modifica- 
tions for cross-browser fingerprinting. 

Screen Resolution. The current measurement of screen resolu- 
tion be via the “screen” object under JavaScript. However, we 
find that many browsers, especially Firefox and IE, change the 
resolution value in proportion to the zoom level. For example, 
if the user enlarges the webpage with “ctrl++” in Firefox and 
IE, the screen resolution be inaccurate. We believe that the 
zoom level need to be consider in both single- and cross- 
browser fingerprinting. 

Specifically, we pursue two separate directions. First, we 
adopt exist work [13] on the detection of zoom level base 
on the size of a div tag and the device pixel ratio, and then 
adjust the screen resolution correspondingly. Second, because 
the former method be not always reliable a acknowledge by 
the inventors, we adopt a new feature, i.e., the ratio between 

2 



screen width and height, which do not change with the zoom 
level. 

In addition to screen resolution, we also find that some 
other properties, such a availHeight, availWidth, availLeft, 
availTop, and screenOrientation, be useful in both single- 
and cross-browser fingerprinting. The first four represent the 
available screen for the browser exclude system areas, such 
a the top menu and the tool bar of a Mac OS. The last one 
show the position of the screen, e.g., whether the screen be 
landscape or portrait, and whether the screen be upside down. 

Number of CPU Virtual Cores. The core number can be ob- 
tained by a new browser feature call hardwareConcurrency, 
which provide the capability information for Web Workers. 
Now, many browser support such feature, but some, especially 
early version of browsers, do not. If not supported, there exsits 
a side channel [1] to obtain the number. Specifically, one can 
monitor the finish time of payload when increase the 
number of web workers. When the finish time increase 
significantly at a certain level of web workers, the limit of 
hardware concurrency be reached, make it useful to finger- 
print the number of cores. Note that, some browsers, such a 
Safari, will cut the number available core to Web Workers 
by half, and we need to double the number for cross-browser 
fingerprinting. 

The number of core be know by the inventor to be 
fingerprintable [2] and this be one of the reason that they 
call it hardwareConcurrency rather than cores. However, the 
feature be never be use or measure in prior art of browser 
fingerprinting. 

AudioContext. AudioContext provide a bundle of audio signal 
processing functionality from signal generation to signal 
filter with the help of audio stack in the OS and the 
audio card. Specifically, exist fingerprint work [18] us 
OscillatorNode to generate a triangle wave, and then feed 
the wave into DynamicsCompressorNode, a signal processing 
module that suppresses loud sound or amplifies quiet sounds, 
i.e., create a compression effect. Then, the process audio 
signal be convert to the frequency domain via AnalyserNode. 

The wave in the frequency domain differs from one browser 
to another on the same machine. However, we find that peak 
value and their correspond frequency be relatively stable 
across browsers. Therefore, we create a list of bin with small 
step on both the frequency and value axes, and map the peak 
frequency and value to the correspond bins. If one bin 
contains a frequency or value, we mark the bin a one and 
otherwise zero: such list of bin serve a our cross-browser 
feature. 

In addition to the wave processing, we also obtain the fol- 
low information from the destination audio device: sample 
rate, max channel count, number of inputs, number of outputs, 
channel count, channel count mode, and channel interpretation. 
Note that to the best of our knowledge, none of exist 
fingerprint work have use such audio device information 
for browser fingerprinting. 

List of Fonts. The measurement in AmIUnique be base on 
Flash plugin, however Flash be disappear very fast, which 
be also mention and acknowledge in their paper. At the time 
of our experiment, Flash have already become little support to 

obtain the font list. Instead, we adopt the side-channel method 
mention by Nikiforakis et al. [36], where the width and 
height of a certain string be measure to determine the font 
type. Note that not all font be cross-browser fingerprintable 
because some font be web specific and provide by browsers, 
and we need to apply a mask show in Section III-C to select 
a subset. Another thing worth note be that we be aware that 
Fifield et al. [20] provide a subset of 43 font for fingerprinting, 
however their work be base on single-browser fingerprint 
and not applicable in our cross-browser scenario. 

C. Newly-proposed Atomic Fingerprintable Features 

In this and next subsection, we introduce our newly- 
propose fingerprintable features. We first start with atomic 
features, and by atomic, we mean that the browser expose 
either an API or a component directly to the JavaScript. Then, 
we will introduce composite features, which usually require 
more than one API and component to collaborate. 

Line, curve, and anti-aliasing. Line and curve be 2D feature 
support by both Canvas (2D part) and WebGL. Anti-aliasing 
be a computer graphic technique use to diminish aliasing 
by smooth jaggies, i.e., jagged or stair-stepped lines, in 
either single line/curve object or the edge of a computer 
graphic model. There be many exist algorithm [4] for 
anti-aliasing, such a first-principles approach, signal pro- 
cessing approach, and mipmapping, which make anti-aliasing 
fingerprintable. 

Vertex shader. A vertex shader, render by GPU and the 
driver, convert each vertex in a 3D model to it coordinate in 
a 2D clip-space. In WebGL, a vertex shader may accept data 
in 3 ways: attribute from buffers, uniform that always stay 
the same, and texture from fragment shader. A vertex shader 
be usually combine with a fragment shader described below 
when render a computer graphic task. 

Fragment shader. A fragment shader, render by GPU and 
the driver a well, process a fragment, such a a triangle 
output by the rasterization, into a set of color and a single 
depth value. In WebGL, fragment shader take data in the 
follow ways: 
• Uniforms. A uniform value stay the same for every pixel 

in a fragment during a single draw call. Therefore, uniform 
be non-fingerprintable features, and we list it here for 
completeness. 
• Varyings. Varyings pas value from the vertex shader to 

the fragment shader that interpolates between these value 
and rasterizes the fragment, i.e., draw each pixel in the 
fragment. The interpolation algorithm varies in different 
computer graphic cards, and thus varyings be fingerprint- 
able. 
• Textures. Given a set of mapping between vertex 

and texture, a fragment shader calculates the color of each 
pixel base on the texture. Due to the limited resolution 
of the texture, the fragment shader need to interpolate 
value for a target pixel base on these pixel in the texture 
surround by the target. The texture interpolation algorithm 
also differs from one graphic card to another, make texture 
fingerprintable. 
Textures in WebGL can be further classify into several 
categories: (1) normal texture, i.e., the texture that we 

3 



introduce above; (2) depth texture, i.e., a texture that 
contains depth value for each pixel; (3) animate texture, 
i.e., a texture that contains video frame instead of static 
images; and (4) compress texture, i.e., a texture that 
accepts compress format. 

Transparency via Alpha Channel. Transparency, a feature 
provide by GPU and the driver, allows the background to be 
intermingle with the foreground. Specifically, alpha channel 
with a value between 0 and 1 composite background and 
foreground image into a single, final one use a compositing 
algebra. There be two fingerprint point in an alpha chan- 
nel. First, we can use one single alpha value to fingerprint the 
compositing algorithm between background and foreground. 
Second, we can fingerprint the change of transparency effect 
when the alpha value increase from 0 to 1. Because some 
graphic card adopt discrete alpha values, some jump may 
be observe in the change of transparency effects. 

Image encode and decoding. Images can be encode and 
compress in different formats, such a JPEG, PNG, and 
DataURL. Some of the formats, such a PNG, be lossless, 
while some, such a JPEG, be compress with loss of 
information. The decompression of a compress image be 
a fingerprintable feature, because different algorithm may un- 
cover different information during decompression. According 
to our study, this be a single-browser feature, and cannot be 
use for cross-browser. 

Installed write script (languages). Writing script (systems), 
or commonly know a write languages, such a Chinese, 
Korean, and Arabic, require the installation of special library 
to display due to the size of the library and locality of the 
languages. Browsers do not provide APIs to access the list of 
instal languages, however such information can be obtain 
via a side channel. Specifically, a browser with a particular 
language instal will display the language correctly, and 
otherwise show several boxes. That is, the existence of box 
can be use to fingerprint the presence of that language. 

D. Newly-proposed Composite Fingeprintable Features 

Now, let u introduce our newly-proposed composite fin- 
geprintable features, which be render by more than one 
browser API or component, and sometimes with additional 
algorithm built atop of browser APIs. 

Modeling and multiple models. Modeling, or specifically 3D 
model in this paper, be a computer graphic process of math- 
ematically describe an object via three-dimensional surfaces. 
The vertex of a model be handle by the vertex shader, 
and the surface by the fragment shader. Different object be 
represent by different models, and may interact with each 
other especially when technique below, such a lighting, exist. 

Lighting and shadow mapping. Lighting be the simulation of 
light effect in computer graphics, and shadow mapping be to 
test whether a pixel be visible under a certain light and add cor- 
respond shadows. There be many type of lighting, such a 
ambient lighting, directional lighting, and point lighting, which 
differ in the source of the light. Additionally, many effect be 
accompany by lights, such a reflection, translucency, light 
tracing, and indirect illumination, when light interact with one 
computer graphic model or multiple models. WebGL do not 

Task 

Manager 

Server 

Client 

Tasks 

Rendering Processing Hashes 

Composition 

Fingerprints 

Browser Info 

Store 

Masks 

Fig. 1: System Architecture 

provide direct APIs for light and shadows, and some WebGL 
library (such a three.js) provide high-level APIs built on 
top of WebGL’s vertex and fragment shaders for light and 
shadows. 

Camera. Camera, or specifically pinhole camera model, map 
3D point in a space onto 2D point in an image. In WebGL, 
a camera be represent by a camera projection matrix handle 
by the vertex and fragment shaders, and can be use to rotate 
and zoom in and out an object. 

Clipping Planes. Clipping restricts the render operation 
within a define region of interest. In 3D rendering, a clip 
plane be some distance away from and perpendicular to the 
camera so that it can prevent render surface that be too 
far from the camera. In WebGL, clip plane be perform 
by the vertex and fragment shaders with additional provide 
algorithms. 

III. DESIGN 

A. Overall Architecture 

Figure 1 show the system architecture. First, the task 
manager at the server side sends various render tasks, such 
a draw curve and lines, to the client side. Note that the 
render task also involve obtain OS and hardware level 
information, like screen resolution and timezone. Then, the 
client-side browser render these task by invoke a specific 
API or a combination of APIs, and produce correspond 
results, e.g., image and sound waves. Then, these results, 
especially images, be convert into hash so that they can 
be conveniently sent to the server. Meantime, the browser also 
collect browser-specific information, such a whether anti- 
aliasing and compress texture be supported, which will be 
use at the server side for fingerprint composition. 

Next, when the server collect all the information from 
the client side, the server will start to composite fingerprints. 
Specifically, a fingerprint be generate from a list of hash 
from the client side and a mask that be a list of one or zero 
correspond to the hash list—we perform an “and” operation 
between the list of hash and the mask, and then generate 
another hash a the fingerprint. The mask for single-browser 
fingerprint be straightforward, a list of all ones. The mask for 
cross-browser fingerprint be composited from two sources. 
First, the collect browser information will contribute to the 
mask: if the browser do not support anti-aliasing, the bit 
value in the mask for all task that involve anti-aliasing be 
zero. Second, we will have a different mask for each browser 
pair, e.g., Chrome vs. Firefox and Chrome vs. Windows Edge. 

4 



In the next two sections, we first introduce our render 
task at client side, and then our fingerprint composition, 
especially how to generate the masks. 

B. Rendering Tasks 

In this section, we introduce different render task 
propose in this work. Before that, let u first present the 
basic canvas set below. The size of the canvas be 256×256. 
The ax of the canvas be define a follows. [0, 0, 0] be the 
middle of the canvas, where x-axis be the horizontal line that 
increase to the right, y-axis be the vertical line that increase 
to the bottom, and z-axis increase when move far from the 
screen. An ambient light with the power of [R: 0.3, G: 0.3, B: 
0.3] on a scale of 1 be present, and a camera be place at the 
location of [0, 0, -7]. These two component be necessary, 
because otherwise the model be entirely black. In the rest of 
the paper, unless specified, such a Task (d) with 2D feature 
and other task with additional lights, we use the same basic 
setting in all the tasks. 

Note that unlike the setting in AmIUnique [26], our canvas 
set be reliable when the condition of the current window 
changes. Specifically, we test three different changes: win- 
dow size, side bar, and zoom-level. First, we manually change 
the window size, and find that the content in the canvas remain 
the same both visually and computationally in term of hash 
value. Second, we zoom in and out the current window, and 
find that the content change visually accord to definition, 
but the hash value remain the same. Lastly, we open a browser 
console a a side bar, and find that the canvas content also 
remain the same similar to change window size. Now let u 
introduce our render task from Task (a) to (r). 

Task (a): Texture. The task in Figure 2(a) be to test the regular 
texture feature in the fragment shader. Specifically, a classical 
Suzanne Monkey Head model [19] be render on a canvas 
with a randomly-generated texture. The texture, a square with 
a size a 256×256, be create by randomly pick a color for 
each pixel. That is, we generate three random value uniformly 
between 0 and 255 for three primary colors—red, green and 
blue—at one pixel, mix three primary color together, and use 
it a the color for the pixel. 

We choose this randomly-generated texture rather than 
a regular one, because this texture have more fingerprintable 
features. The reason be a follows. When a fragment shader 
map a texture to a model, the fragment shader need to 
interpolate point in the texture so that the texture can be 
mapped to every point on the model. The interpolation al- 
gorithm differs from one graphic card to another, and the 
difference be amplify when the texture change drastically 
in color. Therefore, we generate this texture in which color 
change greatly between each pair of adjacent pixels. 

Task (b): Varyings. This task, show in Figure 2(b), be design 
to test the vary feature of the fragment shader on a canvas. 
Different vary color be drawn on six surface of a cube 
model with a specification of the color of four point on each 
surface. We choose this vary color to enlarge the color 
difference and change on each single surface. For example, 
when blue be abundant (such a 0.9 with a scale of 1) on 
one vertex of a surface, the other vertex will lack blue (such 
a 0.1) and have more green or red color. Additionally, a 

camera be place at the location of [0, 0, -5] for the purpose 
of comparison with Task (c). 

Task (b’): Anti-aliasing+Varyings. The task in Figure 2(b’) be 
to test the anti-aliasing feature, i.e., how browser smooth the 
edge of models. Specifically, we adopt the same task in Task 
(b), and add anti-aliasing. If we enlarge Figure 2(b’), we will 
find that the edge of both model be smoothed. 

Task (c): Camera. The task in Figure 2(c) be to test the camera 
feature, i.e., a projection matrix fed into the fragment shader. 
Every set in this task be the same a Task (a) except for 
the camera, which be move to a new location of [-1, -4, -10]. 
The same cube look small than the one in Task (a), because 
the camera be move further from the cube (the z-axis be -10 
a oppose to -5). 

Task (d): Lines and Curves. The task in Figure 2(d) be to 
test line and curves. One curve and three line with different 
angle be drawn on a canvas. Specifically, the curve obeys 
the follow function: y = 256 − 100cos(2.0πx/100.0) + 
30cos(4.0πx/100.0) + 6cos(6.0πx/100.0), where [0, 0] be 
the left and top of the canvas, x-axis increase to the right, 
and y-axis increase to the bottom. The start and end 
point of three line be {[38.4, 115.2], [89.6, 204.8]}, {[89.6, 
89.6], [153.6, 204.8]}, and {[166.4, 89.6], [217.6, 204.8]}. 
We choose these specific line and curve so that we can test 
different gradient and shapes. 

Task (d’): Anti-aliasing+Lines and Curves. Task (d’) be an anti- 
aliasing version of Task (d). 

Task (e): Multi-models. The task in Figure 2(e) be to test how 
different model influence each other in the same canvas. In 
addition to the Suzanne model, we introduce another model 
that look like a single-person arm sofa (called sofa model), 
and put two model in parallel. Another randomly-generated 
texture follow the same procedure described in Task (a) be 
mapped to the sofa model. 

Task (f): Light. The task in Figure 2(f) be to test the interaction 
of a diffuse, point light and the Suzanne model. A diffuse, point 
light cause diffuse reflection when illuminate an object. 
Specifically, the light be white with the same value across 
RGB, the power of the light be 2 for each primary color, and 
the light source be locate at [3.0, -4.0, -2.0]. 

We choose a white light source in this task because the 
texture be colorful, and a single-color light may diminish some 
subtle difference on the texture. The power of the light be also 
carefully chosen, because a very weak light will not illuminate 
the Suzanne model, make it invisible, but a very strong light 
will make everything white and diminish all the fingerprintable 
features. In a small scale experiment with 6 machines, when 
increase the power from 0 to 255, we find that when the 
light power be 2, the pixel difference among these machine 
be the maximum. The light position be randomly chosen and 
do not affect the feature fingerprint results. 

Task (g): Light and Models. The task in Figure 2(g) be to test 
the interaction of a single, diffuse, point light and two models, 
because one model may create a shadow on another when 
illuminate by a point light. Every set of light be the same 
a Task (f), and the model be the same a Task (e). 

5 



(a) Texture (b) Varyings (b’) Anti-aliasing (c) Camera (d) Lines&Curves (e) Multi-models (f) Light 

(g) Light&Models (h) Specular Light (i) Two Textures (j) Alpha (0.09–1) (k) Complex Lights (l) Clipping Plane (m) Cubemap Texture 

(n) DDS Textures (o) PVR Textures (p) Float Texture (q) Video (r) Writing Scripts (Systems) 

Fig. 2: Client-side Rendering Tasks for the Purpose of Fingerprinting 

Task (h): Specular Light. The task in Figure 2(h) be to test 
the effect of a diffuse point light with another color and a 
specular point light on two models. Similar to diffuse point 
light, a specular point light will cause a specular reflection on 
an object. Specifically, both light be locate at [0.8, -0.8, - 
0.8], the RGB of the diffuse point light be [0.75, 0.75, 1.0], 
and the RGB of the specular light be [0.8, 0.8, 0.8]. 

There be two thing worth noting. First, we choose the 
specific camera location because it be closer to the model and 
have big effects. Particularly, one may notice the spot on the 
back of the sofa model illuminate by the specular point light. 
Second, although the color of the diffuse point light be towards 
blue, but still have much red and green. We want to test other 
colors, but white light be still the best for fingerprint give 
that the texture be colorful. 

Task (h’): Anti-aliasing+Specular Light. Task (h’) be an anti- 
aliasing version of Task (h). 

Task (h”): Anti-aliasing+Specular Light+Rotation. Task (h’) 
be the same a Task (h’) but with 90 degree rotation. 

Task (i): Two Textures. The task in Figure 2(i) be to test the 
effect of mapping two different texture to the same objects. 
On top of Task (h), i.e., every other set be the same, we 
map another layer of randomly-generated texture to both the 
Suzanne and sofa model. 

Task (j): Alpha. The task in Figure 2(j) consist of 8 sub-tasks 
be to test the effect of different alpha values. Specifically, we 
put the Suzanne and sofa model in parallel, and change the 
alpha value chosen from this specific set, {0.09, 0.1, 0.11, 
0.39, 0.4, 0.41, 0.79, 1}, where 0 mean completely transparent 
and 1 no transparency. 

Again, there be two thing worth noting. First, we choose 
this value set carefully to reflect different alpha value and 
small value changes: three representative value {0.1, 0.4, 
0.8} a well a their nearby value be selected. Values be 

augment in 0.01, because many GPUs do not accept small 
steps. Second, the Suzanne and sofa model be position so 
that they be partially overlap and the hidden structure of 
the sofa model be visible when the model becomes transparent. 
For example, the arm of the sofa model be partially visible 
when view from the back of the model. 

Task (k): Complex Lights. The task in Figure 2(l) be to test 
complex light features, such a reflection, move lights, and 
light trace among multiple models. Specifically, we generate 
5,000 metallic ring model with different angle randomly 
place on the ground and pile together. For reliability, we use 
a seed random number generator with the same random seed 
every time so that the test can be repeat on different browser 
and machines. Two point light sources, yellow and red, towards 
the bottom be circle around in the right top corner of the 
entire scene. When light illuminate the ring underneath, other 
ring also get illuminate through reflection and two color 
from different source be intermingle together. 

Note that we choose single-color light source because the 
model be not colorful, and light with color will illuminate 
more detail on the rings. Furthermore, light with different 
color will interact with each other and create more detailed 
effects. 

Task (k’): Anti-aliasing+Complex Lights. Task (k’) be an anti- 
aliasing version of Task (k). 

Task (l): Clipping Plane. The task in Figure 2(n) be to test 
the movement of a clip plane and the FPS. Specifically, 
we put a static positive tetrahedron on the ground, illuminate 
it with collimate light, and move the clip plane so that 
the observer feel that the tetrahedron be moving. The capture 
image in Figure 2(n) be upside down when the clip plane 
move to that position. 

Task (m): Cubemap Texture+Fresnel Effect. The task in Fig- 
ure 2(n) be to test cubemap texture and fresnel effect in 

6 



light reflection. Particularly, cubemap texture [7] be a special 
texture that utilizes the six face of a cube a the map 
shape, and fresnel effect be an observation that the amount 
of reflect light depends on the view angle. We create a 
cubemap texture with a normal campus scene, and put several 
transparent bubble on top of the texture for the fresnel effect. 
All the bubble be move randomly and bumping to each 
other in animation. 

Task (n): DDS Textures. DDS Textures refer to those that use 
DirectDraw Surface file format, a special compress data 
format with the S3 Texture Compression (S3TC) algorithm. 
There be five different variation of S3TC from DXT1 to 
DXT5, and each format have an option to enable mipmapping, 
a technique to scale high-resolution texture into multiple 
resolution within the texture file. Because DXT2 be similar 
to DXT3 and DXT4 similar to DXT5, Task (p) only test 
DXT1, DXT3, and DXT5 with and without mipmapping in 
each column a show in Figure 2(p). For comparison, we 
also include an uncompressed texture with ARGB format in 
the rightmost column. There be two gray cube in Figure 2(p) 
because DXT3 and DXT5 with mipmapping be unsupported on 
that specific machine. 

Task (o): PVR Textures. PVR texture, or call PVRTC texture, 
be another texture compression format adopt mostly by 
mobile devices, such a all iPhone, iPod Touch, and iPad a 
well a some Android products. Based on the size of data 
blocks, there be two modes: 4 bit mode and 2 bit mode. 
Further, there be two popular versions, v1 and v3, and we 
can choose to enable mipmapping a well. In total, Task (q), 
show in Figure 2(q), have 8 subtasks that enumerate different 
combination of bit mode, version, and mipmapping. Similarly, 
a gray cube mean that the format be not supported. 

Task (p): Float Textures. Float texture, or call float point 
texture, us float point instead of integer to represent 
color values. A special type of float point texture be depth 
texture that contains the data from the depth buffer for a 
particular scene. Task (r), show in Figure 2(r), be adopt 
from an exist online test [15] for the purpose of render 
float and depth textures. 

Task (q): Video (Animating Textures). The task in Figure 2(s) 
be to test the decompression of videos. Specifically, we create 
a two-second static scene video from a PNG file with three 
different compression format (namely WebM, high quality 
MP4, and standard MP4), map the video a an animate 
texture to a cube, and capture six consecutive frame from the 
video. 

Note that although all the video be create with one 
single PNG file, the capture frame be different because the 
compression algorithm be with loss. We choose six consecutive 
frame because JavaScript only provide an API to obtain 
frame at a certain time but not with certain frame numbers— 
six consecutive frame can make sure that the target frame be 
within the set base on our experiment. 

Task (r): Writing Scripts. The task in Figure 2(t) be to obtain 
the list of support write scripts, such a Latin, Chinese, 
and Arabic, in a browser. Because none of exist browser 
provide an API to obtain the list of support write scripts, 
we adopt a side channel to test the existence of each write 
script. Specifically, the method be a follows. The name of 

Algorithm 1 Cross-browser Mask Generation 
Input: 

M : the set of all possible masks. 
Hbrowser,machine = {Hashtask1, Hashtask2, Hashtask3, ...} : the hash 
list for all the render task on one browser of a specific machine. 
Hbrowser = {Hbrowser,machine1, Hbrowser,machine2, ...} : the hash list 
for a browser. 
HS = {Hchrome, Hfirefox, Hopera, ..} : the overall hash list. 

Process: 
1: for all possible {hbrowser1, hbrowser2} ⊂ HS do 
2: Maxuniq ← 0 
3: Maxmask ← null 
4: for mask in M do 
5: FS ← {} 
6: Count← 0 
7: for m1 ∈ hbrowser1 and m2 ∈ hbrowser2 do 
8: if m1&mask == m2&mask and m1&mask /∈ FS then 
9: Count + + 

10: FS.add(m1&mask) 
11: end if 
12: end for 
13: Uniq ← Count/size(hbrowser1) 
14: if Uniq > Maxuniq then 
15: Maxuniq ← Uniq 
16: Maxmask ←Mask 
17: end if 
18: end for 
19: Maxmask be the mask for browser 1 and 2. 
20: end for 

each write script in it own language be render in the 
browser. If the write script be supported, the render will 
succeed; otherwise, a set of box will be show instead of 
the script. Therefore, we can detect the box to test whether 
the browser support the script: For example, Figure 2(t) show 
that Javanese, Sudanese, Lontara and Thaana be not support 
in that specific test browser. Our current test list have 36 
write script obtain from Wikipedia [8] and ranked by 
their popularity. 

C. Fingerprints Composition 

In this section, we present how to form a fingerprint 
at the server side base on the hash from the client-side 
render tasks. As mentioned, a fingerprint be a hash compute 
from an “and” operation of the hash list of all the task and 
a mask. The mask be straightly all one for single-browser 
fingerprinting, and compute from two sub-masks for cross- 
browser fingerprinting. We have talk about the first sub-mask 
compute from the fact whether a browser support certain 
functionality in Section III-A, and now will discus the 
second sub-mask, which differs for every browser pair. 

The generation of the mask for every two browser be a 
training-based approach. Specifically, we use a small subset to 
obtain a mask that optimizes both the cross-browser stability 
and the uniqueness. Note that similar to false positive and 
negative, these two numbers, i.e., cross-browser stability and 
uniqueness, be two side of a coin: When the cross-browser 
stability increases, uniqueness decrease, and vice versa. Let 
u think about two extreme examples. If we use single- 
browser features, the cross-browser stability be zero but the 
uniqueness be the highest. At contrast, if we use only one 
feature, e.g., platform, the cross-browser stability be 100% but 
the uniqueness be very low. 

Algorithm 1 show the training procedure of the mask for 
every browser pair. We adopt a brute-force search: though not 
the most efficient but the most effective and complete. Due to 

7 



the small size of the training data, we realize that brute force 
be possible and produce the best result. Specifically, we first 
enumerate every browser pair (Line 1), and then every possible 
mask (Line 4). For each mask, we go through the training data 
(Line 7), and make sure to select the mask that maximizes the 
cross-browser stability multiply the uniqueness (Line 8–11 
and 14–17). 

IV. IMPLEMENTATION 

Our open-source implementation, exclude all the open- 
source library (e.g., three.js, a JavaScript 3D library, and 
glMatrix, a JavaScript library for matrix operations), have 
approximately 21K Lines of Code (LoC). Specifically, our 
approach involves approximately 14K line of JavaScript, 1K 
line of HTML, 2.4K line of Coffeescript, 500 line of C 
code, and 3.7K line of Python code. 

We now divide our code into client and server, and describe 
below. The client-side code have a manager in JavaScript that be 
generate from Coffeescript. The manager performs three jobs: 
(1) load all the render tasks, (2) collect all the result 
from the render task a well a browser information, and 
(3) send the result to a snippet of JavaScript that performs 
hash and then communicates with the server-side code. Tasks 
(n) and (o) be write in C and convert to JavaScript via 
Emscripten. All other render task be write in JavaScript 
directly: Tasks (k)–(m) be write with the help of three.js, and 
the rest task be directly use either WebGL or JavaScript 
APIs. All render task have use glMatrix for vector and 
matrix operations. 

The server side of our implementation be write in Python, 
serve a a module of an Apache server. Our server-side code 
can be further divide into two parts: the first with 1.2K LoC 
for communicate with the client-side code and store hash 
into a database and image into a folder, and the second with 
2.5K LoC for the analysis such a generate and apply 
mask on the collect fingerprints. 

V. DATA COLLECTION 

We collect data from two crowdsourcing websites, namely 
Amazon Mechanical Turks and MacroWorkers. Specifically, 
we instruct crowdsourcing worker to visit our website via 
two different browser at their own choice, and if they visit 
the website via three browsers, they will get paid by a bonus. 
After visiting, our website will provide a unique code for each 
worker so that she can input it back to the crowdsourcing 
website to get paid and optional bonus. Note that in our data 
collection, in addition to hashes, we also send all the image 
data to the server—such a step be not need if deploy our 
approach. 

To ensure that we have the ground truth data, we insert a 
unique identifier a part of the URL that each crowdsourcing 
worker visits, e.g., http://oururl.com/?id=ABC. The unique 
identifier be store at the client-side browser a a cookie so 
that if the user visit our website again, she will get the same 
identifier. Additionally, we allow one crowdsourcing worker to 
take the job only once. For example, the number of Human 
Intelligence Tasks (HITs) in MTurks be one for each worker. 

In total, we have collect 3,615 fingerprint from 1,903 
user within three months. Some user just visit our website 

TABLE I: Normalized Entropy for Six Attributes of the Dataset 
Collected by Our Approach, AmIUnique, and Panopticlick 
(The last two column be copy from the AmIUnique paper) 

Ours AmIUnique Panopticlick 

User Agent 0.612 0.570 0.531 
List of Plugins 0.526 0.578 0.817 
List of Fonts (Flash) 0.219 0.446 0.738 
Screen Resolution 0.285 0.277 0.256 
Timezone 0.340 0.201 0.161 
Cookie Enabled 0.001 0.042 0.019 

with one browser and do not finish the two-browser task. We 
use all the fingerprint directly for single-browser fingerprint- 
ing. For cross-browser fingerprinting, the dataset be divide 
equally into ten part for each browser pair if there be enough 
data: one for the generation of masks, and the other nine for 
testing. 

A. Comparing Our Dataset with AmIUnique and Panopticlick 

The purpose of this part of the section be to compare 
our dataset with AmIUnique and Panopticlick in the metric 
of normalize Shannon’s entropy invent in the AmIUnique 
paper. Specifically, Equation 1 show the definition accord 
to their paper: 

NH = 
H(X) 

HM 
= 
− 
∑ 

i P (xi)log2P (xi) 

log2(N) 
(1) 

H(X) be the Shannon’s entropy where X be a variable with 
possible value {x1, xi, ..} and P(X) a probability function. 
HM be the bad case scenario in which every fingerprint have 
the same probability and we have the maximum entropy. N be 
the total number of fingerprints. 

Table I show the comparison result where the statistic 
for AmIUnique and Panopticlick be obtain from Table III of 
the AmIUnique paper. We observe that the normalize entropy 
value of our dataset be very similar to datasets use in past 
approach except for list of font and timezone. 

First, the normalize entropy of list of font drop 0.22 
from AmIUnique and 0.52 from Panopticlick. The reason a 
explain by AmIUnique be that Flash be disappearing. By 
the time that we collect data, the percentage of browser 
with Flash support decrease even more when compare with 
AmIUnique. To further validate our dataset, we also calculate 
the normalize entropy for the list of font collect by 
JavaScript. The value be 0.901, very close to the one from 
Panopticlick. 

Second, the normalize entropy of timezone increase 
0.139 from AmIUnique and 0.179 from Panopticlick. The 
reason be that our crowdsourcing worker from MicroWorkers 
be very international, span from Africa and Europe to 
Asia and Latin America. Specifically, MicroWorkers allow u 
to create campaign target different region all over the 
world, and we do create campaign for each continental. 

Another thing worth note be that the normalize entropy 
of cookie enable be almost zero for our dataset. The reason 
be that we collect data from crowdsourcing websites, where 

8 



TABLE II: Overall Results Comparing AmIUnique, Boda et al. 
exclude IP Address, and Our Approach (“Unique” mean the 
percentage of unique fingerprint out of total, “Entropy” the 
Shannon entropy, and “Stability” the percentage of fingerprint 
that be stable across browsers. We do not list cross-browser 
number for AmIUnique and single-browser number for Boda 
et al. in the table, because these number be very low and their 
approach be not design for that purpose. ) 

Single-browser Cross-browser 

Unique Entropy Unique Entropy Stability 

AmIUnique [26] 90.84% 10.82 
Boda et al. [14] 68.98% 6.88 84.64% 
Ours 99.24% 10.95 83.24% 7.10 91.44% 

worker need to get paid with cookie enabled. If they disable 
cookies, they cannot even log into the crowdsourcing website. 
At contrast, both AmIUnique and Panopticlick attract general 
web user in which a small percentage may disable cookies. In 
general, there be very few people disable cookies, because 
cooky be essential for many modern web functionalities. 

VI. RESULTS 

In this section, we first give an overview of our results, 
and then break down the result by different browser pair 
and features. Lastly, we present some interest observation. 

A. Overview 

We first give an overview of our result for both single- 
and cross-browser fingerprinting. Specifically, we compare our 
single-browser fingerprint with AmIUnique, state of the art, 
and our cross-browser fingerprint with Boda et al. exclude 
IP address. Note that although many new features, e.g., these 
in AmIUnique, emerge after Boda et al., these feature be 
browser specific and we find that the feature use in Boda et 
al. be still the one with the high cross-browser stability. 

We now introduce how we reproduce the result for these 
two works. AmIUnique be open-source [3], and we can directly 
download the source code from github. Boda et al. provide 
an open test website (https://fingerprint.pet-portal.eu/), and 
we can download the fingerprint JavaScript directly. We 
believe that the direct usage of their source code minimizes 
all the possible implementation biases. 

The overall result of AmIUnique, Boda et al., and our 
approach be show in Table II. Let u first take a look at 
single-browser fingerprinting. We compare our approach with 
AmIUnique in term of uniqueness and entropy. Uniqueness 
mean the percentage of unique fingerprint over the total 
number of fingerprints, and entropy be the Shannon entropy. 
The evaluation show that our approach can uniquely identify 
99.24% of user a oppose to 90.84% for AmIUnique, 
counting to 8.4% increase. For the entropy, the maximum 
value be 10.96, and both approaches, especially ours, be very 
close to the maximum. That is, non-unique fingerprint in both 
approach be scatter in small anonymous groups. 

Then, let u look at the metric for cross-browser finger- 
printing. In addition to uniqueness and entropy, we also cal- 
culate another metric call cross-browser stability, meaning 

the percentage of fingerprint that be stable across different 
browser on the same machine. Although we select feature 
that be stable across browser most of time, fingerprint 
from different browser might still differ. For example, screen 
resolution could be different for Boda et al., if the user 
chooses different zoom level in two browsers. For another 
example, GPU render might be different for our approach, 
if one browser adopts hardware render but another software 
rendering. 

Now let u look at the cross-browser fingerprint result 
for Boda et al. and our approach. Table II show that our 
approach can identify 83.24% of user a oppose to 68.98% 
for Boda et al. This be a huge increase with 14.26% difference. 
The cross-browser stability also increase from 84.64% for 
Boda et al. to 91.44% for our approach. One of the reason be 
that we make exist features, such a screen resolution and 
the list of fonts, more stable across different browsers. The 
entropy also increase from 6.88 for Boda et al. to 7.10 for 
our approach. 

B. Breakdown by Browser Pairs 

In this part of the section, we break down our result by 
different browser pair show in Table III. There be six differ- 
ent type of browsers, and a category call others include 
some uncommon browsers, such a Maxthon, Coconut, and 
UC browser. The table be a low triangular matrix due to 
it symmetric property: If we list all the numbers, the upper 
triangle be exactly the same a the lower. The main diagonal of 
the table represent single-browser fingerprinting, and the other 
part cross-browser. There be two N/A because Apple give up 
the support of Safari on Windows, and Microsoft never support 
Internet Explorer and Edge Browser on Mac OS, i.e., Safari 
do not co-exist with IE and Edge. There be two dash a 
well for others and Edge/IE/Safari, because we do not observe 
any such pair in our dataset. 

Let u first look at the main diagonal. The stability for 
single browser be obviously 100% because we be compare 
a browser to itself. The browser with low uniqueness be 
Mozilla Firefox, because Firefox hide some information, 
e.g., the WebGL render and vendor, for privacy reasons. The 
uniqueness for IE and Edge be 100%, show that both 
browser be highly fingerprintable. The uniqueness for Opera, 
Safari, and other browser be also 100%, but due to the small 
number of sample in our dataset, we cannot draw further 
conclusion for these browsers. 

Then, we look at the low triangle of the matrix except the 
main diagonal, which show the uniqueness and stability for 
cross-browser fingerprinting. First, the cross-browser stability 
for all pair be very hight (> 85%) except for other browser 
and Opera vs. IE. Because the number of such pair be small, it 
be hard for u to generate a mask with reasonable cross-browser 
stability. 

Second, the uniqueness for IE and Edge vs. the rest be rela- 
tively low when compare with other pairs. The reason be that 
both IE and Edge be independently implement by Microsoft 
with few open-source libraries. That is, the common part 
share between IE/Edge and the rest be much less than these 
among the rest browsers. At contrast, the uniqueness between 

9 



TABLE III: Cross-browser Fingerprinting Uniqueness and Stability Break-down by Browser Pairs 

Browser Chrome Firefox Edge IE Opera Safari Other 

Chrome 99.2% (100%) 
Firefox 89.1% (90.6%) 98.6% (100%) 
Edge 87.5% (92.6%) 97.9% (95.9%) 100% (100%) 
IE 85.1% (93.1%) 91.8% (90.7%) 100% (95.7%) 100% (100%) 
Opera 90.9% (90.0%) 100% (89.7%) 100% (100%) 100% (60.0%) 100% (100%) 
Safari 100% (89.7%) 100% (84.8%) N/A N/A 100% (100%) 100% (100%) 
Other 100% (22.2%) 100% (33.3%) - - 100% (50%) - 100% (100%) 

Note: The format of each cell be a follow – Uniqueness (Cross-browser Stability). 

IE and Edge be very high: 100% uniqueness with 95.7% cross- 
browser stability, meaning that IE and Edge probably share a 
considerable amount of code. 

Third, it be interest to compare IE and Edge. The 
uniqueness of Edge Browser be high than IE for all browser 
pairs. The reason be that Edge Browser introduces more func- 
tionalities, such a a full implementation of WebGL obey 
the standard, which expose more fingerprint aspects. 

C. Breakdown by Features 

In this part of the section, we break down our result 
by different feature and show it in Table IV. Specifically, 
Table IV can be divide into two parts: the first part above 
AmIUnique row show the feature adopt by AmIUnique, 
the second part below the first show all the new feature 
propose by our approach. Now let u look at different 
features. 

1) Screen Resolution and Ratio: The single-browser en- 
tropy for screen resolution and ratio be 7.41, while the entropy 
for the width and height ratio drop significantly to 1.40. 
The reason be that many resolutions, e.g., 1024×768 and 
1280×960, share the same ratio. The cross-browser stability 
for screen resolution be very low (9.13%), because user often 
zoom in and out the web page a mention before. The 
cross-browser stability for the width and height ratio be high 
(97.57%) but low than 100%, because some user adopt two 
screen and put two browser in separate ones. 

2) List of Font: Due to the ongoing disappearance of Flash, 
the entropy for the list of font obtain from Flash be a low 
a 2.40, and at contrast the entropy for the list from JavaScript 
be a high a 10.40. That mean the list of font be still a highly 
fingerprintable feature, and we need to obtain the feature use 
JavaScript in the future. 

Note that although the entropy for the font list from 
JavaScript be high, it do not take a significant portion in 
our fingerprinting. When we remove this feature, the single- 
browser uniqueness of our approach only drop from 99.24% 
to 99.09%, less than 0.2% difference. That is, our approach 
can still fingerprint user with high accuracy without the font 
list feature. 

3) Anti-aliasing: Tasks (b), (b’), (d), (d’), (h), (h’), (k) 
and (k’) be related to anti-aliasing. The entropy for single- 
browser fingerprint increase for (b), (d) and (h) when anti- 
aliasing be added, but decrease for (k). The reason be that 
(b), (d) and (h) have few edges, and anti-aliasing will add 

more fingerprintable contents; at contrast, (k) contains many 
small edge on each of the beans, and anti-aliasing will occupy 
the content of the bean and diminish some fingerprintable 
content inside of the beans. 

Now let u look at cross-browser fingerprinting. The cross- 
browser stability be the opposite of the single-browser entropy: 
it decrease for (b), (d) and (h), but increase for (k). The 
reason be that anti-aliasing be not support for all browser on 
the same machine, make the stability decrease for (b), (d) and 
(h). For similar reason, because anti-aliasing diminishes some 
fingerprintable content inside the bean, the cross-browser 
stability increase for (k). 

4) Line&Curves: Task (d) test the effect of line and 
curves. The entropy be low (1.09) and the cross-browser stabil- 
ity be high (90.77%), because both line and curve be simple 
2D operation and do not differ too much across browser and 
machines. We manually compare those case that be different 
across machine or browsers, and find that the major difference 
lie in the start and end point where there be one or two 
pixel shifting. 

5) Camera: When compare the single-browser entropy 
for Task (b) and (c), we find that the entropy decrease when 
a camera be added. The reason be that the purpose of the 
add camera be to zoom out the cube, which diminishes subtle 
difference on the surface. The cross-browser stability for (b) 
and (c) be very similar due to the similarity between (b) and 
(c). 

6) Texture: Let u first compare normal, DDS, PVR, cube- 
map and float textures. The entropy for float and cubemap 
texture be high than all other textures, because float and 
cubemap texture have more information, e.g., the depth in 
float texture and a cube mapping for cubemap textures. 
The entropy for PVR texture be very low (0.14), because 
PVR texture be mostly support on Apple mobile devices, 
such a iPhones and iPads. As our dataset be collect from 
crowdsourcing workers, very few of them will use Apple 
mobile device to perform the crowdsourcing tasks. Another 
interest observation be that the cross-browser stability for 
DDS texture be low (68.18%). The reason be that DDS, a 
Microsoft format, be unsupported on many browsers. 

Second, let u look at two textures, i.e., Task (i). Compared 
with Task (h), another layer of texture be added, but the entropy 
for both single- and cross-browser fingerprint decrease. 
The reason be that the texture use in our task be carefully 
create so that it can contain more fingerprintable features. 

10 



TABLE IV: Entropy and Cross-browser Stability by Features 

Feature 
Single-browser Cross-browser 

Entropy Entropy Stability 

User agent 6.71 0.00 1.39% 
Accept 1.29 0.01 1.25% 
Content encode 0.33 0.03 87.83% 
Content language 4.28 1.39 10.96% 
List of plugins 5.77 0.25 1.65% 
Cookies enable 0.00 0.00 100.00% 
Use of local/session storage 0.03 0.00 99.57% 
Timezone 3.72 3.51 100.00% 
Screen resolution and color depth 7.41 3.24 9.13% 
List of font (Flash) 2.40 0.05 68.00% 
List of HTTP header 3.17 0.64 9.13% 
Platform 2.22 1.25 97.91% 
Do Not Track 0.47 0.18 82.00% 
Canvas 5.71 2.73 8.17% 
WebGL Vendor 2.22 0.70 16.09% 
WebGL Renderer 5.70 3.92 15.39% 
Use of an Ad blocker 0.67 0.28 70.78% 

AmIUnique 10.82 0.00 1.39% 

Screen Ratio 1.40 0.98 97.57% 
List of font (JavaScript) 10.40 6.58 96.52% 
AudioContext 1.87 1.02 97.48% 
CPU Virtual core 1.92 0.59 100.00% 
Normalized WebGL Renderer 4.98 4.01 37.39% 
Task (a) Texture 3.51 2.26 81.47% 
Task (b) Varyings 2.59 1.76 88.25% 
Task (b’) Varyings+anti-aliasing 3.24 1.66 73.95% 
Task (c) Camera 2.29 1.58 88.07% 
Task (d) Lines&Curves 1.09 0.42 90.77% 
Task (d’) (d)+anti-aliasing 3.59 2.20 74.88% 
Task (e) Multi-models 3.54 2.14 81.15% 
Task (f) Light 3.52 2.27 81.23% 
Task (g) Light&Model 3.55 2.14 80.94% 
Task (h) Specular light 4.44 3.24 80.64% 
Task (h’) (h)+anti-aliasing 5.24 3.71 70.35% 
Task (h”) (h’)+rotation 4.01 2.68 75.09% 
Task (i) Two texture 4.04 2.68 75.98% 
Task (j) Alpha (0.09) 3.41 2.36 86.25% 
Task (j) Alpha (0.10) 4.11 3.02 75.31% 
Task (j) Alpha (0.11) 3.95 2.84 75.80% 
Task (j) Alpha (0.39) 4.35 3.06 82.75% 
Task (j) Alpha (0.40) 4.38 3.10 82.58% 
Task (j) Alpha (0.41) 4.49 3.13 81.89% 
Task (j) Alpha (0.79) 4.74 3.12 72.63% 
Task (j) Alpha (1) 4.38 3.07 82.75% 
Task (k) Complex light 6.07 4.19 66.37% 
Task (k’) (k)+anti-aliasing 5.79 3.96 74.45% 
Task (l) Clipping plane 3.48 1.93 76.61% 
Task (m) Cubemap texture 6.03 3.93 58.94% 
Task (n) DDS texture 4.71 3.06 68.18% 
Task (o) PVR texture 0.14 0.00 99.16% 
Task (p) Float texture 5.11 3.63 74.41% 
Task (q) Video 7.29 2.32 5.48% 
Task (r) Writing script (support) 2.87 0.51 97.91% 
Task (r) Writing script (images) 6.00 1.98 5.48% 

All cross-browser feature 10.92 7.10 91.44% 
All feature 10.95 0.00 1.39% 

When we add two texture together, some of these feature 
be diminished, make two-texture task less fingerprintable. 

7) Model: Let u compare Tasks (a) and (e) a well a 
Tasks (f) and (g) for the effect of models. Compared to (a) 
and (f), a sofa model be add to (e) and (g), and the entropy 
increase a little bit, i.e., 0.03 for both tasks. The conclusion 
be that the Sofa model do introduce more fingerprintable 
feature but the increase be very limited. 

8) Light: Tasks (a), (e), (f), (h), and (k) be related to 
lights. Let u first look at Task (f) in which a diffuse, point 
light be add to Task (a). The entropy only increase 0.01 
for both single- and cross-browser fingerprinting, show that 
the diffuse, point light have little impact in fingerprinting. As a 
comparison, the effect of a specular light be more apparent 
because the entropy for Task (h) be an increase of >0.9 
when compare to Task (e) in both single- and cross-browser 
fingerprinting. Lastly, let u look at Task (k), a complex light 
example. The entropy for Task (k) be the high among all 
task except for video, because there be 5,000 model and 
light with different color be reflect among all the model 
and intermingle together. 

9) Alpha: Task (j) test alpha value from 0.09 to 1. It 
be interest that different alpha value have very different 
entropies. In general, the trend be that when the alpha value 
increases, the entropy increase a well but with many fall- 
backs. We do not test continuous alpha value in our large- 
scale experiment, but perform a small-scale one among five 
machines. Specifically, we compare the differ pixel between 
each Alpha value image and a standard one, and find that 
the fallback be mainly cause by software rendering, which 
approximates alpha values. Additionally, we observe some 
pattern in the fallbacks, which happens in an approximate 
0.1 incremental step. 

10)Clipping Planes: Task (l) be to test the effect of clip 
planes, yield 3.48 single-browser entropy and 1.93 cross- 
browser entropy with 76.61% stability. The entropy be similar 
to the one with pure texture, because clip plane be im- 
plemented in JavaScript and do not contribute to fingeprinting 
much. 

11) Rotation: Task (h”) be a rotation of Task (h’). The 
entropy decrease and the cross-browser stability increases. 
The reason be that the front of the Suzanne model and the 
inside of the sofa model have more details. When we rotate both 
model to another angle, the fingerprintable detail decrease 
and correspondingly the stability increases. 

12) AudioContext: The AudioContext that we measure be 
the cross-browser stable one, i.e., the destination audio device 
information and the convert waves. The entropy be 1.87, 
much small than the entire entropy of the entire wave— 
which be 5.4 a measure by Englehardt et al. [18]. 

13)Video: Task (q) be test the video feature. The entropy 
for video be the high (7.29) among all of render tasks, 
because decode video be a combination of the browser, the 
driver, and sometimes the hardware a well. At contrast, the 
cross-browser stability for video be very low (5.48%) and the 
entropy also drop to 2.32. The reason be that similar to image 
encode and decoding, both WebM and MP4 video format 
be with loss and decode by the browser. We do not find a 
universal lossless format for video a we do for images. 

11 



14) Writing Scripts: Writing script be test in Task (r). 
We further divide Task (r) into two part for the purpose of 
cross-browser fingerprinting. The first part, we call it write 
script (support), only contains the information of whether 
certain write script be supported, i.e., a list of zero and 
one where one mean support and zero not. As mentioned, 
we obtain the information via box detection. The second part, 
we call it write script (images), be the image render 
at the client-side. The single-browser entropy for write 
script (images) be 3.13 large than the one for write script 
(support). That is, the image do contain more information than 
whether the write script be supported. The cross-browser 
stability for write script (support) be calculate base on the 
result after apply our mask, because some write script 
be ship with the browser and not cross-browser stable. 
Correspondingly, the cross-browser entropy for write script 
(support) be low than the single-browser one. 

15) CPU Virtual Cores: The number of CPU virtual 
cores, calculate from the HardwareConcurrency value only 
(if not supported, the value be “undefined”), have an entropy 
of 1.92 for single-browser fingerprinting. We expect that the 
entropy will increase in the future, because just before our 
submission, Firefox 48 start to support the new feature. 
The cross-browser stability be 100%, because we can detect 
whether a browser support HardwareConcurrency and applies 
a customize mask. The cross-browser entropy be different 
from the single-browser one due to the size of data, and the 
normalize entropy for both be very similar. 

16) Normalized WebGL Renderer: The WebGL renderer 
be not cross-browser fingerprintable, partly because different 
browser provide different level of information. We extract 
the common information from different browsers, and align 
the information in a standard format. Compared with the 
original WebGL renderer with 5.70 entropy, the entropy for 
the normalize one be 4.98. The reason for the drop be that the 
extraction will discard some information, e.g., for Chrome, 
to align with other browsers, e.g., Edge browser. Correspond- 
ingly, the cross-browser stability increase from 15.39% for 
the original WebGL renderer to 37.39% for the normalize 
one. 

There be two thing worth note here. First, the WebGL 
vendor do not provide more information than the WebGL 
renderer. That is, when we combine both value together, the 
entropy be the one for WebGL renderer. Second, our GPU 
task have much more information than the one provide by 
WebGL vendor and renderer. Some browsers, namely Firefox, 
do not provide WebGL vendor and renderer information, which 
give u much room to fill the gap. Furthermore, even when 
a browser provide such information, the entropy for our GPU 
task when combine together be 7.10, much large than the 
5.70 entropy provide by WebGL render. The reason be that 
the render be a combination of software and hardware, and 
WebGL renderer only provide the hardware information for 
hardware rendering. 

D. Observations 

During our experiment and implementations, we have 
observe several interest fact and show them below in 
this subsection: 

Observation 1: Our fingerprintable feature be highly reliable, 
i.e., the removal of one single feature have little impact on the 
fingerprint results. 

In this part, we show the impact of remove a single 
feature from both AmIUnique and our approach, and then 
measure the uniqueness of both. The result show that the 
uniqueness of our fingerprint be still above 99% when 
remove any single feature in Table IV include all the 
old one from AmIUnique and our new ones. At contrast, 
the uniqueness for AmIUnique drop below 84% if remove 
any single one of the follow six attributes, namely user 
agent, timezone, list of plugins, content language, list of HTTP 
headers, and screen resolution and color depth. In sum, our 
approach be more reliable than AmIUnique in term of use 
features. 

Observation 2: Software render can also be use for 
fingerprinting. 

One common understand for WebGL be that software 
render may diminish all the difference cause by the 
graphic cards. However, our experiment show that even soft- 
ware render can be use for fingerprinting. Specifically, we 
select all the data where WebGL be render by SwiftShader, 
an open source software renderer invent by Google and 
use by Chrome when hardware render be unavailable. We 
calculate a special fingerprint only contain all our GPU 
render tasks, i.e., Task (a)–(p) exclude write script and 
video. 

Due to the high adoption of hardware rendering, we only 
collect 88 case use SwiftShader and find 11 distinct GPU 
fingerprint with 7 unique ones. The uniqueness of software 
render be definitely much low than the one of hardware 
render but still not zero. That is, we need to be careful 
when adopt software render to mitigate WebGL-based 
fingerprinting. 

Observation 3: WebGL render be a combination of software 
and hardware in which the hardware contributes more than the 
software. 

In this observation, we look at another extreme compare 
to software rendering, which be Microsoft Basic Rendering. 
Microsoft Basic Rendering provide a universal driver for all 
kind of graphic cards, i.e., the use of Microsoft Basic Render- 
ing will minimize the effect of software driver and show the 
one brought by the hardware. Similar to the experiment for 
software rendering, we select these that use Microsoft Basic 
Rendering and calculate the fingerprints. 

For similar reason in software rendering, we only collect 
32 case use Microsoft Basic Rendering and find 18 distinct 
GPU fingerprint with 15 unique values. The uniqueness of 
Microsoft Basic Rendering be low than the one use normal 
graphic card drivers, meaning that WebGL be render by 
both software and hardware. Meanwhile, we consider hardware 
make more contributions, because the uniqueness for Mi- 
crosoft Basic Rendering be high than the one for the software 
renderer. 

Observation 4: DataURL be implement differently across 
browsers. 

12 



In this observation, we look at DataURL, a common format 
use in prior fingerprint to represent images. Surprisingly, 
we find that DataURL be implement very differently in 
browsers, i.e., if we convert an image into DataURL, the 
representation varies a lot across browsers. This be a good news 
for single-browser fingerprint but bad for cross-browser. As 
show in Table IV, the cross-browser rate for Canvas be very 
low (8.17%), because we adopt the code from AmIUnique 
where DataURL be use to store images. 

Observation 5: Some difference between render result be 
very subtle, i.e., with one or two pixel variance. 

In this last observation, we manually compare the differ- 
ences between render results, and find that while some 
of them be large, especially between software and hardware 
rendering, some be very subtle, especially when two graphic 
card be similar to each other. For example, the Suzanne 
model render by an iMac and another Mac Pro only differs 
one pixel on the texture, and if we rotate the model, the 
difference will be gone. 

VII. DEFENSE OF THE PROPOSED FINGERPRINTING 

In this section, we discus how to defend our propose 
browser fingerprinting. We will first start from exist de- 
fense, the famous Tor browser, and then come to some vision 
of our defense. 

Tor Browser normalizes many browser output to mitigate 
exist browser fingerprinting. That is, many feature be 
unavailable in Tor Browsers—based on our test, only the 
follow features, notably our newly proposed, still exist, 
which include the screen width and height ratio, and audio 
context information (e.g., sample rate and max channel count). 
We believe that it be easy for Tor Browser to normalize these 
remain outputs. 

Another thing worth mention be that Tor Browser dis- 
ables canvas by default, and will ask user to allow the usage 
of canvas. If the user do allow canvas, she can still be 
fingerprinted. The Tor Browser document also mention a 
unimplemented software render solution, however a note 
in Section VI-D, the output of software render also differ 
significantly in the same browser. We still believe that this 
be the way to pursue, but more careful analysis be need to 
include all the library of software rendering. 

Overall, the idea of defend browser fingerprint can 
be generalize a virtualization, and we need to find a correct 
virtualization layer. Think about one extreme solution, which 
be a browser run inside a virtual machine—everything be 
normalize in the virtual machine, and the browser output 
be the same across different physical machines. However, the 
drawback be that machine virtualization be heavyweight. Tor 
browser be another extreme—everything be virtualized a part 
of a browser. This approach be lightweight, but we need to 
find all possible fingerprintable places, such a canvas and 
audio context: If one place be missing, the browser can still 
be somehow fingerprinted. We leave it a our future work to 
explore the correct virtualization layer. 

VIII. DISCUSSIONS ON ETHICS ISSUES 

We have discuss ethic issue with the institutional 
review board (IRB) of our organization, and obtain the 
IRB approval. Specifically, although web track can be use 
to acquire private information, the identifier that we obtain 
from crowdsourcing workers, e.g., the behavior of computer 
graphic cards, be not private themselves. Only when the 
identifier be associate with private information, such a 
browsing history, the combination be consider a private— 
however, this step be out of scope of the research. Our survey 
part, i.e., the study about the statistic of multiple browser 
usage in the Appendix A, contains users’ browsing habits. In 
order to ensure privacy, the survey be anonymized and we do 
not store user ID from MicroWorkers. 

IX. RELATED WORK 

In this section, we discus related work on exist web 
track and anti-tracking techniques. 

A. Web Tracking Techniques and Measurement 

We first talk about the first generation tracking, i.e., cookie 
or super-cookie based, and then the second generation, browser 
fingerprinting. 

1) Cookie or Super-cookie base Tracking: There be much 
exist work focus on the measurement or study of cookie 
or super-cookie base web track techniques. Mayer et 
al. [28] and Sanchez et al. [40] conduct comprehensive discus- 
sion about third-party tracking, include track techniques, 
business models, defense choice and policy debates. Another 
important measurement work from Roesner et al. proposes 
a comprehensive classification framework for different web 
track deployed in real-world website [39]. Lerner et al. 
conduct an archaeological study of web tracking, include 
cookie and super-cookie base a well a browser fingerprint- 
ing, from 1996 to 2016 [27]. Soltani et al. and Ayenson 
et al. measure the prevalence of non-cookie base stateful 
track and show how track company use multiple client- 
side state to regenerate delete identifier [11, 41]. Metwalley 
et al. [30] propose an unsupervised measurement of web 
tracking. In addition to track behavior and techniques, 
Krishnamurthy et al. [22–25] focus on the risk of harm result 
from web tracking, show that not only user’s browsing 
history, but also other sensitive personal information, such a 
name and email, can be leak out. 

2) Browser Fingerprinting: Now let u discus browser fin- 
gerprinting, the second-generation web tracking. We first talk 
about exist measurement studies. Yen et al. and Nikiforakis 
et al. discus different second-generation track technique 
use in exist fingerprint tool and their effectiveness in 
their work [36, 46]. Acar et al. [9] perform a large-scale study 
of three advanced web track mechanisms, one on second- 
generation web tracking, i.e., canvas fingerprinting, and the 
other two stay on the first-generation web tracking, i.e., 
evercookies and use of ”cookie syncing” in conjunction with 
evercookies. Fifield el al. [20] focus on a specific metric, i.e., 
the font, of second-generation web tracking. FPDetective [10] 
conduct a large-scale study of million of most popular web- 
site by focus on the font detection with their framework. 
Englehardt et al. [18] also conduct a large-scale study on 1 

13 



million website and find many new fingerprint features, 
such a AudioContext. We have use their newly discover 
fingerprint feature a part of prior one in Section II of 
our paper a well. 

Now let u talk about browser fingerprint works. Mow- 
ery et al. [32] be probably one of the very early work in 
propose canvas-based fingerprinting. Some other work [31, 
33] focus on fingerprint browser JavaScript engine. Nakibly 
et al. [34], a position paper, propose several hardware-based 
track include microphone, motion sensor and GPU. Their 
GPU track only include timing-based features, less reli- 
able than the technique in the paper. Laperdrix et al. [26], 
i.e., AmIUnique, perform a most extensive study on browser 
fingerprint with 17 attribute and we have compare with 
them throughout our paper. Boda et al. [14] attempt to achieve 
cross-browser tracking, but their feature be old one from 
single-browser track include IP address. As discussed, IP 
address be unreliable when a machine be use a DHCP, 
behind a NAT, or move to a new location like a laptop. 

As a general comparison with exist works, our approach 
introduces many new feature on the OS and hardware levels. 
For example, we introduce many GPU feature such a tex- 
tures, varyings, light and models. For another example, we 
also introduce a side channel to detect instal write script 
and some new information in AudioContext. All these new 
feature contribute to our high fingerprint uniqueness and 
cross-browser stability. 

B. Existing Anti-tracking Mechanisms 

We first talk about exist anti-tracking for the first- 
generation tracking, and then for the second. 

1) Anti-tracking against Cookie or Super-cookie base 
Techniques: Roesner et al. [39] propose a tool call Share- 
MeNot, defend social medium button tracking, such a Face- 
book Like button. Private browsing mode [44, 45] isolates 
normal browsing from private one with a separate user profile. 
Similarly, TrackingFree [37] adopts the profile-based isola- 
tion and proposes an indegree-bounded graph for the profile 
creation. The Do Not Track (DNT) [43] header be a opt- 
out approach, which require tracker compliance. As show 
by prior work [28, 39], DNT cannot effectively protect user 
from track in real world. Users can also disable third-party 
cookie, which be support by most browser to avoid cookie- 
base tracking. Meng et al. [29] design a policy and empower 
user to control whether to be tracked, but they have to rely 
on an exist anti-tracking technique. 

All the aforementioned work focus on cooky or super- 
cookie base web tracking, and can either fully or partially 
prevent such tracking. None of them can prevent the propose 
fingerprint in this paper, because the propose belongs to 
the second generation, which do not require a server-side, 
stateful identifier. 

2) Anti-tracking against Browser Fingerprinting: Tor 
Browser [38] can successfully defend many browser finger- 
printing techniques, include feature propose in our paper. 
Please refer to Section VII for more details. Other than the 
normalization technique propose in Tor Browser, PriVarica- 
tor [35] add randomize noise to fingerprint-able outputs. 

Because PriVaricator be not open source, we could not test 
our fingerprint against their defense. 

X. CONCLUSION 

In conclusion, we have propose a novel browser finger- 
printing that can identify not only user behind one browser but 
also these that use different browser on the same machine. Our 
approach adopts OS and hardware level feature include 
graphic card expose by WebGL, audio stack by Audio- 
Context, and CPU by hardwareConcurrency. Our evaluation 
show that our approach can uniquely identify more user than 
AmIUnique for single-browser fingerprinting, and than Boda 
et al. for cross-browser fingerprinting. Our approach be highly 
reliable, i.e., the removal of any single feature only decrease 
the accuracy by at most 0.3%. 

ACKNOWLEDGEMENT 

The author would like to thank anonymous reviewer for 
their thoughtful comments. This work be support in part 
by U.S. National Science Foundation (NSF) under Grants 
CNS-1646662 and CNS-1563843. The view and conclusion 
contain herein be those of the author and should not be 
interpret a necessarily represent the official policy or 
endorsements, either express or implied, of NSF. 

REFERENCES 

[1] Core estimator. https://github.com/oftn-oswg/core-estimator. 
[2] [email threads] proposal: navigator.cores. https://lists.w3.org/Archives/ 

Public/public-whatwg-archive/2014May/0062.html. 
[3] [github] Am I Unique? https://github.com/DIVERSIFY- 

project/amiunique. 
[4] [graphics wikia] anti-aliasing. http://graphics.wikia.com/wiki/Anti- 

Aliasing. 
[5] Panopticlick: Is your browser safe against tracking? https://panopticlick. 

eff.org/. 
[6] Watched: A wall street journal privacy report. http://www.wsj.com/ 

public/page/what-they-know-digital-privacy.html. 
[7] [wikipedia] cube mapping. https://en.wikipedia.org/wiki/Cube 

mapping. 
[8] [wikipedia] list of write systems. https://en.wikipedia.org/wiki/List 

of write systems. 
[9] G. Acar, C. Eubank, S. Englehardt, M. Juarez, A. Narayanan, and 

C. Diaz, “The web never forgets: Persistent track mechanism in 
the wild,” in Proceedings of the 2014 ACM SIGSAC Conference on 
Computer and Communications Security, ser. CCS ’14, 2014, pp. 674– 
689. 

[10] G. Acar, M. Juarez, N. Nikiforakis, C. Diaz, S. Gürses, F. Piessens, 
and B. Preneel, “FPDetective: Dusting the web for fingerprinters,” in 
Proceedings of the 2013 ACM SIGSAC Conference on Computer and 
Communications Security, ser. CCS ’13, 2013, pp. 1129–1140. 

[11] M. Ayenson, D. Wambach, A. Soltani, N. Good, and C. Hoofnagle, 
“Flash cooky and privacy ii: Now with html5 and etag respawning,” 
Available at SSRN 1898390, 2011. 

[12] S. Berger. You should install two browsers. http://www.compukiss.com/ 
internet-and-security/you-should-install-two-browsers.html. 

[13] T. Bigelajzen. Cross browser zoom and pixel ratio detector. https:// 
github.com/tombigel/detect-zoom. 

[14] K. Boda, A. M. Földes, G. G. Gulyás, and S. Imre, “User track on the 
web via cross-browser fingerprinting,” in Proceedings of the 16th Nordic 
Conference on Information Security Technology for Applications, ser. 
NordSec’11, 2012, pp. 31–46. 

[15] F. Boesch. Soft shadow mapping. http://codeflow.org/entries/2013/feb/ 
15/soft-shadow-mapping/. 

14 



TABLE V: Statistics of Browser Usage 

Single >2 >3 Chrome& Chrome& 
browser browser browser Firefox Microsoft IE/Edge 

30% 70% 13% 33% 20% 

[16] F. T. Commission. Cross-device tracking. https://www.ftc.gov/news- 
events/events-calendar/2015/11/cross-device-tracking. 

[17] P. Eckersley, “How unique be your web browser?” in Proceedings of 
the 10th International Conference on Privacy Enhancing Technologies, 
ser. PETS’10, 2010. 

[18] S. Englehardt and A. Narayanan, “Online tracking: A 1-million-site 
measurement and analysis,” in Proceedings of the 22Nd ACM SIGSAC 
Conference on Computer and Communications Security, ser. CCS ’16, 
2016. 

[19] A. Etienne and J. Etienne. Classical suzanne monkey from 
blender to get your game start with threex.suzanne. 
http://learningthreejs.com/blog/2014/05/09/classical-suzanne-monkey- 
from-blender-to-get-your-game-started-with-threex-dot-suzanne/. 

[20] D. Fifield and S. Egelman, “Fingerprinting web user through font 
metrics,” in Financial Cryptography and Data Security. Springer, 2015, 
pp. 107–124. 

[21] S. Kamkar. Evercookie. http://samy.pl/evercookie/. 
[22] B. Krishnamurthy, K. Naryshkin, and C. Wills, “Privacy leakage vs. 

protection measures: the grow disconnect,” in Web 2.0 Security and 
Privacy Workshop, 2011. 

[23] B. Krishnamurthy and C. Wills, “Privacy diffusion on the web: a 
longitudinal perspective,” in Proceedings of the 18th international 
conference on World wide web. ACM, 2009, pp. 541–550. 

[24] B. Krishnamurthy and C. E. Wills, “Generating a privacy footprint on 
the internet,” in Proceedings of the 6th ACM SIGCOMM conference on 
Internet measurement. ACM, 2006, pp. 65–70. 

[25] ——, “Characterizing privacy in online social networks,” in Proceed- 
ings of the first workshop on Online social networks. ACM, 2008, pp. 
37–42. 

[26] P. Laperdrix, W. Rudametkin, and B. Baudry, “Beauty and the beast: 
Diverting modern web browser to build unique browser fingerprints,” 
in 37th IEEE Symposium on Security and Privacy (S&P 2016), 2016. 

[27] A. Lerner, A. K. Simpson, T. Kohno, and F. Roesner, “Internet jones and 
the raider of the lose trackers: An archaeological study of web track 
from 1996 to 2016,” in 25th USENIX Security Symposium (USENIX 
Security 16), Austin, TX, 2016. 

[28] J. R. Mayer and J. C. Mitchell, “Third-party web tracking: Policy and 
technology,” in Security and Privacy (SP), 2012 IEEE Symposium on. 
IEEE, 2012, pp. 413–427. 

[29] W. Meng, B. Lee, X. Xing, and W. Lee, “Trackmeornot: Enabling flex- 
ible control on web tracking,” in Proceedings of the 25th International 
Conference on World Wide Web, ser. WWW ’16, 2016, pp. 99–109. 

[30] H. Metwalley and S. Traverso, “Unsupervised detection of web track- 
ers,” in Globecom, 2015. 

[31] K. Mowery, D. Bogenreif, S. Yilek, and H. Shacham, “Fingerprinting 
information in javascript implementations,” 2011. 

[32] K. Mowery and H. Shacham, “Pixel perfect: Fingerprinting canvas in 
html5,” 2012. 

[33] M. Mulazzani, P. Reschl, M. Huber, M. Leithner, S. Schrittwieser, 
E. Weippl, and F. Wien, “Fast and reliable browser identification with 
javascript engine fingerprinting,” in W2SP, 2013. 

[34] G. Nakibly, G. Shelef, and S. Yudilevich, “Hardware fingerprint 
use html5,” arXiv preprint arXiv:1503.01408, 2015. 

[35] N. Nikiforakis, W. Joosen, and B. Livshits, “Privaricator: Deceiving 
fingerprinters with little white lies,” in Proceedings of the 24th Inter- 
national Conference on World Wide Web, ser. WWW ’15, 2015, pp. 
820–830. 

[36] N. Nikiforakis, A. Kapravelos, W. Joosen, C. Kruegel, F. Piessens, and 
G. Vigna, “Cookieless monster: Exploring the ecosystem of web-based 

device fingerprinting,” in IEEE Symposium on Security and Privacy, 
2013. 

[37] X. Pan, Y. Cao, and Y. Chen, “I do not know what you visit 
last summer - protect user from third-party web track with 
trackingfree browser,” in NDSS, 2015. 

[38] M. Perry, E. Clark, and S. Murdoch, “The design and implementation 
of the tor browser [draft][online], united states,” 2015. 

[39] F. Roesner, T. Kohno, and D. Wetherall, “Detecting and defend 
against third-party track on the web,” in Proceedings of the 9th 
USENIX Conference on Networked Systems Design and Implementa- 
tion, ser. NSDI’12, 2012, pp. 12–12. 

[40] I. Sánchez-Rola, X. Ugarte-Pedrero, I. Santos, and P. G. Bringas, 
“Tracking user like there be no tomorrow: Privacy on the current 
internet,” in International Joint Conference. Springer, 2015, pp. 473– 
483. 

[41] A. Soltani, S. Canty, Q. Mayo, L. Thomas, and C. J. Hoofnagle, 
“Flash cooky and privacy,” in AAAI Spring Symposium: Intelligent 
Information Privacy Management, 2010. 

[42] US-CERT. Securing your web browser. https://www.us-cert.gov/ 
publications/securing-your-web-browser. 

[43] Wikipedia. Do Not Track Policy. http://en.wikipedia.org/wiki/Do Not 
Track Policy. 

[44] ——. Privacy Mode. http://en.wikipedia.org/wiki/Privacy mode. 
[45] M. Xu, Y. Jang, X. Xing, T. Kim, and W. Lee, “Ucognito: Private 

browsing without tears,” in Proceedings of the 22Nd ACM SIGSAC 
Conference on Computer and Communications Security, ser. CCS ’15, 
2015, pp. 438–449. 

[46] T.-F. Yen, Y. Xie, F. Yu, R. P. Yu, and M. Abadi, “Host fingerprint 
and track on the web: Privacy and security implications,” in Pro- 
ceedings of NDSS, 2012. 

APPENDIX A 
SURVEY OF PEOPLE’S USAGE OF MULTIPLE BROWSERS 

In this appendix, we study the statistic of people who 
use multiple browser on the same machine. Note that this 
be a small-scale, separate study from all other design and 
experiment of the paper. We perform the study to strengthen 
the motivation of the paper. Our result show that people 
do use more than one browser on the same machine with a 
considerable amount of time. 

Now let u introduce our experiment setup on MicroWork- 
ers, a crowdsourcing website. We conduct a survey with an 
open question that ask survey taker which browser(s) they 
have and normally use a well a how much time in term of 
percentage they spend on each browser. They be free to write 
anything into a multiple-line text box. 

Here be our experiment results. We have collect 102 
answer with one answer just copying our survey link and an- 
other mention a browser that do not exist. After exclude 
these two invalid answers, we have exactly 100 in total. 95% 
of the survey user have instal more than two browser 
because IE or Edge be instal by default. We further count 
the percentage of them use two or more browser regularly, 
i.e., they spend at least more than 5% time on one of the 
browser. 

The result of people use browser be show in Table V. 
70% of the survey taker use two or more browser regularly, 
and only 30% use a single browser. Browser type in the 
survey answer include Chrome, Firefox, IE, Edge, Safari, 
Coconut Browser, and Maxthon. The result show that people 
do use multiple browsers, and cross-browser fingerprint be 
important and necessary. 

15 


