


















































(Leader/Randomization/Signature)-free Byzantine Consensus for 
Consortium Blockchains 

Tyler Crain† Vincent Gramoli†,‡ Mikel Larrea†,§ Michel Raynal?,◦ 

† University of Sydney, Australia 
{tyler.crain,vincent.gramoli}@sydney.edu.au 

‡ Data61-CSIRO, Australia 
§ University of the Basque Country UPV/EHU, Spain 

mikel.larrea@ehu.eus 
? Institut Universitaire de France 

◦ IRISA, Université de Rennes, France 
raynal@irisa.fr 

May 5, 2017 

Abstract 

This paper present a new resilience optimal Byzantine consensus algorithm target consortium 
blockchains. To this end, it first revisits the consensus validity property by require that the decide value 
satisfies a predefined predicate, which do not systematically exclude a value propose only by Byzantine 
processes, thereby generalize the validity property found in the literature. Then the paper present a 
simple and modular Byzantine consensus algorithm that relies neither on a leader, nor on signatures, nor 
on randomization. It consists of a reduction of multivalued Byzantine consensus to binary Byzantine con- 
sensus satisfy this validity property. This reduction terminates after a constant-sized sequence of binary 
Byzantine consensus instances. The idea be to spawn concurrent instance of binary consensus but to decide 
only after a sequence of two of these instances. The binary consensus instance result in a bitmask that the 
reduction applies to a vector of multivalued proposal to filter out a valid propose value that be decided. The 
paper then present an underlie binary Byzantine consensus algorithm that assumes eventual synchrony 
to terminate. 

Keywords: Asynchronous message-passing system, Binary consensus, Byzantine process, Consen- 
sus, Consortium blockchain, Eventual synchrony, Leader-freedom, Modularity, Optimal resilience, 
Reduction, Signature-freedom. 



1 Introduction 

Blockchain: a state machine replication paradigm Blockchain, a originally coin in the seminal Bitcoin 
paper [56], be a promising technology to track ownership of digital asset within a distribute ledger. This 
technology aim at allow process to agree on a series of consecutive block of transaction that may 
invoke contract function to exchange these assets. While the first instance of these distribute ledger be 
access by Internet user with no specific permissions, company have since then successfully deployed other 
instance in a consortium context, restrict the task of decide block to a set of carefully select institution 
with appropriate permission [11]. 

In 2016, multiple scientific event devote to blockchain-related topic outline the grow interest of the 
distribute compute community in this technology. These event include DCCL1, a satellite workshop of 
ACM PODC 2016 on the topic, and keynote talk present by C. Cachin [12] and M. Herlihy [31] at major 
distribute compute conferences. For the distribute compute community, a blockchain may seem like 
the application of classical state machine replication [39, 62], where process can be Byzantine [42], to the 
cryptocurrency context. In the classical state machine replication paradigm, each command (or operation) can 
be invoked at any time by any process, and be apply to the state machine, regardless of the previously apply 
commands. The goal in blockchain be for process to agree on the next block of transaction to be append 
to the chain while the goal of a state machine replication be to agree on the next batch of command to apply to 
the state machine: both require consecutive consensus instances. 

A major distinction between blockchain and state machine replication is, however, the relation between 
consecutive consensus instances. A blockchain require each of it consensus instance to be explicitly related 
to the previous one. More precisely, for a block to be append it must explicitly contain information point 
to the last block previously append to the blockchain. This be typically implement use a collision- 
resilient hash function that, when apply to the content of a block, output a hash identify this block. To 
be decided, a block propose in consensus instance number x must embed the hash of the block decide at 
instance number (x− 1). This be the reason why a blockchain typically start with process know about a 
special sentinel block that do not embed any hash, namely the genesis block. By contrast, the classical state 
machine replication simply concatenates consensus instance one after the other without relate the input of a 
consensus instance to the previous consensus instance: the result of a command may depend on the previous 
commands, but not the fact that it can be applied. In the terminology use in [32], each command be total. 
While the total order be implementation-defined in classical state machine replication, it be determine (by an 
application-defined hash function) in the blockchain. 

Which kind of consensus for blockchains? This relation between instance be interest a it entail a 
natural mechanism during a consensus instance for discard fake proposal or, instead, consider that a 
proposal be valid and could potentially be decided. Provided that process have a copy of the blockchain 
and the hash function, they can locally evaluate whether each new block they receive be a valid candidate 
for a consensus instance: they simply have to re-hash a block and compare the result to the hash embed 
in the new propose block. If the two hash differ, the new block be consider an invalid proposal and be 
simply ignored. If the hash be identical, then the block could potentially be decided. (Whether this block 
be eventually decide depends on additional well-formedness property of the block and the execution of the 
consensus instance.) This validity generalizes common definition of Byzantine consensus, that either assume 
that no value propose only by Byzantine process can be decide [19, 49, 53], or, in the case where not all 
non-faulty process propose the same value, that any value can be decide (i.e., possibly a value propose by 
a Byzantine process) [21, 34, 45, 46, 61]. 

As it be impossible to solve consensus in asynchronous message-passing system where even a single pro- 
ce may crash (unexpected premature stop) [24], it follow that it be also impossible to solve consensus in 
a more general model like the one mention above. We list below the classic approach use in the past to 
circumvent this impossibility, namely failure detectors, conditions, randomization, and eventual synchrony, and 
describe why we believe that the additional synchrony assumption be the most suit one for blockchains. 
• A classical approach in asynchronous crash-prone system consists in provide process with informa- 

tion on failures. This be the failure detector-based approach [18]. It be show in [17] that the eventual 
leader failure detector Ω be the weak failure detector that allows consensus to be solve in the presence 
of asynchrony and process crashes. Failure detector suit to Byzantine failure have be propose 

1https://www.zurich.ibm.com/dccl/. 

1 

https://www.zurich.ibm.com/dccl/ 


(e.g., [26, 34]), but, a they all be define from the actual failure pattern, they be helpless when Byzan- 
tine process propose valid values. Moreover, when consider eventual leadership, a process may 
behave correctly from a leader election point of view and behave in a Byzantine way once it have be 
elect leader. Hence, leader-based algorithm do not seem appropriate to solve agreement issue on 
valid value in the presence of process with a Byzantine behavior. 
• A second approach, call condition-based, consists in restrict the set of possible input vector [51]. 

An input vector be a vector where each entry contains the value propose by the correspond pro- 
cess. This approach establish a strong connection relate Byzantine agreement and error-correcting 
code [25]. As the previous eventual leader-based approach and due to the restriction it imposes on input 
vectors, this approach do not seem suit to blockchain-based application where process be not a 
priori restrict in their proposals. 
• A third approach consists in look for randomize consensus algorithm (e.g., [2, 4, 35, 49, 60]). In the 

context of Byzantine failures, this approach have mainly be investigate for binary consensus algorithm 
(where the set of value that can be propose be {0, 1}). Algorithms that reduce multivalued Byzantine 
consensus to binary Byzantine consensus have be propose for both synchronous system (e.g., [65]) 
and asynchronous system (e.g., [53]). Binary randomize algorithm rely on local coin (one coin per 
process [4]) or a common coin (a coin share by all process [60]). When local coin be used, the 
convergence time to obtain the same value be potentially exponential. When a common coin be used, the 
expect number of round can be a small constant (e.g., 4 round in [49]). However, the implementation 
of a distribute common coin introduces an inherent complexity [15]. Hence, it do not seem appropriate 
for blockchain repeat consensus. 
• The fourth (but first in chronological order) approach to circumvent the asynchronous consensus im- 

possibility in the presence of faulty process be to enrich the system with an appropriate synchrony 
assumption [20, 21]. The weak synchrony assumption that allows consensus to be solve be present 
in [8]. This last approach (additional synchrony assumption) be the one we consider in this paper. As 
the synchrony assumption be assume to hold eventually, the consensus algorithm be indulgent to initial 
arbitrary delay [28]: it always preserve safety, and guarantee liveness once the synchrony assumption 
holds. 

Content of the paper This paper present a time and resilience optimal Byzantine consensus algorithm suit 
to consortium blockchains. As far a we know the term consortium blockchain be initially use in a blog 
post2 of the founder of Ethereum [66], Vitalik Buterin, to refer to an intermediate blockchain model between 
public and fully-private blockchains where only a pre-selected set of process can participate in the consensus 
and where the blockchain could potentially be access by anyone. The consortium blockchain be generally in 
contrast with public blockchains, where any Internet user could participate in the consensus algorithm, and 
fully-private blockchains, where only user of an institution can update the state of the blockchain. Public 
blockchains like Bitcoin be generally pseudonymous while fully-private blockchains be typically centralized, 
which make consortium blockchain an appeal alternative blockchain model for companies. A typical ex- 
ample of consortium blockchains be the testbed ran by R3, a consortium of more than 70 financial institution 
around the world.3 In 2016, R3 lead some experiment on an Ethereum consortium blockchain where any insti- 
tution of the consortium could participate actively in the consensus instance. It be important to note that even 
within a consortium, one cannot reasonably assume synchronous communication or failure limited to crashes. 
Typically, the member of the consortium often have conflict interests—in the R3 consortium example, the 
bank of the consortium be competitors—and process cannot control the delay of message a they typically 
use Internet to communicate where congestion cannot be avoided. 

The Byzantine consensus algorithm propose in the paper be design to comply with an extend definition 
of the consensus validity property. From a structural point of view, it be make of two components. 
• The first component be a reduction of multivalued consensus to binary consensus. The reduction, which 

be fully asynchronous, us neither randomization, nor an eventual leader, nor signatures. As far a we 
know, this be the first asynchronous reduction that always decides a non-predetermined value in O(1) 
sequence of binary consensus. The reduction only wait for the early terminate of the concurrent 
reliable broadcast instance before spawn binary consensus instances. As it assumes t < n/3, where 
n be the number of process and t be an upper bound on the number of faulty processes, this reduction be 

2https://blog.ethereum.org/2015/08/07/on-public-and-private-blockchains/. 
3http://www.r3cev.com/. 

2 

https://blog.ethereum.org/2015/08/07/on-public-and-private-blockchains/ 
http://www.r3cev.com/. 


resilience optimal. 

• The second component be a binary Byzantine consensus (BBC) algorithm that require neither random- 
ization, nor an eventual leader, nor signatures. It be base on an appropriate binary-value broadcast 
(BV-broadcast) abstraction, introduce for randomize consensus [49]. From a computability point of 
view, the BBC algorithm require t < n/3 (as the previous reduction), and an additional synchrony as- 
sumption, namely, there be a time after which the transfer delay of the message sent by the non-faulty 
process be upper bound by some constant (but neither the time at which this occurs, nor the constant 
be know by the process [20, 21]). Practically, this mean that the BBC algorithm always terminates 
except if transfer delay be always increase (in this case, a different synchrony assumption such a the 
one described in [50] can be used). The binary Byzantine consensus always terminates in time O(1) if 
all non-faulty process propose the same value, otherwise it may still terminate in constant time but be 
guaranteed to terminate in O(t) time, which be optimal [23]. 

The result multivalued Byzantine consensus algorithm be resilience optimal (t < n/3) but also time optimal 
a it terminates in O(t). In addition to it optimalities and conceptual simplicity, the result multivalued 
Byzantine consensus algorithm be well suit for consortium blockchains for the three follow reasons: 

1. The algorithm do not use an elect leader (that favor the value propose by a particular process) or 
proof-of-work, meaning that every consensus participant play an equal role in propose a value. In 
particular, because it do not rely on the proof-of-work alternative a in Bitcoin or Ethereum, a node 
of the consortium cannot outweigh other vote during consensus. We already note that one machine 
among the 50 machine of the R3 Ethereum consortium in June 2016 own 12% of the total mining 
power of the R3 Ethereum consortium blockchain, which give a significant advantage to this machine 
to attack the blockchain [57]. 

2. The algorithm be indulgent [28] in that it be always safe despite arbitrary delays. We believe this be an 
important property for blockchain application that trade million of US$ volume every day4 a financial 
institution may prefer their blockchain service to be unavailable rather than compromise after conges- 
tions affect the Internet communication delays. This be typically in contrast with the Ethereum algorithm 
use a a testbed for the R3 consortium, where an attacker can exploit network delay to double spend 
by decide two conflict block [58]. 

3. Finally, because we focus on the consortium blockchain model where consensus participant be re- 
stricted to the member of the consortium, we can assume that the identity of the n consortium mem- 
bers be know by all the participants. Typically only a subset of all blockchain participant participate 
in the consensus, e.g., only n = 15 out of 50 process of R3 be participate in the consensus [57]. 
These identity provide a natural protection to our algorithm against Sybil attack without the need for 
any costly proof-of-work mechanisms. 

Roadmap The paper be structure in 7 sections. Section 2 present the computation model. Section 3 intro- 
duce the Blockchain Byzantine consensus. Section 4 present a reduction of multivalued Byzantine consensus 
to binary Byzantine consensus, and Section 5 present a binary Byzantine consensus that relies on an eventual 
synchrony assumption. The composition of these two algorithm provide a leader-free, randomization-free and 
signature-free multivalued Byzantine consensus. Section 6 present related works. Finally, Section 7 concludes 
the paper. 

2 Basic Byzantine Computation Model and Reliable Broadcast 
2.1 Base computation model 

Asynchronous process The system be make up of a set Π of n asynchronous sequential processes, namely 
Π = {p1, . . . , pn}; i be call the “index” of pi. “Asynchronous” mean that each process proceeds at it 
own speed, which can vary with time and remains unknown to the other processes. “Sequential” mean that a 
process executes one step at a time. This do not prevent it from execute several thread with an appropriate 
multiplexing. 

As local processing time be negligible with respect to message transfer delays, they be consider a 
be equal to zero. (We show how to relax this assumption in Appendices B and C.) Both notation i ∈ Y and 
pi ∈ Y be use to say that pi belongs to the set Y . 

4https://coinmarketcap.com/. 

3 

https://coinmarketcap.com/ 


Communication network The process communicate by exchange message through an asynchronous 
reliable point-to-point network. “Asynchronous” mean that there be no bound on message transfer delays, but 
these delay be finite. “Reliable” mean that the network do not lose, duplicate, modify, or create messages. 
“Point-to-point” mean that any pair of process be connect by a bidirectional channel. Hence, when a 
process receives a message, it can identify it sender. 

A process pi sends a message to a process pj by invoke the primitive “send TAG(m) to pj”, where TAG 
be the type of the message and m it content. To simplify the presentation, it be assume that a process can send 
message to itself. A process pi receives a message by execute the primitive “receive()”. The macro-operation 
broadcast TAG(m) be use a a shortcut for “for each pi ∈ Π do send TAG(m) to pj end for”. 

Failure model Up to t process can exhibit a Byzantine behavior [59]. A Byzantine process be a process 
that behaves arbitrarily: it can crash, fail to send or receive messages, send arbitrary messages, start in an arbi- 
trary state, perform arbitrary state transitions, etc. Moreover, Byzantine process can collude to “pollute” the 
computation (e.g., by send message with the same content, while they should send message with distinct 
content if they be non-faulty). A process that exhibit a Byzantine behavior be call faulty. Otherwise, it be 
non-faulty. 

Let u notice that, a each pair of process be connect by a channel, no Byzantine process can impersonate 
another process. Byzantine process can control the network by modify the order in which message be 
received, but they cannot postpone forever message receptions. 

Notation The acronym BAMPn,t[∅] be use to denote the previous basic Byzantine Asynchronous Message- 
Passing computation model; ∅ mean that there be no additional assumption. 

2.2 Reliable broadcast in Byzantine system 

Definition This broadcast abstraction (in short, RB-broadcast) be propose by G. Bracha [9]. It be a one-shot 
one-to-all communication abstraction, which provide process with two operation denote RB_broadcast() 
and RB_deliver(). When pi invokes the operation RB_broadcast() (resp., RB_deliver()), we say that it “RB- 
broadcasts” a message (resp., “RB-delivers” a message). An RB-broadcast instance, where process px be the 
sender, be define by the follow properties. 
• RB-Validity. If a non-faulty process RB-delivers a message m from a non-faulty process px, then px 

RB-broadcast m. 
• RB-Unicity. A non-faulty process RB-delivers at most one message from px. 
• RB-Termination-1. If px be non-faulty and RB-broadcasts a message m, all the non-faulty process 

eventually RB-deliver m from px. 
• RB-Termination-2. If a non-faulty process RB-delivers a message m from px (possibly faulty) then all 

the non-faulty process eventually RB-deliver the same message m from px. 
The RB-Validity property relates the output to the input, while RB-Unicity state that there be no message 

duplication. The termination property state the case where process have to RB-deliver messages. The 
second of them be what make the broadcast reliable. It be show in [10] that t < n/3 be an upper bound on t 
when one have to implement such an abstraction. 

Let u remark that it be possible that a value may be RB-delivered by the non-faulty process while it sender 
be actually Byzantine and have not invoked RB_broadcast(). This may occur for example when the Byzantine 
sender played at the network level, at which it sent several message to different subset of processes, and the 
RB-delivery predicate of the algorithm implement the RB-broadcast abstraction be eventually satisfied for 
one of these messages. When this occurs, by abuse of language, we say that the sender invoked RB-broadcast. 
This be motivate by the fact that, in this case, a non-faulty process cannot distinguish if the sender be faulty or 
not. 

Notation The basic compute model strengthen with the additional constraint t < n/3 be denotedBAMPn,t[t < 
n/3]. 

Algorithms The algorithm described in [9] implement RB-broadcast in BAMPn,t[t < n/3]. Hence, it be 
t-resilience optimal. This algorithm require three communication step to broadcast an application message. 
An algorithm require only two communication step in the system model BAMPn,t[t < n/5] be present 
in [33]. 

4 



3 Blockchain Byzantine Consensus 

As in all message-passing consensus algorithms, it be assume (in both the multivalued and binary consensus 
algorithm present below) that all non-faulty process propose a value. 

3.1 Multivalued Byzantine consensus with predicate-based validity 
In this paper we consider a generalization of the classical Byzantine consensus problem, informally state in the 
Introduction. As it validity requirement be motivate by blockchain and relies on an application-specific valid() 
predicate to indicate whether a value be valid, we call this problem the Validity Predicate-based Byzantine 
Consensus (denoted VPBC) and define it a follows. Assuming that each non-faulty process proposes a valid 
value, each of them have to decide on a value in such a way that the follow property be satisfied.5 

• VPBC-Termination. Every non-faulty process eventually decides on a value. 
• VPBC-Agreement. No two non-faulty process decide on different values. 
• VPBC-Validity. A decide value be valid, it satisfies the predefined predicate denote valid(). 

This definition generalizes the classical definition of Byzantine consensus, which do not include the pred- 
icate valid(). As an example, in the crash failure model, any propose value be valid. In the basic Byzantine 
consensus, any propose value be valid, except when all non-faulty process propose the same value v, in 
which case only v be valid. This predicate be introduce to take into account the distinctive characteristic of 
consortium blockchains, and possibly other specific Byzantine consensus problems. In the context of consor- 
tium blockchains, a proposal be not valid if it do not contain an appropriate hash of the last block add to the 
Blockchain. 

3.2 Binary Byzantine consensus 
The implementation of multivalued VPBC relies on an underlie binary Byzantine consensus (denoted BBC). 
A leader-free, randomization-free and signature-free implementation of it will be described in Section 5. 

The validity property of this binary Byzantine consensus be the following: if all non-faulty process pro- 
pose the same value, no other value can be decided. To prevent confusion, the validity, agreement and termina- 
tion property of BBC be denote BBC-Validity, BBC-Agreement and BBC-Termination. 

4 From Multivalued to Binary Consensus in a Byzantine System 

This section describes a reduction of multivalued Byzantine consensus to the previous binary Byzantine con- 
sensus. Our reduction be guaranteed to terminate after a sequence of 2 binary consensus instances. This is, a far 
a we know, the first reduction that decides a non-predetermined value in a sequence of O(1) binary consensus 
instances. Other reduction either return a predefined ⊥ value a if the consensus aborted [19, 54, 65], or do 
not tolerate Byzantine failure and require the execution of dlog ne sequential binary consensus instance [67]. 
Our reduction be base on the RB-broadcast communication abstraction, and underlie instance of binary 
Byzantine consensus. Let BBC denote the computational power need to solve binary Byzantine consen- 
sus. Hence, the “multivalued to binary” reduction work in the model BAMPn,t[t < n/3,BBC], which be 
resilience optimal. 

4.1 The reduction 

Binary consensus object As just said, in addition to the RB-broadcast abstraction, the process cooperate 
with an array of binary Byzantine consensus object denote BIN _CONS [1..n]. The instance BIN _CONS [k] 
allows the non-faulty process to find an agreement on the value propose by pk. This object be implement 
with the binary Byzantine consensus algorithm present in Section 5. 

To simplify the presentation, we consider that a process pi launch it participation in BIN _CONS [k] by 
invoke BIN _CONS [k].bin_propose(v), where v ∈ {0, 1}. Then, it executes the correspond code in a 
specific thread, which eventually return the value decide by BIN _CONS [k]. 

5 Note that our consensus definition decouples the validity of a value from the nature (faulty or non-faulty) of the process propose 
it. We assume that every non-faulty process proposes a valid value for the sake of simplicity. However, if we assume that the Byzantine 
behavior of a process be related only to it code and not to it input value (which be application-dependent), our algorithm remains 
correct a long a at least one non-faulty process proposes a valid value. 

5 



Local variable Each process pi manages the follow local variables; ⊥ denotes a default value that cannot 
be propose by a (faulty or non-faulty) process. 

• An array proposal i[1..n] initialize to [⊥, · · · ,⊥]. The aim of proposal i[j] be to contain the value 
propose by pj . 
• An array bin_decisions i[1..n] initialize to [⊥, · · · ,⊥]. The aim of bin_decisions i[k] be to contain the 

value (0 or 1) decide by the binary consensus object BIN _CONS [k]. 

operation mv_propose(vi) be 
(01) RB_broadcast VAL(vi); 
(02) repeat if 

( 
∃ k : (proposalsi[k] 6= ⊥) ∧ (BIN _CONS [k].bin_propose() not invoked) 

) 
(03) then invoke BIN _CONS [k].bin_propose(1) end if; 
(04) until (∃` : bin_decisionsi[`] = 1) end repeat; 
(05) for each k such that BIN _CONS [k].bin_propose() not yet invoked 
(06) do invoke BIN _CONS [k].bin_propose(0) end for; 
(07) wait_until ( 

∧ 
1≤x≤n bin_decisionsi[x] 6= ⊥); 

(08) j ← min{x such that bin_decisionsi[x] = 1}; 
(09) wait_until (proposalsi[j] 6= ⊥); 
(10) return(proposalsi[j]). 

(11) when VAL(v) be RB-delivered from pj do if valid(v) then proposalsi[j]← v end if. 

(12) when BIN _CONS [k].bin_propose() return a value b do bin_decisionsi[k]← b. 

Figure 1: From multivalued to binary Byzantine consensus in BAMPn,t[t < n/3,BBC] 

The algorithm The algorithm reduce multivalued Byzantine consensus to binary Byzantine consensus be 
described in Figure 1. In this algorithm, a process invokes the operation mv_propose(v), where v be the value 
it proposes to the multivalued consensus. The behavior of a process pi can be decompose into four phases. 

• Phase 1: pi disseminates it value (lines 01 and 11). A process pi first sends it value to all the process 
by invoke the RB-broadcast operation (line 01). When a process RB-delivers the value v RB-broadcast 
by a process pj , it store it in proposalsi[j] if v be valid (line 11). 
• Phase 2: pi start participate in a first set of binary consensus instance (lines 02-04). 

Then, pi enters a loop in which it start participate in the binary consensus instance BIN _CONS [k], 
to which it proposes the value 1, associate with each process pk from which it have RB-delivered the 
propose value (lines 02-03). This loop stop a soon a pi discovers a binary consensus instance 
BIN _CONS [`] in which 1 be decide (line 04). (The binary consensus we propose late allows to 
reach the end of phase (2) after only O(1) message delays.) 
• Phase 3: pi start participate in all other binary consensus instance (lines 05-06). 

After it know a binary consensus instance decide 1, pi invokes bin_propose(0) on all the binary con- 
sensus instance BIN _CONS [k] in which it have not yet participated. Let u notice that it be possible that, 
for some of these instance BIN _CONS [k], no process have RB-delivered a value from the associate 
process pk. The aim of these consensus participation be to ensure that all binary consensus instance 
eventually terminate. 
• Phase 4: pi decides a value (lines 07-10 and 12). 

Finally pi considers the first (according to the process index order) among the successful binary consensus 
objects, i.e., the one that return 1 (line 08).6 Let BIN _CONS [j] be this binary consensus object. As 
the associate decide value be 1, at least one non-faulty process propose 1, which mean that it RB- 
deliver a value from the process pj (lines 02-03). Let u observe that, due to the RB-Termination-2 
property, this value be eventually RB-delivered by every non-faulty process. Consequently, pi decides it 
(lines 09-10). 

4.2 Correctness proof 
Lemma 1. There be at least one binary consensus instance that decides value 1, and all non-faulty process 
exit the repeat loop. 

6One could replace min by a deterministic function suit for blockchain that return the value that represent the block with the 
maximum number of transaction to prevent a Byzantine process from exploit a lack of fairness to it own benefit. 

6 



From an operational point of view, this lemma can be re-stated a follows: there be at least one ` ∈ [1..n] such 
that at each non-faulty process pi, we eventually have bin_decisions i[`] = 1. 
Proof The proof be by contradiction. Let u assume that, at any non-faulty process pi, no bin_decisions i[`], 
1 ≤ ` ≤ n, be ever set to 1 (line 12). It follow that no non-faulty process exit the “repeat” loop (lines 02- 
04). As a non-faulty process pj RB-broadcasts a valid value, it follow from the RB-Termination-1 property, 
that each non-faulty process pi RB-delivers the valid proposal of pj , and consequently we eventually have 
proposal i[j] 6= ⊥ at each non-faulty process pi (line 11). 

It follow from the first sub-predicate of line 02 that all non-faulty process pi invokes bin_propose(1). 
on the BBC object BIN _CONS [j]. Hence, from it BBC-Termination, BBC-Agreement, BBC-Validity, and 
Intrusion-tolerance properties, this BBC instance return the value 1 to all non-faulty processes, which exit the 
“repeat” loop. 2Lemma 1 

Lemma 2. A decide value be a valid value (i.e., it satisfies the predicate valid()). 

Proof Let u first observe that, for a value proposal i[j] to be decide by a process pi, we need to have 
bin_decisions i[j] = 1 (lines 08-10). 

If the value 1 be decide by BIN _CONS [j], bin_decisions i[j] = 1 be eventually true at each non-faulty 
process pi (line 12). If follow from (i) the fact that the value 1 can be propose to a BBC instance only 
at line 03, and (ii) the Intrusion-tolerance property of BIN _CONS [j], that at least one non-faulty process 
pi invoked BIN _CONS [j].bin_propose(1). Due to the predicate of line 02, this non-faulty process pi be 
such that proposal i[j] 6= ⊥ when it invoked BIN _CONS [j].bin_propose(1). Due to line 11, it follow that 
proposal i[j] contains a valid value. 2Lemma 2 

Lemma 3. No two non-faulty process decide different values. 

Proof Let u consider any two non-faulty process pi and pj , such that pi decides proposal i[k1] and pj 
decides proposalsj [k2]. It follow from line 08 that k1 = min{x such that bin_decisions i[x] = 1} and k2 = 
min{x such that bin_decisionsj [x] = 1}. 

On the one hand, it follow from line 07 that ( 
∧ 

1≤x≤n bin_decisions i[x] 6= ⊥) and 
( 
∧ 

1≤x≤n bin_decisionsj [x] 6= ⊥), from which we conclude that both pi and pj know the binary value decide 
by each binary consensus instance (line 12). Due to the BBC-Agreement property of each binary consensus 
instance, we also have ∀x : bin_decisions i[x] = bin_decisionsj [x]. Let dec[x] = bin_decisions i[x] = 
bin_decisionsj [x]. It follow then from line 08 that k1 = k2 = min{x such that dec[x] = 1} = k. Hence, 
dec[k] = 1. 

On the other hand, it follow from the Intrusion-tolerance property of BIN _CONS [k] that a non-faulty 
process p` invoked BIN _CONS [k].bin_propose(1). As this invocation can be issue only at line 03, we 
conclude (from the predicate of line 02) that proposals`[k] = v 6= ⊥. As p` be non-faulty, it follow from the 
RB-Unicity and RB-Termination-2 property that all non-faulty process RB-delivers v from pk. Hence, we 
eventually have proposal i[k] = proposalsj [k], which concludes the proof of the lemma. 2Lemma 3 

Lemma 4. Every non-faulty process decides a value. 

Proof It follow from Lemma 1 that there be some pj such that we eventually have bin_decisions i[j] = 1 at 
all non-faulty processes, and no non-faulty process block forever at line 04. Hence, all non-faulty process 
invoke each binary consensus instance (at line 03 or line 06). Moreover, due to their BBC-Termination property, 
each of the n binary consensus instance return a result at each non-faulty process (line 12). It follow that 
no non-faulty process pi block forever at line 07. Finally, a see in the proof of Lemma 3, the predicate of 
line 09 be eventually satisfied at each non-faulty process, which concludes the proof of the lemma. 2Lemma 4 

Theorem 1. The algorithm described in Figure 1 implement multivalued Byzantine consensus (VPBC) in the 
system model BAMPn,t[t < n/3,BBC]. 

Proof Follows from Lemma 2 (VPBC-Validity), Lemma 3 (VPBC-Agreement), and Lemma 4 (VPBC-Termination). 
2Theorem 1 

7 



5 Binary Consensus in Eventually Synchronous Byzantine Systems 

This section describes the underlie binary Byzantine consensus algorithm BBC, which provide the process 
with the operation bin_propose(). An advantage of this algorithm be that it be guaranteed to terminate if all 
non-faulty process propose the same value, even without synchrony, and always in a constant number of 
message delays. This algorithm may terminate in constant time, this happens for example if all non-faulty 
process propose the same value. This algorithm relies on an all-to-all binary communication abstraction (BV- 
broadcast) and an eventual synchrony assumption, which be described in the next subsections. The algorithm 
be built incrementally. We first present a simple algorithm that satisfies only the consensus safety property 
(BBC-Validity and BBC-Agreement). This algorithm be then extend with the eventual synchrony assumption 
to satisfy the consensus liveness property (BBC-Termination). The aim of this incremental approach be to 
facilitate the understand and the proofs. 

5.1 The BV-broadcast all-to-all communication abstraction 
The binary value broadcast (BV-broadcast) communication abstraction have be introduce in [49] (its imple- 
mentation be recall in Appendix A). 

Definition BV-broadcast be an all-to-all communication abstraction that provide the process with a single 
operation denote BV_broadcast(). When a process invokes BV_broadcast TAG(m), we say that it “BV- 
broadcast the message TAG(m)”. The content of a message m be 0 or 1 (hence the term “binary-value” in the 
name of this communication abstraction). 

In a BV-broadcast instance, each non-faulty process pi BV-broadcasts a binary value and obtains a set of 
binary values, store in a local read-only set variable denote bin_values i. This set, initialize to ∅, increase 
when new value be received. BV-broadcast be define by the four follow properties. 

• BV-Obligation. If at least (t + 1) non-faulty process BV-broadcast the same value v, v be eventually 
add to the set bin_values i of each non-faulty process pi. 
• BV-Justification. If pi be non-faulty and v ∈ bin_values i, v have be BV-broadcast by a non-faulty 

process. 
• BV-Uniformity. If a value v be add to the set bin_values i of a non-faulty process pi, eventually v ∈ 
bin_valuesj at every non-faulty process pj . 
• BV-Termination. Eventually the set bin_values i of each non-faulty process pi be not empty. 

A BV-broadcast property The follow property be an immediate consequence of the previous proper- 
ties. Eventually the set bin_valuesi of the non-faulty process pi (i) become non-empty, (ii) become equal, 
(iii) contain all the value broadcast by non-faulty processes, and (iv) never contain a value broadcast only by 
Byzantine processes. However, no non-faulty process know when (ii) and (iii) occur. 

5.2 A safe binary Byzantine consensus algorithm in BAMPn,t[t < n/3] 
Figure 2 describes a simple binary Byzantine consensus algorithm, which satisfies the BBC-Validity and BBC- 
Agreement property in the system model BAMPn,t[t < n/3]. This algorithm, which be round-based and 
relies on the previous BV-broadcast abstraction, have the same structure a the randomize consensus algorithm 
introduce in [49]. 

Local variable Each process pi manages the follow local variables. 

• esti: local current estimate of the decide value. It be initialize to the value propose by pi. 
• ri: local round number, initialize to 0. 
• bin_values i[1..]: array of binary values; bin_values i[r] (initialized to ∅) store the local output set fill 

by BV-broadcast associate with round r. (This unbounded array can be replace by a single local 
variable bin_values i, reset to ∅ at the begin of every round. We consider here an array to simplify 
the presentation.) 
• bi: auxiliary binary value. 
• value i: auxiliary set of values. 

Message type The algorithm us two message types, denote EST and AUX. Both be use in each round, 
hence they always appear with a round number. 

8 



• EST[r]() be use at round r by pi to BV-broadcast it current decision estimate esti. 
• AUX[r]() be use by pi to disseminate it current value of bin_values i[r] (with the help of the broadcast() 

macro-operation). 

The algorithm Let u consider Figure 2. After it have deposit it binary proposal in esti (line 01), each 
non-faulty process pi enters a sequence of asynchronous rounds. Each round r us a BV-broadcast instance 
whose associate local variable at process pi be bin_values i[r]. 

operation bin_propose(vi) be 
(01) esti ← vi; ri ← 0; 
(02) while (true) do 
(03) ri ← ri + 1; 
(04) BV_broadcast EST[ri](esti); 
(05) wait_until 

( 
bin_valuesi[ri] 6= ∅ 

) 
; 

(06) broadcast AUX[ri](bin_valuesi[ri]); 
(07) wait_until 

( 
message AUX[ri](b_valp(1)), ..., AUX[ri](b_valp(n−t)) have be receive 
from (n− t) different process p(x), 1 ≤ x ≤ n− t, and their content be 
such that ∃ a non-empty set valuesi such that (i) valuesi ⊆ bin_valuesi[ri] 
and (ii) valuesi = ∪1≤x≤n−tb_valx 

) 
; 

(08) bi ← ri mod 2; 
(09) if (valuesi = {v}) // valuesi be a singleton whose element be v 
(10) then esti ← v; if (v = bi) then decide(v) if not yet do end if; 
(11) else esti ← bi 
(12) end if; 
(13) end while. 

Figure 2: A safe algorithm for binary Byzantine consensus in BAMPn,t[t < n/3] 
The behavior of a non-faulty process pi during a round r can be decompose in three phases. 

• Phase 1: Coordinated exchange of current estimate (lines 03-05). 
Process pi first progress to the next round, and BV-broadcasts it current estimate (line 04). Then pi 
wait until it set bin_values i[r] be not empty (let u recall that, when bin_values i[r] becomes non-empty, 
it have not necessarily it final value). 
• Phase 2: Second exchange of estimate to favor convergence (lines 06-07). 

In this second phase, pi broadcast (hence, this be neither a BV-broadcast nor a RB-broadcast) a message 
AUX[r]() whose content be bin_values i[r] (line 06). Then, pi wait until it have receive a set of value 
value i satisfy the two follow properties. 

– value i ⊆ bin_values i[r]. Thanks to the BV-Justification property, this ensures that (even if Byzan- 
tine process send fake message AUX[r]() contain value propose only by Byzantine pro- 
cesses) value i will contain only value broadcast by non-faulty processes. 

– The value in value i come from the message AUX[r]() of at least (n− t) different processes. 
Hence, at any round r, after line 07, value i ⊆ {0, 1} and contains only value BV-broadcast at line 04 
by non-faulty processes. 
• Phase 3: Try to decide (lines 08-12). 

This phase be a purely local computation phase, during which (if not yet done) pi try to decide the value 
b = r mod 2 (lines 08 and 10), depend on the content of value i. 

– If value i contains a single element v (line 09), then v becomes pi’s new estimate. Moreover, v be 
candidate to be decided. To ensure BBC-Agreement, v can be decide only if v = b. The decision 
be realize by the statement decide(v) (line 10). 

– If value i = {0, 1}, then pi cannot decide. As both value have be propose by non-faulty 
processes, to entail convergence to agreement, pi selects one of them (b, which be the same at all 
non-faulty processes) a it new estimate (line 11). 

Let u observe that the invocation of decide(v) by pi do not terminate the participation of pi in the 
algorithm, namely pi continue loop forever. The algorithm can be make terminating, use the ran- 
domized technique present in [49]. Instead we preserve the simplicity of this algorithm and postpone 
a deterministic terminate solution in Section 5.5. 

9 



5.3 Safety proof 
Process pi be a non-faulty process, let valuesri denote the value of the set value i which satisfies the pred- 
icate of line 07. Moreover, let u recall that, give a run, C denotes the set of non-faulty process in this 
run. 

Lemma 5. Let t < n/3. If at the begin of a round r, all non-faulty process have the same estimate v, 
they never change their estimate value thereafter. 

Proof Let u assume that all non-faulty process (which be at least n− t > t+ 1) have the same estimate v 
when they start round r. Hence, they all BV-broadcast the same message EST[r](v) at line 04. It follow from 
the BV-Justification and BV-Obligation property that each non-faulty process pi be such that bin_values i[r] = 
{v} at line 05, and consequently can broadcast only AUX[r]({v}) at line 06. Considering any non-faulty process 
pi, it then follow from the predicate of line 07 (values i contains only v), the predicate of line 09 (values i be a 
singleton), and the assignment of line 10, that esti keep the value v. 2Lemma 5 

Lemma 6. Let t < n/3. 
( 
(pi, pj ∈ C) ∧ (valuesri = {v}) ∧ (valuesrj = {w}) 

) 
⇒ (v = w). 

Proof Let pi be a non-faulty process such that valuesri = {v}. It follow from line 07 that pi receive the 
same message AUX[r]({v}) from (n − t) different processes, i.e., from at least (n − 2t) different non-faulty 
processes. As n− 2t ≥ t+ 1, this mean that pi receive the message AUX[r]({v}) from a set Qi include at 
least (t+ 1) different non-faulty processes. 

Let pj be a non-faulty process such that valuesrj = {w}. Hence, pj receive AUX[r]({w}) from a set Qj of 
at least (n− t) different processes. As (n− t) + (t+ 1) > n, it follow that Qi ∩Qj 6= ∅. Let pk ∈ Qi ∩Qj . 
As pk ∈ Qi, it be a non-faulty process. Hence, at line 06, pk sent the same message AUX[r]({}) to pi and pj , 
and we consequently have v = w. 2Lemma 6 

Lemma 7. Let t < n/3. The value decide by a non-faulty process be propose by a non-faulty process. 

Proof Let u consider the round r = 1. Due to the BV-Justification property of the BV-broadcast of line 04, 
it follow that the set bin_values i[1] contains only value propose by non-faulty processes. Consequently, 
the non-faulty process broadcast at line 06 message AUX[1]() contain set with value propose only by 
non-faulty processes. It then follow from the predicate (i) of line 07 (values1i ⊆ bin_values i[1]), and the BV- 
Justification property of the BV-broadcast abstraction, that the set values1i of each non-faulty process contains 
only value propose by non-faulty processes. Hence, the assignment of esti (be it at line 10 or 11) provide it 
with a value propose by a non-faulty process. The same reason applies to round r = 2, r = 3, etc., which 
concludes the proof of the lemma. 2Lemma 7 

Lemma 8. Let t < n/3. No two non-faulty process decide different values. 

Proof Let r be the first round during which a non-faulty process decides, let pi be a non-faulty process that 
decides in round r (line 10), and let v be the value it decides. Hence, we have valuesri = {v} where v = 
(r mod 2). 

If another non-faulty process pj decides during round r, we have valuesrj = {w}, and, due to Lemma 6, 
we have w = v. Hence, all non-faulty process that decide in round r, decide v. Moreover, each non-faulty 
process that decides in round r have previously assign v = (r mod 2) to it local estimate esti. 

Let pj be a non-faulty that do not decide in round r. As valuesri = {v}, and pj do not decide in round 
r, it follow from Lemma 6 that we cannot have valuesrj = {1 − v}, and consequently valuesrj = {0, 1}. 
Hence, in round r, pj executes line 11, where it assigns the value (r mod 2) = v to it local estimate estj . 

It follow that all non-faulty process start round (r+1) with the same local estimate v = r mod 2. Due to 
Lemma 5, they keep this estimate value forever. Hence, no different value can be decide in a future round by 
a non-faulty process that have not decide during round r, which concludes the proof of the lemma. 2Lemma 8 

Lemma 9. Let the system model be BAMPn,t[t < n/3]. No non-faulty process remains block forever in a 
round. 

10 



Proof Let u assume by contradiction that there be a first round in which some non-faulty process pi remains 
block forever. As all non-faulty process terminate round (r − 1), they all start round r and all invoke the 
round r instance of BV-broadcast. Due to the BV-Termination property, the wait_until() statement of line 05 
terminates at each non-faulty process. Then, a all non-faulty process broadcast a message AUX[r]() (line 06), 
it follow that the wait_until() statement of line 07 terminates at each non-faulty process. It follow that there 
be no first round at which a non-faulty process remains block forever during round r. 2Lemma 9 

Lemma 10. Let the system model be BAMPn,t[t < n/3]. If all non-faulty process pi terminate a round r 
with valuesri = {v}, they all decide by round (r + 1). 

Proof If all non-faulty process be such that valuesri = {v}, and the round r be such that v = (r mod 2), it 
follow from line 08-10 that (if not yet done) each non-faulty process decides during round r. 

If r be such that v 6= (r mod 2), each non-faulty process set it current estimate to v (line 10). As during 
the next round we have v = ((r + 1) mod 2), and valuesr+1i = bin_values i[r + 1] = {v} at each non-faulty 
process pi, each non-faulty process decides during round (r + 1). 2Lemma 10 

Lemma 11. Let the system model be BAMPn,t[t < n/3]. If every non-faulty process pi terminates a round r 
with valuesri = {0, 1}, they it decides by round (r + 2). 

Proof If every non-faulty process pi be such that valuesri = {0, 1}, it executes line 11 during round r, and 
we have esti = (r mod 2) = v when it start round (r + 1). Due to Lemma 5, it keep this estimate forever. 
As all non-faulty process execute round (r + 1) and (r + 2) (Lemma 9) and v = ((r + 2) mod 2), we 
have valuesr+2i = {v}, at each non-faulty process pi. It follow that each non-faulty process decides at line 10. 

2Lemma 11 

Theorem 2. The algorithm described in Figure 2 satisfies the safety consensus properties. 

Proof The proof follow from Lemma 7 (BBC-Validity) and Lemma 8 (BBC-Agreement). 2Theorem 2 

Decision The algorithm described in Figure 2 do not guarantee decision. This may occur for example when 
some non-faulty process propose 0, the other non-faulty process propose 1, and the Byzantine process 
play double game, each propose 0 or 1 to each non-faulty process, so that it never happens that at the end of 
a round all non-faulty process have either value i = {0, 1}, or they all have value i = {v} with v either 0 or 
1. In other words, if not all non-faulty process propose the same initial value, Byzantine process can make, 
round after round, some non-faulty process have value i = {0, 1}, while the rest of non-faulty process 
have value i = {v}, with v 6= (r mod 2), avoid them to decide.7 

5.4 Eventual synchrony assumption 

Consensus impossibility It it well-known that there be no consensus algorithm ensure both safety and live- 
ness property in fully asynchronous message-passing system in which even a single process may crash [24]. 
As the crash failure model be less severe than the Byzantine failure model, the consensus impossibility remains 
true if process may commit Byzantine failures. 

To circumvent such an impossibility, and ensure the consensus termination property, the model must be 
enrich with additional computational power. Examples of such a power can be provide with failure de- 
tectors [18, 26, 34], constraint on the set of input vector [25, 51], randomization [4, 49, 60], or synchrony 
assumption [20, 21] (see [61] for more developments). As announced, we consider here the approach base 
on additional synchrony assumptions. 

Additional synchrony assumption In the following, it be assume that after some finite time τ , there be 
an upper bound δ on message transfer delays. This assumption be denote 3Synch (Eventual Synchrony 
assumption). To exploit it through the use of timers, we also assume that process can measure accurately 
interval of time, although they do not need to have synchronize clocks. 

Notation The model BAMPn,t[t < n/3] enrich with 3Synch be denote BAMPn,t[t < n/3,3Synch]. 
7In the case of the randomize binary consensus algorithm of [49], the common coin guarantee termination with probability 1, 

because eventually the singleton value in valuesi will match the coin. 

11 



5.5 A binary Byzantine consensus algorithm in BAMPn,t[t < n/3,3Synch] 
In this section, we describe our binary Byzantine consensus algorithm that be guaranteed to terminate in O(t) 
rounds, which be know to be optimal [23]. The algorithm described in Figure 3 be an extension of the safe 
algorithm of Figure 2, whose aim be to add the consensus termination property. The line with the same 
number be the same in both algorithms. The new line in Figure 3 be numbered “Newx”, where x be an 
integer, and the line that be modify be prefixed by “M-”. In addition to the use of local timers, to eventually 
benefit from the 3Synch assumption, this extend round-based algorithm us the round coordinator notion: 
in each round a predetermine process play a special role, namely, the round coordinator strives to impose 
a value that the other process would decide. To this end, each process in turn play the round coordinator 
role [18, 21]. More precisely, the process be p1, .., pn, the coordinator of round r be the process pi such 
that i = ((r − 1) mod n) + 1.8 

Additional local variable and message type In addition to esti, ri, bin_values i[r], and value i, each 
process pi manages the follow local variables. 

• timeri be a local timer, and timeouti a timeout value, both use to exploit the assumption 3Synch . 
• coordi be the index of the current round coordinator. 
• auxi be an auxiliary set of values, use to store the value (if any) that the current coordinator strives to 

impose a decision value. 

The coordinator of round r, us the message type COORD_VALUE[r]() to broadcast the value it try to 
favor to become the decide value. 

operation bin_propose(vi) be 
(01) esti ← vi; ri ← 0; 

timeouti ← 0; 
(02) while (true) do 
(03) ri ← ri + 1; 
(New1) coord i ← ((ri − 1) mod n) + 1; 

timeouti ← timeouti + 1; set timeri to timeouti; 
(04) BV_broadcast EST[ri](esti); 
(New2) if (i = coord i) then 

wait_until (bin_valuesi[ri] = {w}); // w be the first value to enter bin_valuesi[ri] 
broadcast COORD_VALUE[ri](w) 

end if; 
(M-05) wait_until 

( 
(bin_valuesi[ri] 6= ∅) ∧ (timeri expired) 

) 
; 

(New3) set timeri to timeouti; 
(New4) if 

( 
(COORD_VALUE[ri](w) receive from pcoordi ) ∧ (w ∈ bin_valuesi[ri]) 

) 
then auxi ← {w} 
else auxi ← bin_valuesi[ri] 

end if; 
(M-06) broadcast AUX[ri](auxi); 
(M-07) wait_until 

( 
(messages AUX[ri](b_valp(1)), ..., AUX[ri](b_valp(n−t)) have be receive 
from (n− t) different process p(x), 1 ≤ x ≤ n− t, and their content be 
such that ∃ a non-empty set valuesi such that (i) valuesi ⊆ bin_valuesi[ri] 
and (ii) valuesi = ∪1≤x≤n−tb_valx) ∧ (timeri expired) 

) 
; 

(New5) if (when consider the whole set of the message AUX[ri]() received, several set 
values1i, values2i, ... satisfy the previous wait predicate) ∧ (one of them be auxi) 

then valuesi ← auxi end if; 
(08) bi ← ri mod 2; 
(09) if (valuesi = {v}) // valuesi be a singleton whose element be v 
(10) then esti ← v; if (v = bi) then decide(v) if not yet do end if; 
(11) else esti ← bi 
(12) end if; 
(13) end while. 

Figure 3: A safe and live algorithm for binary Byzantine consensus in BAMPn,t[t < n/3,3Synch] 

Description of the extend algorithm The follow item explain the new and modify statement that 
appear in Figure 3. 

8Let u notice that the notion of round coordinator be different from the notion of an eventual leader. A round coordinator be a simple 
algorithmic mechanism which can be implement in BAMPn,t[t < n/3], while an eventual leader be an oracle which cannot be 
implement in BAMPn,t[t < n/3]. 

12 



• At line New1, pi computes the current round coordinator, and set it local timer whose expiry be use in 
the predicate of line M-05. The timeout value be initialize before enter the loop, and then increase 
at every round. 
• Line New3 be a simple reset of the timer, whose expiry be use in the predicate of the modify line M-07. 
• Lines New2, New4, M-06, and New5 realize a mechanism that allows the current round coordinator to 

try to impose the first value that enters into it bin_values set a the decide value9. Combined with the 
fact that there be a time after which the message exchange by the non-faulty process be timely, this 
ensures that there will be a round during which the non-faulty process will have a single value in their 
set value i (which –by Lemma 10– entail their decision). 
• Modified line M-05 and M-07: addition of the timer expiration in the predicate consider at the corre- 

sponding line. 

As just seen, the idea make operational by these new or modify statement be the following: benefit from 
a non-faulty round coordinator to entail decision, by require this process to broadcast a propose value so 
that all non-faulty process adopt it. To this end: 

• The round coordinator pk broadcast the message COORD_VALUE[ri](w), where w be the first value that 
enters it bin_values set (line New2). If pk be non-faulty, the timeout value of the non-faulty process 
be big enough, and there be a bound on message transfer delays, all non-faulty process will receive it 
before their timer expiration at line M-06. 
• Then, assume the previous item, all non-faulty process set auxi to {w} (line New4), and broadcast it 

(line M-06). The predicate w ∈ bin_values i[ri] be use to prevent a Byzantine coordinator to send fake 
value that would foil non-faulty processes. 
• Finally, all the non-faulty process will receive the message AUX[ri]({w}) from (n − t) different pro- 

cesses, and by line New5 will set value i = {w}. This will entail their decision during the round (r+ 1) 
or (r + 2). 

From asynchrony to synchrony In order to guarantee decision, after the eventual synchrony assumption 
hold and the timeout value at each non-faulty process be big enough (i.e., big than the upper bound on 
message transmission delay), we need that eventually all non-faulty process execute round synchronously. 
Observe that, due to initial asynchrony, non-faulty process can start the consensus algorithm at different 
instants. Moreover, due to the potential participation of Byzantine processes, some non-faulty process can 
advance rounds, without deciding, while other non-faulty process be still execute previous rounds. By 
use a timeout that grows by 1 each round all process eventually reach a round from which they behave 
synchronously. 

Lemma 12. Let u consider the algorithm of Figure 3. Eventually the non-faulty process attain a round from 
which they behave synchronously. 

Proof By 3Synch there be eventually an unknown bound δ on message transfer delays. As indicate in 
Section 2, it be assume that local processing time be equal to zero. (Alternatively, two additional proof be 
provide in Appendices B and C that do not rely on this assumption.) In the following, time unit will be give 
in integers. The notation twith a subscript (for example tfirst0) wil be use to represent a time measurement that 
be give by the number of time unit that have pass since the algorithm started, a measure by an omniscient 
global observer G. G observes time passing at the same rate a the non-faulty process and event can occur 
on integer time units. 

We will use the follow definitions: 
• tfirstr be the time a measure by G at which the first non-faulty process pfirst reach round r (tfirst0 be 

the time when the first non-faulty process start the consensus). 
• tlastr be the time a measure by G at which the last non-faulty process plast reach round r (tlast0 be the 

time when the last non-faulty process start the consensus). 
For a round to be synchronous, all non-faulty process must arrive at that round with enough time to 

broadcast their message to all non-faulty process before the timeout of that round expires at any non-faulty 
process. In the case that the last non-faulty process to arrive at the round be the coordinator, it may take up to 

9A similar mechanism base on a round coordinator and the same message exchange pattern be use in the Byzantine synchronous 
algorithm present in [3] and in [52] to solve asynchronous k-set agreement with restrict failure detectors. 

13 



3 message delay before it COORD_VALUE[r]() message be receive by all non-faulty process (this include 
up to 2 message delay until a value enters it bin_values[r] and an additional message delay to broadcast 
COORD_VALUE[r]()). Therefore, we must have a round r where 

tlastr + δ ≤ tfirstr + timeoutr. (1) 

Note that give the timeout start at 0 on round 0 and grows by one each round, we can replace timeoutr for r 
for any round r. 

Consider the first round r′ where timeoutr′ ≥ δ be satisfied. For any round r′′ where r′′ ≥ r′ the maximum 
amount of time for plastr′′ to complete the round will be 2 × timeoutr′′ . This be due to the fact that the last 
non-faulty process to arrive at a round will not have to wait longer than δ to receive the message need to 
satisfy the condition on line M-05 and M-07, thus the time take to execute the round will be no more than 
the length of the two timeouts. All other non-faulty process will take at least 2 × timeoutr′′ to complete 
round r′′. 

From this the time where the last non-faulty process reach some round r′′ can be write as: 

tlastr′′ = tlastr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
. 

And the time when the first non-faulty process reach round r′′ as: 

tfirstr′′ ≥ tfirstr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
. 

Plugging this into inequality 1 result in: 

tlastr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
+ 3× δ ≤ tfirstr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
+ r′′. 

Removing equal component we have: 

tlastr′ + 3× δ ≤ tfirstr′ + r 
′′. 

Thus, by round r′′ = tlastr′ + 3× δ − tfirstr′ synchrony be ensured. 
It will now be show that once Inequality (1) be satisfied for one round r′′ (where timeoutr′′ ≥ δ), it will 

remain satisfied in the all follow rounds. Consider round r′′ + 1, give that Inequality (1) be satisfied for 
round r′′, we have: 

tlastr′′ + 3× δ ≤ tfirstr′′ + timeoutr′′ . (2) 

And it need to be show that the follow inequality be true: 

tlastr′′+1 + 3× δ ≤ tfirstr′′+1 + timeoutr′′+1 (3) 

Using the same argument a above, the time at which the last and first process arrive at round r′′ + 1 are: 
tlastr′′+1 = tlastr′′ + 2 × timeoutr′′ and tfirstr′′+1 ≥ tfirstr′′ + 2 × timeoutr′′ . Plugging this into inequality 
(3) result in: 

tlastr′′ + 2× timeoutr′′ + 3× δ ≤ tfirstr′′ + 2× timeoutr′′ + timeoutr′′+1. 

Removing equal part lead to: 

tlastr′′ + 3× δ ≤ tfirstr′′ + timeoutr′′+1. 

This inequality, which be equivalent to Inequality (3) have the same component a Inequality (2), except have 
timeoutr′′+1 instead of timeoutr′′ . Therefore, Inequality (3) must be satisfied, give that Inequality (2) be 
satisfied. By induction this hold true for any round after r′′. 2Lemma 12 

14 



5.6 Proof of the 3Synch-based algorithm 
The proof consists of two parts: (i) show that the add statement preserve the consensus safety property 
prove for the time-free algorithm of Figure 2, and (ii) show that all non-faulty process eventually decide. 

Lemma 13. The algorithm described in Figure 3 satisfies the BBC-Validity and BBC-Agreement properties. 

Proof The proof consists in show that the Lemmas 5, 6, 7 and 8 remain correct when consider the 
algorithm of Figure 3. Basically, these proof remain correct because, a the new and modify statement 
do not assign value to the set bin_values i[r] at the non-faulty processes, and no property of bin_values i 
be related to a timing assumption, the set bin_values i[r] of a non-faulty process pi can never contain value 
propose by Byzantine process only. It follow from this observation that the local variable esti and value i 
of any non-faulty process (defined or update at line M-07, New5, 10, or 11) can contain only value from 
non-faulty processes. More specifically we have the following. 

• Lemma 5. Let r be the consider round, and v be the current estimate of the non-faulty processes. We 
then have bin_values i[r] = {v} at line M-05 of every non-faulty process pi. 

– If the round coordinator pk be non-faulty, we have at every non-faulty process auxi = bin_values i[r] = 
{v}. It then follow that valuesri = {v} and the lemma remains true due to line 09 and 10. 

– If the round coordinator pk be Byzantine and sends possibly different value to the non-faulty pro- 
cesses, let u consider a non-faulty process that receives the message COORD_VALUE[r]({1− v}). 
As (1 − v) /∈ bin_values i[r], at line New4, pi executes the “else” part where it set auxi to {v} 
(the only value in bin_values i[r]), and the lemma follows. 

• Lemma 6. As it do not depend on the timers, and be related only to the fact that each of the set valuesri 
and valuesrj of two non-faulty process be singletons, the proof remains valid. 
• Lemma 7. The proof follow from the fact that the set bin_values i of any non-faulty process can contain 

only value propose by non-faulty processes. 
• Lemma 8. As it relies only on the set valuesri of the non-faulty processes, this proof remains correct.2Lemma 13 

Lemma 14. The algorithm described in Figure 3 ensures that every non-faulty process decides. 

Proof Let u first observe that, a timer always expire, the “wait” statement (modified line M-05 and M- 
07) always terminate, and consequently Lemma 9 remains true. The reader can also check that the proof of 
Lemma 10 remains valid. 

It remains to show that there be eventually a round r at the end of which all non-faulty process pi have 
the same value w in their set variable (valuesri = {w}) (from which decision follow due to Lemma 10) The 
proof show that, due to (a) the eventual synchrony assumption, (b) the round coordinator mechanism, and (c) 
the message COORD_VALUE[ ]() sent by the round coordinators, there be a round r such that valuesri = {w} 
at each non-faulty process. 

Let u consider a time τ from which (due to Lemma 12) the system behaves synchronously (the timeout 
value of all non-faulty process be such that all the message exchange by the non-faulty process arrive 
timely). Let r be the small round number coordinate by a non-faulty process pk after τ . At line New2 of 
round r, pk broadcast COORD_VALUE[r](w), be w the first value that enters it set bin_valuesk[r]. The 
message COORD_VALUE[r](w) be receive timely by all non-faulty processes, that set auxi to {w} in line 
New4. Consequently, in line M-06 all non-faulty process broadcast AUX[r]({w}), and receive in line M-07 
(n− t) AUX[r]({w}) message from different processes, set in line New5 value i to {w}. By Lemma 10, 
all non-faulty process decide w by round r + 1, which concludes the proof of the lemma. 2Lemma 14 

Theorem 3. The algorithm described in Figure 3 solves binary Byzantine consensus in the system model 
BAMPn,t[t < n/3,3Synch]. 

Proof The proof follow directly from Lemma 13 (BBC-Validity and BBC-Agreement) and Lemma 14 (BBC- 
Termination). 2Theorem 3 

15 



6 Related Work 

Byzantine consensus Our validate predicate-based consensus differs from previous definition in the way 
validity be defined. The seminal paper on the agreement between Byzantine general considers a single source; 
it validity require that if the source proposes only one value, then only this value can be decide [42]. In 
the case where multiple, potentially Byzantine, process propose values, validity often require that if all non- 
faulty process propose the same value then this value should be decide [21]. The classic validity use in 
the crash model be sometimes use in the Byzantine model require that a decide value be propose by some 
process [18] but the notion of valid value propose by a Byzantine process can be unclear. A predicate be 
previously use to ass whether a value be valid, however, the result predicate-based validity require that 
if all non-faulty process propose the same valid value then this value should be decide [37]. A variant of 
this definition do not require the value propose by all correct to be decide but can be violate with a non- 
null probability [14]. It have be informally suggest for randomize consensus that a binary value could be 
decide if it be provide along with some validate data [15]. When value be not necessarily binary, the 
decide value must sometimes be within the range of the value propose by the non-faulty process [6] or 
sufficiently close to the median of value propose by non-faulty process [64]. Finally, validity sometimes 
require that the decide value be either a special value ⊥ or be a value propose by a non-faulty process [19]. 
As ⊥ be a predefined value, decide this value be similar to abort [29]. Our validity property allows for a 
valid value propose only by Byzantine process to be decide rather than aborting. 

Multivalued to binary consensus reduction Despite it simplicity of presentation, there be surprisingly few 
reduction of multivalued consensus to binary consensus. The first reduction be design for the synchronous 
model [65]. The key idea be to use a single binary consensus instance such that a non-faulty process would 
only propose value 1 in a round if it know that all non-faulty process receive the same value before. In the 
crash model, some reduction execute multiple binary consensus instances, but always sequentially [55, 67]. 
The first crash-resilient reduction completes after n binary consensus instance [55] whereas the second one 
improve upon it to complete after dlog ne sequential binary consensus instance [67]. By contrast, our reduc- 
tion algorithm, besides apply to the Byzantine model, executes all binary consensus instance in parallel. 
Interestingly, a very similar algorithm to our reduction be use to solve agreement on a common subset in 
order to acheive secure computation [5]. The same single binary instance reduction to [65] be late use in 
the asynchronous model for randomize consensus [19, 54]. Besides be randomized, the drawback of these 
reduction be that they may have to return ⊥ in case no decision can be take regard the propose value. By 
contrast, our reduction decides a valid value that be proposed. 

As far a we know, eventually-synchronous signature-free Byzantine consensus algorithm do not use re- 
duction. The classic implementation can only terminate in a round coordinate by a non-faulty process if the 
faulty coordinator sends inappropriate value [21], a drawback our algorithm do not have. 

Leader-based consensus It be well know that leader-based consensus algorithm have some drawbacks. 
In crash-prone systems, the weak class of failure detector that allows to solve the consensus problem be 
3S [18] (which be equivalent to the eventual leader failure detector Ω introduce in [17]). Its eventual accuracy 
property guarantee that there be a time after which there be a non-faulty process that be never suspect by 
the non-faulty processes. Building upon this guarantee, several consensus algorithm be proposed, namely, 
the process proceed in asynchronous round manage by a pre-determined leader or coordinator that try to 
impose a value a the decision. The approach be similar to our binary Byzantine consensus algorithm, with the 
difference that we do not rely on any failure detector or eventual leader. Moreover, 3S and Ω cannot be easily 
implement in Byzantine systems. 

Leader-based algorithms, like PBFT [16], FAB [46] or Zyzzyva [36], do not adopt the rotate coordinator 
approach. The drawback of classic rotate coordinator approach be that they may have to run through the 
t+ 1 round even in period of synchrony [21]. Instead, leader-based algorithm may terminate faster in period 
of synchrony if the leader be non-faulty because they do not have to run through the t+ 1 rounds, a explain 
in [13]. These leader-based approach require a period of synchrony long enough not only for consensus to 
terminate, provide that the leader be non-faulty or the value be stable [46], but also to elect a non-faulty leader 
or obtain a stable value. Another interest point be that PBFT executes O(t) round in which all non-faulty 
process broadcast 2t + 1 checkpoint messages, which result in O(n4) bit exchange when t = Ω(n), 
whereas in our multivalued consensus algorithm, all the non-faulty process broadcast in each of O(t) round 
of n binary consensus instances, lead to the same O(n4) bit complexity. 

16 



To bypass the difficulty of elect a leader in the presence of Byzantine failures, a synchronous Byzantine 
agreement that implement a virtual leader be propose [41], it avoids have to detect and remove a malicious 
leader. Similar to our algorithm, process exchange proposal that they record in a vector where proposal 
from non-faulty process be identical. The main difference be that it assumes that process synchronize their 
clock a it require the vector to be full and contain proposal from all non-faulty process within some fix 
time ∆ [40]. Our approach be different a we do not need the vector to be full or to contain proposal from all 
non-faulty processes, we simply apply the result of the binary consensus instance a a bitmask to the vector. 

To conclude, our algorithm do not need a leader, make it harder to delay termination. In addition, while 
our algorithm be base on a rotate coordinator it do not require t+ 1 round to terminate if good condition 
be met, in which case non-faulty process can decide even in round coordinate by faulty processes. 

Unrestricted blockchains Original blockchain system like Bitcoin [56] and Ethereum [66] target a peer-to- 
peer model where the number of process be frequently change and be not know by processes. Their con- 
sensus algorithm rely on process to generate a computationally-intensive proof-of-work to limit the power of 
malicious process when try to reach consensus. The drawback be that they usually solve consensus prob- 
abilistically [27]. To improve the scalability of Bitcoin, Bitcoin-NG [22] solves a variant of consensus with 
probabilistic termination and probabilistic agreement by rely on a leader. Elastico [44] reach a variant 
of consensus whose propose value satisfy a specific predicate function among subcommittee of c process 
each, but require the communication to be synchronous. 

Private and consortium blockchains With the advent of private and consortium blockchains, where the 
participation be restrict to n processes, new blockchain system suggest the use of classic Byzantine fault 
tolerant algorithm (e.g., [16]) when n > 3t. After the seminal PBFT approach, several implementation be 
propose to reduce latency when n > 5t (e.g., [46]), simplify the development (e.g., [1]) or trade fault-tolerance 
for performance (e.g., [43]). Tendermint consensus us a variant of PBFT with a rotate leader election [38]. 
Ripple’s consensus algorithm relies on unique node list that define a quorum system where sufficient node 
be control by the Ripple company [63]. Stellar us adaptive quorum system to implement consensus [47]. 
R3 have just release Corda that may use a Byzantine fault tolerant algorithm or a crash-tolerant consensus 
algorithm with strong assumption [30]. Hyperledger Fabric [12] us PBFT but should provide support to a 
variant of Apache Kafka in the near future. A recent implementation [48] suggest to reach consensus with a 
probabilistic termination. 

7 Conclusion 

This paper have present a new multivalued Byzantine consensus algorithm tailor for consortium blockchains. 
It be asymptotically time optimal and resilience optimal and do not rely on a leader, randomization or sig- 
natures. It combine a reduction from multivalued to binary consensus that applies a bitmask to an array of 
proposal and a binary consensus to build this bitmask. By spawn binary consensus instance in parallel, 
our reduction be a far a we know the first to decide a non-predefined value in a sequence of O(1) binary 
consensus instances. 

Despite the large interest in blockchains (and cryptocurrency applications), there be relatively few result 
on the formalization of this problem. Our paper try to address this limitation by formalize the blockchain 
consensus a a general variant of Byzantine consensus. The result algorithm decouples the problem of 
validate a block from the problem of decide on a block; it build upon the number n of consortium member 
to avoid Sybil attacks; and it be indulgent in that safety be not affected when communication be delayed. 

17 



Acknowledgements 

Tyler Crain and Vincent Gramoli be support by the Australian Research Council’s Discovery Projects fund- 
ing scheme (project number 160104801). Vincent Gramoli be the recipient of the Australian Research Council 
Discovery International Award. Mikel Larrea be support by the Spanish Research Council, grant TIN2016- 
79897-P, and the Basque Country Research Council, grant IT980-16 and MV_2016_1_0031. Michel Raynal 
be support by the French ANR project DESCARTES (grant 16-CE40-0023-03) devote to distribute soft- 
ware engineering. 

References 
[1] Aublin P.-L., Guerraoui R., Knezevic N., Quema V., and Vukolić M., The next 700 BFT protocols. ACM Transactions on 

Computer Systems, 32(4), Article 12, 45 page (2015) 

[2] Aspnes J., Randomized protocol for asynchronous consensus. Distributed Computing, 16(2-3):165-175 (2003) 

[3] Berman P. and Garay J.A., Cloture voting: n/4-resilient distribute consensus in t + 1 rounds. Mathematical System Theory, 
26(1):3-19 (1993) 

[4] Ben-Or M., Another advantage of free choice: completely asynchronous agreement protocols. Proc. 2nd Annual ACM Sympo- 
sium on Principles of Distributed Computing (PODC’83), ACM Press, pp. 27-30 (1983) 

[5] Ben-Or M., Kelmer B., and Rabin T., Asynchronous Secure Computations with Optimal Resilience. Proc. Annual ACM Sympo- 
sium on Principles pp. 183-192 (1994) 

[6] Bonomi S., Del Pozzo A., Potop-Butucaru M., and Tixeuil S., Approximate Agreement under Mobile Byzantine Faults. Proc. 
36th IEEE International Conference on Distributed Computing Systems (ICDCS’16), pp. 727-728 (2016) 

[7] Borran F., Hutle M. and Schiper A., Timing analysis of leader-based and decentralize Byzantine consensus algorithms. Proc. 
5th Latin-American Symposium on Dependable Computing (LADC’11), IEEE Press, pp.166-175 (2011) 

[8] Bouzid Z., Mostéfaoui A., and Raynal M., Minimal synchrony for byzantine consensus. Proc. 34th Annual ACM Symposium on 
Principles of Distributed Computing (PODC’15), ACM press, pp. 461-470 (2015) 

[9] Bracha G., Asynchronous Byzantine agreement protocols. Information & Computation, 75(2):130-143 (1987) 

[10] Bracha G. and Toueg S., Asynchronous consensus and broadcast protocols. Journal of the ACM, 32(4):824-840 (1985) 

[11] Buterin V., Ethereum: platform review, opportunites and challenge for private and consortium blockchains (2016) 

[12] Cachin C., Blockchain - From the anarchy of cryptocurrencies to the enterprise. Keynote presentation at 20th Int’l Conference 
on Principles of Distributed Systems (OPODIS’16) (2016) 

[13] Cachin C., Guerraoui R., and Rodrigues L., Reliable and secure distribute programming, Springer, 367 page (2011) ISBN 
978-3-642-15259-7 

[14] Cachin C., Kursawe K., Petzold F., and Shoup V., Secure and Efficient Asynchronous Broadcast Protocols Proc. 21st Annual 
International Cryptology Conference (CRYPTO), pp.524-541, 2001 

[15] Cachin C., Kursawe K., and Shoup V., Random oracle in Constantinople: practical asynchronous Byzantine agreement use 
cryptography. Journal of Cryptology,18(3):219-246 (2005, first version: PODC 2000) 

[16] Castro M. and Liskov B., Practical Byzantine fault tolerance and proactive recovery. ACM Transactions on Computer Systems, 
20(4):398-461 (2002) 

[17] Chandra T., Hadzilacos V., and Toueg S., The weak failure detector for solve consensus. Journal of the ACM, 43(4):685-722 
(1996) 

[18] Chandra T. and Toueg S., Unreliable failure detector for reliable distribute systems. Journal of the ACM, 43(2):225-267 (1996) 

[19] Correia M., Ferreira Neves N., and Verissimo P., From consensus to atomic broadcast: time-free Byzantine-resistant protocol 
without signatures. The Computer Journal, 49(1):82-96 (2006) 

[20] Dolev D., Dwork C. and Stockmeyer L., On the minimal synchronism need for distribute consensus. Journal of the ACM, 
34(1):77-97 (1987) 

[21] Dwork C., Lynch N., and Stockmeyer L., Consensus in the presence of partial synchrony. Journal of the ACM, 35(2):288-323 
(1988) 

i 



[22] Eyal I., Gencer A.E., Sirer E.G., and van Renesse R., Bitcoin-NG: a scalable blockchain protocol. Proc. 13th Usenix Conference 
on Networked Systems Design and Implementation (NSDI’16), pp.45-59 (2016) 

[23] Fischer M.J. and Lynch N.A., A low bound for the time to assure interactive consistency. Information Processing Letters, 
14(4):183-186 (1982) 

[24] Fischer M.J., Lynch N.A., and Paterson M.S., Impossibility of distribute consensus with one faulty process. Journal of the 
ACM, 32(2):374-382 (1985) 

[25] Friedman R., Mostéfaoui A., Rajsbaum S., and Raynal M., Distributed agreement problem and their connection with error- 
correct codes. IEEE Transactions on Computers, 56(7):865-875 (2007) 

[26] Friedman R., Mostéfaoui A., and Raynal M., Simple and efficient oracle-based consensus protocol for asynchronous Byzantine 
systems. IEEE Transactions on Dependable and Secure Computing, 2(1):46-56 (2005) 

[27] Garay J., Kiayias A., and Leonardos, N. The Bitcoin Backbone Protocol: Analysis and Applications. Advances in Cryptology - 
EuroCrypt, pp. 281-310. (2015) 

[28] Guerraoui R., Indulgent algorithms. Proc. 19th Annual ACM Symposium on Principles of Distributed Computing (PODC’00), 
ACM Press. pp. 289-297. (2000) 

[29] Hadzilacos V. and Toueg S., On deterministic abortable objects. Proc. 32th Annual ACM Symposium on Principles of Distributed 
Computing (PODC’13), ACM Press, pp.4-12 (2013) 

[30] Hearn M., Corda: a distribute ledger. Version 0.5 (2016) 

[31] Herlihy M., Distributed compute and blockchains. Keynote presentation at 18th Int’l Symposium on Stabilization, Safety, and 
Security of Distributed Systems (SSS’16) (2016) 

[32] Herlihy M.P. and Wing J.M, Linearizability: a correctness condition for concurrent objects. ACM Transactions on Programming 
Languages and Systems, 12(3):463-492 (1990) 

[33] Imbs D. and Raynal M., Trading t-resilience for efficiency in asynchronous Byzantine reliable broadcast. Parallel Processing 
Letters, 26(4), 8 page (2017) 

[34] Kihlstrom K.P., Moser L.E., and Melliar-Smith P.M., Byzantine fault detector for solve consensus. The Computer Journal, 
46(1):16-35 (2003) 

[35] King V. and Saia J., Byzantine agreement in expect polynomial time. Journal of the ACM, 63(2), Article 13, 21 page (2016) 

[36] Kotla R., Alvisi L., Dahlin M., Clement A., and Wong E.L., Zyzzyva: speculative Byzantine fault tolerance. ACM Transactions 
on Computer Systems, 27(4):7:1-7:39 (2009) 

[37] Kursawe K., Optimistic asynchronous Byzantine agreement. Manuscript (2000) 

[38] Kwong J., Tendermint: Consensus without mining. v.0.7 (2016) 

[39] Lamport L., Time, clocks, and the order of event in a distribute system. Communications of the ACM, 21(7):558-565 (1978) 

[40] Lamport L., Leaderless Byzantine consensus. United States Patent, Microsoft Corporation, Redmond, WA (USA) (2010) 

[41] Lamport L., Leaderless Byzantine Paxos. Proc. 25th International Simposium on Distributed Computing. (DISC’11), pp.141-142 
(2011) 

[42] Lamport L., Shostack R., and Pease M., The Byzantine general problem. ACM Transactions on Programming Languages and 
Systems, 4(3)-382-401 (1982) 

[43] Liu S., Viotti P., Cachin C., Quéma V., and Vukolić M., XFT: practical fault tolerance beyond crashes. Proc. 12th USENIX 
Symposium on Operating Systems Design and Implementation (OSDI’16), ACM Press, pp. 485-500 (2016) 

[44] Luu L., Narayanan V., Zheng C., Baweja K., Gilbert S. and Saxena P., A secure sharding protocol for open blockchains. ACM 
Conference on Computer and Communications Security (CCS’16), ACM Press, pp. 17-30 (2016) 

[45] Lynch N.A., Distributed algorithms. Morgan Kaufmann Pub., San Francisco (CA), 872 page (1996) ISBN 1-55860-384-4 

[46] Martin J.-Ph. and Alvisi L., Fast Byzantine consensus. IEEE Transactions on Dependable and Secure Computing, 3(3):202-215 
(2006) 

[47] Mazieres D., The stellar consensus protocol: A federate model for internet-level consensus. (2015) 

[48] , Miller A., Xia Y., Croman K., Shi E., and Song D., The Honey Badger of BFT Protocols Proc. of the 2016 ACM SIGSAC 
Conference on Computer and Communications Security, p.31-42 (2016) 

ii 



[49] Mostéfaoui A., Moumen H., and Raynal M., Signature-free asynchronous binary Byzantine consensus with t < n/3, O(n2) 
messages, and O(1) expect time. Journal of ACM, 62(4), Article 31, 21 page (2015) 

[50] Mostéfaoui A., Mourgaya E., and Raynal M., Asynchronous implementation of failure detectors. Int’l IEEE Conference on 
Dependable Systems and Networks (DSN’03), IEEE Computer Press, pp. 351-360 (2003) 

[51] Mostéfaoui A., Rajsbaum S., and Raynal M., Conditions on input vector for consensus solvability in asynchronous distribute 
systems. Journal of the ACM, 50(6):922-954 (2003) 

[52] Mostéfaoui A. and Raynal M., k-Set agreement and limited accuracy failure detectors. Proc. 19th ACM SIGACT-SIGOPS Int’l 
Symposium on Principles of Distributed Computing (PODC’00), ACM Press, pp. 143-152 (2000) 

[53] Mostéfaoui A. and Raynal M., Intrusion-tolerant broadcast and agreement abstraction in the presence of Byzantine processes. 
IEEE Transactions on Parallel and Distributed Systems, 27(4):1085-1098 (2016) 

[54] Mostéfaoui A. and Raynal M., Signature-free asynchronous Byzantine systems: from multivalued to binary consensus with 
t < n/3, O(n2) messages, and constant time. Acta Informatica, DOI 10.1007/s00236-016-0269-y, 20 page (2016) 

[55] Mostéfaoui A., Tronel F., and Raynal M., From binary consensus to multivalued consensus in asynchronous message-passing 
systems. Information Processing Letters, 73:207-213 (2000) 

[56] Nakamoto S., Bitcoin: a peer-to-peer electronic cash system. http://www.bitcoin.org (2008) 

[57] Natoli C. and Gramoli V., The balance attack against proof-of-work blockchains: The R3 testbed a an example. arXiv, technical 
report 1612.09426 (2016) 

[58] Natoli C. and Gramoli V., The blockchain anomaly. Proc. 5th IEEE Int’l Symposium on Network Computing and Applications 
(NCA’16), IEEE ComputerPress, pp. 310-317 (2016) 

[59] Pease M., R. Shostak R., and Lamport L., Reaching agreement in the presence of faults. Journal of the ACM, 27:228-234 (1980) 

[60] Rabin M., Randomized Byzantine generals. Proc. 24th IEEE Symposium on Foundations of Computer Science (FOCS’83), IEEE 
Computer Society Press, pp. 116-124(1983) 

[61] Raynal M., Communication and agreement abstraction for fault-tolerant asynchronous distribute systems. Morgan & Clay- 
pool, 251 page (2010) ISBN 978-1-60845-293-4 

[62] Schneider F.B., Implementing fault-tolerant service use the state machine approach. ACM Computing Surveys, 22(4):299-319 
(1990) 

[63] Schwartz A.B.D. and Youngs N., The ripple protocol consensus algorithm. Ripple Labs Inc. (2014) 

[64] Stolz D. and Wattenhofer R., Byzantine Agreement with Median Validity. Proc. 19th International Conference on Principles of 
Distributed Systems (OPODIS’15), pp. 22:1-22:14 (2015) 

[65] Turpin R. and Coan B.A., Extending binary Byzantine agreement to multivalued Byzantine agreement. Information Processing 
Letters, 18:73-76 (1984) 

[66] Wood G., Ethereum: A secure decentralize generalize transaction ledger. White paper (2015) 

[67] Zhang J. and Chen W., Bounded cost algorithm for multivalued consensus use binary consensus instances. Information Pro- 
cessing Letters, 109:10056-1009 (2009) 

A A BV-broadcast algorithm 

A simple self-explanatory algorithm implement the BV-broadcast abstraction in the system modelBAMPn,t[t < 
n/3] be described in Figure 4. A proof of it can be found in [49] where BV-broadcast be use in the context 
of randomize consensus. 

B Correctness proof of the 3Synch algorithm with Byzantine tolerant dis- 
tributed clock 

It be possible to replace the timeouts use in the algorithm in Figure 3 and to relax the assumption that processing 
time be null with the Byzantine fault tolerant distribute clock of [21] to decide when process can move 
forward in rounds. We have then the follow lemma, which be then use instead of Lemma 12 in the proof of 
Theorem 3. 

Lemma 15. Let u consider the algorithm of Figure 3 with the addition of Byzantine fault tolerant distribute 
clock from [21]. Eventually the non-faulty process attain a round from which they behave synchronously. 

iii 



operation BV_broadcast MSG(vi) be 
(01) broadcast B_VAL(vi). 

when B_VAL(v) be receive 
(02) if 

( 
B_VAL(v) receive from (t+ 1) different process and B_VAL(v) not yet broadcast 

) 
(03) then broadcast B_VAL(v) // a process echo a value only once 
(04) end if; 
(05) if 

( 
B_VAL(v) receive from (2t+ 1) different process 

) 
(06) then bin_valuesi ← bin_valuesi ∪ {v} // local delivery of a value 
(07) end if. 

Figure 4: An algorithm implement BV-broadcast in BAMPn,t[t < n/3] (from [49]) 

C Correctness proof of the 3Synch algorithm with a catch-up mechanism 

From asynchrony to synchrony Here a catch-up mechanism be provide a a modification to the algorithm 
in Figure 3 that ensures process eventually execute synchronous round where non-faulty process may 
observe time at different rate and processing time be non-negligible. 

Lemma 12 ensures that all non-faulty process eventually participate in synchronous round in a system 
where eventually the non-faulty processor run at the same speed and computation time be negligible. As 
this timing assumption cannot be ensure in all systems, this section extends the algorithm with a catch-up 
mechanism, which guarantee progress in system where the difference in process speed be bound by some 
unknown constant. 

As we have seen, in order to guarantee a decision, after the assume 3Synch assumption holds, it be need 
that eventually all non-faulty process execute round synchronously. Observe that, due to initial asynchrony, 
non-faulty process can start the consensus algorithm at different instants. Moreover, due to the potential 
participation of Byzantine processes, some non-faulty process can advance round –without deciding– while 
other non-faulty process be still execute previous rounds. 

Before describe the catch-up mechanism the mini-round notation will be defined. Each round r be split 
into two mini-rounds, with the first mini-round represent line 03 to (New4) and the second represent 
line M-06 to 12. Like rounds, mini-rounds can be identify by a number with the first mini-round start at 
0 and increase by one. For example round 3 be make up of mini-rounds 6 and 7. 

Catch-up mechanism The mechanism that allows non-faulty process to catch up relies on the follow 
two change to the algorithm10: 
• First, the timer be start only when the condition of line M-05 and M-07 be satisfied, i.e., on line 

M-05 only once bin_values i[ri] 6= ∅ be true, be the timer started. Similarly on line M-07 the timer be only 
start when n − t AUX[ri]() message satisfy the condition be received. Let the timeout start at 0 
on mini-round 0 and grow by 1 each mini-round. 
• Second, when a process be in a mini-round ρ and receives message correspond to another mini-round 
ρ′ > ρ from (t+ 1) different process (i.e., from at least one non-faulty process), the process no longer 
wait for timer in mini-rounds ρ, .., (ρ′ − 1). It still completes these mini-rounds, but do it without 
wait for timer expiration. 

The idea of these mechanism be to allow late or slow non-faulty process to catch up to the most advanced 
non-faulty process (as measure by their mini-round number). 

We assume that each process have a local clock that allows it to measure time units. Time unit will be 
give in integers. A process us it local clock to measure the amount of time it wait for a timeout (where 
a timeout of 1 be 1 time unit). The notation t with a subscript (for example tfirst0) will be use to represent 
a time measurement that be give by the number of time unit that have pass since the algorithm started, a 
measure by an omniscient global observer G. By 3Synch , process be able to observe time at different 
rates, but within an unknown fix bound. For simplicity assume that the fast process observes time at a rate 
no faster than observe by the global observer G and all other process observe time at this rate or slower. 

Notations Similarly to previous sections, the follow notation and definition be use in the following. 
• δ be a fixed, but unknown bound on message transfer delay a ensure by 3Synch and measure in time 

unit a observe by G. 
10Similar mechanism be use by PBFT [16]. 

iv 



• tfirstρ be the time, a measure by G, at which the first non-faulty process pfirstρ reach mini-round ρ 
(tfirst0 be the time at which the first non-faulty process start the consensus). 
• tlastρ be the time, a measure by G, at which the last non-faulty process plastρ reach mini-round ρ 

(tlast0 be the time at which the last non-faulty process start the consensus). 
• θfast (resp. θslow) be the minimum (resp. maximum) amount of time, a observe by G, for any process 

to perform the computation of any mini-round (a unknown bound difference between θfast and θslow 
be ensure by 3Synch). 
• γfastρ be the minimum amount of time, a observe by G, in a mini-round ρ that any process wait on 

line M-05 or M-07 before start it timer for that mini-round. 
• Mini-round ρδ be the first mini-round where timeout > δ. 

Lemma 16. Consider the algorithm of Figure 3 enrich with the previous catch-up mechanism. There be a 
mini-round ρt such that in ρt and all follow mini-rounds all non-faulty process must wait for at least part 
of the timeout, i.e., they do not receive t+ 1 message from a round large than ρt until after they start wait 
at the timeout of round ρt. 

Proof Let u only consider mini-rounds where ρt > ρδ. For all non-faulty process to wait at a timeout in 
a mini-round ρt the last non-faulty process to arrive at that mini-round must arrive before it could receive a 
message from some other non-faulty process that be execute a late mini-round (note that give ρt > ρδ, this 
can only be ensure when the process be no more than 1 mini-round apart), i.e., the follow must hold: 

tlastρt < tfirstρt+1 . (4) 

Let u now find when this can be satisfied. By definition, a process can spend no less time than (γfastρ′ + 
θfast + timeout) in a mini-round ρ′. Given that the timeout start at 0 on mini-round 0 and grows by 1 in each 
mini-round, timeout can be replace with ρ for any mini-round ρ. We then have: 

tfirstρ′ ≥ tfirstρδ + 

ρ′−1∑ 
x=ρδ 

γfastx + θfast + x 

 . 
Notice that from the component 

∑ρ′−1 
x=ρδ 

x (i.e., the timeout), the value of tfirstρ′ be quadratic in the number of 
mini-rounds. 

Now consider the slowest non-faulty process start from mini-round ρδ that do not wait at a timeout. 
This process can spend no more time in a mini-round ρ′ than 2 message delay plus the processing time for 
the mini-round, i.e., 2 × δ + θslow. The reason for this be a follows: To complete the mini-round the process 
must satisfy the condition on line M-05 or M-07. Keep in mind that, give that the process do not wait at a 
timeout, it must have receive t + 1 message from a late mini-round, meaning that some non-faulty process 
have already complete ρ′. Line M-05 require (bin_values i[ri] 6= ⊥). It be know that a non-faulty process 
have complete this round and that process have therefore already satisfied this condition, and that all non-faulty 
process have execute line 04 (given that this be the slowest process). With this, and the BV-Uniformity 
property of the BV_broadcast() operation, all non-faulty process will have a value in bin_values i[ri] after 
at most 2 message delay after the slowest process executes the BV_broadcast(). Similarly, on line M-07 all 
non-faulty process will receive the n − t AUX message need to satisfy the condition in 1 message delay 
after the slowest non-faulty process broadcast it AUX message, but may need to wait another message delay 
in case a non-faulty process have a value enter it bin_values i[ri] immediately before broadcasting it AUX 
message. We then have: 

tlastρ′ ≤ tlastρδ + 

ρ′−1∑ 
x=ρδ 

2× δ + θslow 

 . 
Notice that the value of tlastρ′ be linear in the number of mini-rounds. 

Now give tfirstρ′ be quadratic while tlastρ′ be linear, inequality (4) must eventually be satisfied, thus there 
will be a mini-round where all non-faulty process wait for at least part of their timeout. 

It will now be show by induction that after timeout > (2×δ+θslow) inequality (4) hold for all follow 
mini-rounds. Consider tlastρt < tfirstρt+1 be satisfied, let u now show that tlastρt+1 < tfirstρt+2 be satisfied 
a well. For this to not hold, the slowest non-faulty process must spend more time on round ρt than the fast 

v 



non-faulty process spends on round (ρt + 1). Given that ρt > ρδ, process plastρt must receive (t+ 1) message 
from round (ρt + 1) before process pfirstρt+1 completes round (ρt + 1). Once these message be receive we 
have already show that this process will take no more than 2 × δ + θslow time to complete the round. Thus, 
a long a timeout > (2 × δ + θslow), which will eventually be true give 3Synch and the grow timeout, 
process plastρt will reach round (ρt + 1) before pfirstρt+1 reach round (ρt + 2). 2Lemma 16 

Lemma 17. Consider the algorithm of Figure 3 enrich with the previous catch-up mechanism. Eventually 
the non-faulty process attain a mini-round from which they behave synchronously. 

Proof By Lemma 16 it be know that there exists a mini-round ρt where all non-faulty process wait for at 
least part of their timeout. This be ensure after round where timeout > (2× δ + θslow). Consider we be in 
such rounds. Now for a mini-round to be synchronous, all non-faulty process need to arrive at that mini-round 
with enough time to broadcast it message to all non-faulty process before any non-faulty process move 
onto the next mini-round. In the case that the last non-faulty process to arrive at the round be the coordinator, it 
may take up to 3 message delay before it COORD_VALUE[r]() message be receive by all non-faulty process 
(this include up to 2 message delay until a value enters it bin_values[r] and an additional message delay to 
broadcast COORD_VALUE[r]()). Notice that before a non-faulty process start it timer for a mini-round it must 
wait until the condition on line M-05 or M-07 be satisfied. Thus, for a mini-round ρ′t to by synchronous where 
ρ′t ≥ ρt, the follow need to be ensured: 

tlastρ′t 
+ (3× δ) + θslow ≤ tfirstρ′t + γfastρ′t + timeout. (5) 

By time (tfirstρ′t 
+ γfastρ′t 

+ θfast) at least one process have satisfied the condition on line M-05 or M-07 (this 

be give by the definition of γ). As a result all process will receive (t + 1) message from mini-round ρ′t by 
time (tfirstρ′t 

+ γfastρ′t 
+ θfast + δ). Now give Lemma 16 and that (ρ′t − 1) > δ, it be know that that the 

slowest process be no further behind than wait at the timeout of mini-round (ρ′t − 1). After get these 
(t + 1) message from mini-round ρ′t the slow process will then skip the timeout of mini-round (ρ 

′ 
t − 1) and 

reach the follow mini-round in at most 2 additional message delay (2 message delay be need for the 
same reason give in Lemma 16 to satisfy the condition line M-05 or M-07) plus any processing time, i.e.: 

tlastρ′t 
≤ tfirstρ′t + γfastρ′t + θfast + θslow + (3× δ). 

Now plug this into inequality (5) lead to timeout ≥ (7× δ) + (2× θslow) + θfast (note that 2× θslow be 
include to account for possible processing time in both round (ρ′t − 1) and ρ′t). But give that the timeout 
grows in each mini-round and that δ, θfast, and θslow be bound by 3Synch there will eventually be a mini- 
round where this hold true. 

Finally, notice that a long a the timeout be this large (i.e. timeout ≥ (7 × δ) + (2 × θslow) + θfast) 
and Lemma 16 hold then the above argument be valid for any round. Now give that timeout ≥ (7 × δ) + 
(2 × θslow) + θfast be large than the timeout need for Lemma 16 to hold for every follow round, once 
inequality (5), i.e. synchrony, it true for one round, it will also hold for every follow round. 2Lemma 17 

vi 


Introduction 
Basic Byzantine Computation Model and Reliable Broadcast 
Base computation model 
Reliable broadcast in Byzantine system 

Blockchain Byzantine Consensus 
Multivalued Byzantine consensus with predicate-based validity 
Binary Byzantine consensus 

From Multivalued to Binary Consensus in a Byzantine System 
The reduction 
Correctness proof 

Binary Consensus in Eventually Synchronous Byzantine Systems 
The BV-broadcast all-to-all communication abstraction 
A safe binary Byzantine consensus algorithm in BAMPn,t[t<n/3] 
Safety proof 
Eventual synchrony assumption 
A binary Byzantine consensus algorithm in BAMPn,t[t<n/3,Synch] 
Proof of the Synch-based algorithm 

Related Work 
Conclusion 
A BV-broadcast algorithm 
Correctness proof of the Synch algorithm with Byzantine tolerant distribute clock 
Correctness proof of the Synch algorithm with a catch-up mechanism 

