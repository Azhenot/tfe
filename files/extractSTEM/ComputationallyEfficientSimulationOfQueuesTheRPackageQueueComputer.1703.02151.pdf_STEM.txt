




















































comput effici simul of queues: the R packag queuecomput 


comput effici simul of queues: 

the R packag queuecomput 

anthoni ebert 
queensland univers of technolog 

acem 

paul Wu 
queensland univers of technolog 

acem 

kerri mengersen 
queensland univers of technolog 

acem 

fabrizio ruggeri 
cnr-imati 

queensland univers of technolog 
acem 

abstract 

larg network of queue system model import real-world system such a 
mapreduc clusters, web-servers, hospitals, call-cent and airport passeng terminals. 
To model such system accur we must infer queue paramet from data. unfor- 
tunately, for mani queue network there be no clear way to proceed with paramet 
infer from data. approxim bayesian comput could offer a straight-forward 
way to infer paramet for such network if we could simul data quickli enough. 

We present a comput effici method for simul from a veri gener set of 
queue network with the R packag queuecomputer. remark speedup of more 
than 2 order of magnitud be observ rel to the popular de packag simmer 
and simpy. We replic output from these packag to valid the package. 

the packag be modular and integr well with the popular R packag dplyr. complex 
queue network with tandem, parallel and fork/join topolog can easili be built with 
these two packag together. We show how to use thi packag with two examples: a 
call-centr and an airport terminal. 

keywords: queues, queue theory, discret event simulation, oper research, approxi- 
mate bayesian computation, R. 

1. introduct 

the queue we encount in our everyday experience, where custom wait in line to be serv 
by a server, be a use analog for mani other processes. We say analog becaus the word 
custom could represent: mapreduc job (lin, zhang, wierman, and tan 2013); patient 
in a hospit (takagi, kanai, and misu 2016); item in a manufactur system (dalleri 
and gershwin 1992); call to a call center (gans, koole, and mandelbaum 2003); ship 
contain in a seaport (kozan 1997) or even cognit task (cao 2013). similarli server 
could represent: a comput cluster; medic staff; machineri or a custom servic represen- 
tativ at a call centre. queue system can also be network togeth to form queue 

ar 
X 

iv 
:1 

70 
3. 

02 
15 

1v 
2 

[ 
st 

at 
.C 

O 
] 

3 
0 

A 
pr 

2 
01 

7 



2 queuecomputer: comput effici simul of queue 

networks. We can use queue network to build model of process such a provis of in- 
ternet servic (sutton and jordan 2011), passeng facilit at intern airport (wu 
and mengersen 2013) and emerg evacu (van woensel and vandael 2007). clearli 
queue system and queue network be use for understand import real-world 
systems. 

perform measur for a give queue system can often onli be deriv through simula- 
tion. queue be usual simul with discret event simul (des) (rio insua, ruggeri, 
and wiper 2012, pg. 226). In de chang in state be discontinuous. the state be act 
upon by a countabl list of event at certain time which caus the discontinuities. If the 
occurr of an event be independ of everyth except simul time it be determined, 
otherwis it be conting (nanc 1981). 

popular de softwar packag be avail in mani program languag including: the R 
packag simmer (ucar and smeet 2016), the python (van rossum and drake 2014) packag 
simpi (lünsdorf and scherfk 2013) and the java (gosl 2000) packag jmt (bertoli, 
casale, and serazzi 2009). de packag be often so express that they can be consid 
languag in their own right, inde the program languag simula (dahl and nygaard 
1966) be a liter exampl of this. 

queuecomput (ebert 2016) implement an algorithm that can easili be appli to a wide 
rang of queue system and network of queue systems. It be vastli more computation- 
alli effici than exist approach to des. We term thi new comput effici 
algorithm queue departur comput (qdc). comput effici be import be- 
caus if we can simul from queue quickli then we can emb a queue simul within an 
approxim bayesian comput (abc) algorithm (sunn̊aker, busetto, numminen, coran- 
der, foll, and dessimoz 2013) and estim queue paramet for veri complic queue 
model in a straight forward manner. 

In section 2 we review the literatur on queue theori and develop notat use through- 
out thi paper. In section 3 we present the qdc algorithm and compar it to des. We 
demonstr usag of the packag in section 4. detail of implement and usag be dis- 
cuss in section 5. the packag be valid in section 6 by replic result from de 
packag simpi and simmer. We compar comput perform measur from the out- 
put of a queuecomput simul to theoret result for m/m/2 queue systems. We 
benchmark the packag in section 7 and compar comput time with simpi and simmer. 
exampl in section 8 be use to demonstr how the packag can be use to simul a 
call centr and an intern airport terminal. 

2. queue theori 

queue theori be the studi of queue system and origin from the work of agner 
krarup erlang in 1909 to plan infrastructur requir for the danish telephon system 
(thomopoulo 2012, pg 2). 

A queue system be defin a follows. each custom i = 1, 2, · · · have an arriv time ai (or 
equival an inter-arriv time δi = ai − ai−1, a0 = 0) and an amount of time they requir 
with a server, call the servic time si. typic a server can serv onli one custom at 
a time. A server which be current serv anoth custom be say to be unavailable, a 
server without a custom be available. If all server be unavail when a custom arriv 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 3 

then custom must wait in the queue until a server be available. detail introduct to 
queue system can be found in standard text such a bhat (2015). 

the characterist of a queue system be express with the notat of kendal (1953). 
thi notat have sinc be extend to six characteristics: 

• fδ, inter-arriv distribution; 

• fs, servic distribution; 

• K, number of server ∈ N; 

• C, capac of system ∈ N; 

• n, custom popul ∈ N; and 

• R, servic disciplin 

choic for inter-arriv and servic distribut be denot by “m” for exponenti and 
independ distributed, “gi” for gener and independ distribut and “g” for gener 
without the independ assumption. the capac of the system C refer to the maximum 
number of custom within the system at ani one time1. custom be within the system if 
they be be serv or wait in the queue. the custom popul n be the total number 
of custom includ those outsid of the system (yet to arriv or alreadi departed). the 
servic disciplin R defin how custom in the queue be alloc to avail servers. the 
most common servic disciplin be first come first serv (fcfs). To specifi a queue system, 
these characterist be place in the order give abov and separ by a forward slash “/”. 

the simplest queue system be exponenti in distribut for both the inter-arriv δi 
iid∼ 

exp(λ) ∀i ∈ 1 : n and servic process si 
iid∼ exp(µ) ∀i ∈ 1 : n, where λ and µ be exponenti 

rate parameters. additionally, K be set to 1, C and n be infinit and R be fcfs. It be denot 
by m/m/1/∞/∞/fcfs, which be shorten to m/m/1. 
paramet infer for thi system be consid first by clark (1957), estim be 
deriv from the likelihood function. thi likelihood be late use by muddapur (1972) to 
deriv the joint posterior distribution. bayesian infer for queue system be summaris 
in detail by rio insua et al. (2012). 

manag and planner be less interest in paramet infer and more interest in 
perform measur such as: n(t), the number of custom in system at time t; b̄, the 
averag number of busi servers; ρ, the resourc utilization; and w̄, the averag wait time for 
customers. If λ < Kµ the queue system will eventu reach equilibrium and distribut 
of perform measur becom independ of time. 

In the case of a m/m/k system equilibrium distribut for perform measur be 
deriv analytically, they be found in standard queue theori textbook (lipski 2008; 
thomopoulo 2012). for instanc the limit probabl of N custom in the system p(n) be 

1if the system be at full capac and new custom arrive, new custom leav the system immedi 
without be served. 



4 queuecomputer: comput effici simul of queue 

p(0) = 

[ 
(kρ)k 

k!(1− ρ) 
+ 1 + 

k−1∑ 
i=1 

(kρ)i 

i! 

]−1 
(1) 

p(n) = 

{ 
p(0) (kρ) 

n 

N ! N ≤ K 
p(0) (kρ) 

n 

k!kn−k 
otherwis 

(2) 

where ρ, the resourc utilization, be defin a λkµ . for an m/m/k system thi be equal to 

the expect number of busi server divid by the total number of server e(b)k (cassandra 
and lafortun 2009, pg. 451). the expect number of custom in the system be (bhat 
2015) 

e(n) = kρ+ 
ρ(kρ)kp (0) 

k!(1− ρ)2 
, (3) 

and the expect wait time be 

e(w) = 
(kρ)kp (0) 

k!kµ(1− ρ)2 
. (4) 

If the paramet of fδ and f be uncertain then we must turn to predict distribut for 
estim of perform measures. predict distribut of perform measur use 
bayesian posterior distribut be deriv by armero (1994); armero and bayarri (1999). 

jackson (1957) be one of the first to consid network of queue systems. In a jackson 
network there be a set of J queue systems. after a custom be serv by queue system 
j they arriv at anoth queue system with fix probabl pj,k. custom leav the 

system with probabl 1 − 
∑J 

k=1 pj,k. other exampl of queue network includ the 
tandem (glynn and whitt 1991), parallel (hunt and foot 1995) and the fork/join (kim and 
agrawala 1989) topologies. 

In a tandem queue network, custom travers an order seri of queue befor depart 
the system. real exampl of such system includ airport terminals, internet servic and 
manufactur systems. In a parallel network, custom be partit into differ (a, s) 
to be see by separ queue systems. In a fork/join network a task (anoth term for 
customer) be fork into a number of subtask which be to be complet by distinct parallel 
servers. the differ from the parallel network be that the task can onli depart the system 
onc all subtask have arriv at the join point. 

most model of queue system assum time-invari inter-arriv and servic processes. 
In practic mani real-world queue have inter-arriv process which be strongli time- 
dependent, such as: call-centr (weinberg, brown, and stroud 2007; brown, gans, mandel- 
baum, sakov, shen, zeltyn, and zhao 2005), airport runway (koopman 1972) and hospit 
(brahimi and worthington 1991). In the case of the m/m/1 queue we can adapt the notat 
to m(t)/m(t)/1 to repres exponenti process where paramet λ(t) and µ(t) chang 
with time. such queue system be refer to a dynam queue systems. 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 5 

In general, analyt solut do not exist for dynam queue system (malon 1995; wor- 
thington 2009). green, kolesar, and svorono (1991) show that use stationari queue 
system to model dynam queue system lead to seriou error even if deviat from 
stationar be slight. the problem be compound onc we consid queue networks. un- 
derstand long-term and transient behaviour of such queue can onli be achiev with 
approxim method or simulation. We now detail the qdc algorithm, a comput 
effici method for simul queue systems. 

3. queue departur comput 

3.1. fix number of server 

qdc can be consid a a multi-serv extens to an algorithm present by lindley 
(1952). for a singl server queue system, the departur time of the ith custom is: 
di = max (ai, di−1) + si, sinc the custom either wait for a server or the server wait for 
a customer. the algorithm (not the paper) was, surprisingly, not extend to multi-serv 
system until krivulin (1994). howev with each new custom i the algorithm must search 
a grow i + 1 length vector. thi algorithm therefor scale poorly, with comput 
complex o(n2), where n be number of customers. kin and chan (2010) adapt the origin 
algorithm of kiefer and wolfowitz (1955) to an o(nk) algorithm for multiserv tandem 
queue with blocking, that be g/g/k/c queue system where C be the maximum capac 
number of custom in the queue systems. 

qdc can also be view a a comput effici solut to the set of equat pre- 
sent in sutton and jordan (2011, pg. 259) for fcf queue systems. there be a singl 
queue serv by a fix number of K servers. the ith custom observ a set of time 
bi = {bik|k ∈ 1 : K} which repres the time when each server will next be available. the 
custom i select the earli avail server pi = argmin(bi) from bi. the departur time 
for the ith custom be therefor di = max(ai, bpi) + si, sinc the server must wait for the 
custom or the custom must wait for the server. the qdc algorithm for a fix number of 
server (algorithm 1) pre-sort the arriv times. rather than assign a bi for each custom 
i to form the matrix b ∈mn×k , qdc consid b a a continu updat K length vector 
repres the state of the system. 

thi algorithm be simpl and comput efficient. At each iter of the loop we need 
onli search b, a K length vector for the minimum element in code line 8. In the languag 
of des, we consid b a the system state and a a the event list, which be all determin 
events. thi differ from convent de approach to model queue system where 
the queue length be the system state and both a and d constitut the event list, where 
the event of a be determin and the event of d be continu updat and therefor 
contingent. 

algorithm 1 can simul ani queue of the form g(t)/g(t)/k/∞/n/fcf where K and n 
can be make arbitrarili large. furthermore, the inter-arriv and servic distribut can be 
of complet gener form and even have a depend structur between them. sinc the 
arriv and servic time be suppli by the user rather than sampl in-situ, the algorithm 
“decouples” statist sampl from queue computation. thi free the user to simul 
queue of arbitrarili complex fδ,s, where K be fixed. 



6 queuecomputer: comput effici simul of queue 

algorithm 1 qdc for fix K 

1: function qdc numeric(a ∈ rn+, s ∈ rn+,k ∈ N) 
2: sort (a, s) in term of a (ascending) 
3: creat vector p ∈ nn. 
4: creat vector b ∈ rk+ . 
5: creat vector d ∈ rn+. 
6: bk ← 0 ∀k ∈ 1 : K 
7: for i ∈ 1 : n do 
8: pi ← arg min(b) 
9: bpi ← max(ai, bpi) + si 

10: di ← bpi 
11: end for 
12: put (a,d,p) back to origin (input) order of a 
13: return (d,p) 
14: end function 

3.2. chang number of server 

condit case 

suppos that the number of server that custom can use chang throughout the day. thi 
reflect realist situat where more server be roster on for busier time of the day. We 
say that for a certain time t, the custom have a choic of k(t) open server from K. thi 
mean that there be k(t) server rostered-on for time t. We defin the term close a the 
opposit of open. 

We repres the number of open server throughout the day a a step function. time be on 
the posit real number line and be partit by L knot locat x = (x1, · · · , xl) ∈ rl+ 
into L + 1 epoch (0, x1], (x1, x2], · · · , (xl,∞). the number of open server in each epoch be 
repres by a L + 1 length vector y = (y1, · · · , yl+1) ∈ nl+10 . If we assum that none of 
the servic time s span the length of more than one epoch (xl, xl+1], formal 

∀i [si < min(xl+1 − xl|l ∈ 1 : l)] , (5) 

then we need consid a chang in state over at most 1 knot location. thi step function be 
determin input by the user. like the arriv and servic time (a, s) it be changeabl by the 
user befor the simul but not dure the simulation. 

We close server k by write an∞ symbol to bk ensur that no custom can use that server. 
If the server need to be open again at time t we write t to bk allow custom to use that 
server. sinc x now correspond to chang in b it be part of the event list along with a. the 
entir event list be still determin and need not be updat mid-simulation. 

thi algorithm can simul queue of form g(t)/g(t)/k(t)/∞/n/fcfs, where k(t) refer 
to the number of open server chang with time. As mention previous thi algorithm be 
subject to condit 5, thi condit be not overli restrict if we consid realist system 
with few chang in K. the record server alloc p = (p1, · · · , pn) may not reflect the 
real system sinc algorithm 2 do not allow the user to specifi exactli which server be 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 7 

algorithm 2 qdc for k(t) (conditional) 

1: function qdc server.stepfun(a ∈ rn+, s ∈ rn+,x ∈ rl+,i ∈ nl+10 ) 
2: sort (a, s) in term of a (ascending) 
3: xl+1 ←∞ 
4: yl+2 ← 1 
5: K ← max(y) 
6: creat vector b ∈ rk+ . 
7: bk ←∞ ∀k ∈ 1 : K 
8: bk ← 0 ∀k ∈ 1 : y0 
9: creat vector p ∈ nn. 
10: creat vector d ∈ rn+. 
11: l← 1 
12: p1 ← 1 
13: for i ∈ 1 : n do 
14: 
15: // adjust to b with chang in epoch 
16: if ∀k ∈ 1 : K [bk ≥ xl+1] OR ai ≥ xl+1 then 
17: if yl+1 − yl > 0 then 
18: for k ∈ (yl + 1 : yl+1) do 
19: bk ← xl+1 
20: end for 
21: end if 
22: if yl+1 − yl < 0 then 
23: for k ∈ (yl+1 + 1 : yl) do 
24: bk ←∞ 
25: end for 
26: end if 
27: l← l + 1 
28: end if 
29: // end of adjust to b with chang in epoch 
30: 
31: pi ← arg min(b) 
32: bpi ← max(ai, bpi) + si 
33: di ← bpi 
34: 
35: // extra loop if current size be zero so that custom i can be process in next epoch 
36: if yl = 0 then 
37: i← i− 1 
38: end if 
39: 
40: end for 
41: put (a,d,p) back to origin (input) order of a 
42: return (d,p) 
43: end function 

open in each epoch, onli how mani be open and closed. If thi output be need or in case 
where condit 5 do not hold, we must use the less comput effici but more 
gener uncondit algorithm below. 

uncondit case 

If condit 5 do not hold or if otherwis we wish to control exactli which server be open 
at what time then we must use a less comput effici algorithm (algorithm 4). each 
server k have it own partit of Lk knot locat xk = (xk,1, · · · , xk,lk) ∈ R 

Lk 
+ and each 



8 queuecomputer: comput effici simul of queue 

yk = (yk,1, · · · , yk,lk+1) be an altern sequenc of 0 and 1 of length Lk indic whether 
the server be open or close respect for the associ epoch. the vector c be use slightli 
differ to how it be use in sutton and jordan (2011). We use it to repres the time at 
which each server be next avail for the current custom i, give the current system state 
b. It be the output of the next_fun function. 

algorithm 3 next function 

function next fun(t,x ∈ rl+,y) 
find l such that xl < t ≤ xl+1. 
if yl+1 = 0 then 

return xl+1 
els 

return t 
end if 

end function 

algorithm 4 qdc for k(t) (unconditional) 

1: function qdc server.list(a ∈ rn+, s ∈ rn+,x = (x1, · · · ,xk),i = (y1, · · · ,yk)) 
2: sort (a, s) in term of a (ascending) 
3: ∀k ∈ 1 : K xk,lk+1 ←∞ 
4: ∀k ∈ 1 : K yk,lk+2 ← 1 
5: K ← length(x) 
6: creat vector c ∈ rk+ 
7: creat vector b ∈ rk+ 
8: bk ← 0 ∀k ∈ 1 : K 
9: creat vector p ∈ nn. 

10: creat vector d ∈ rn+. 
11: for i ∈ 1 : n do 
12: for k ∈ 1 : K do 
13: ck ← next fun(max(bk, ai),xk,yk) 
14: end for 
15: pi ← arg min(b) 
16: bpi ← cpi + si 
17: di ← bpi 
18: end for 
19: put (a,d,p) back to origin (input) order of a 
20: return (d,p) 
21: end function 

thi algorithm can simul queue system of form g(t)/g(t)/k(t)/∞/n/fcfs, where 
k(t) refer to the number of open server chang with time. In addit we can specifi 
which particular server be avail when, not just how mani and we be not bound by 
condit 5. onc again we note that b can be consid a the system state and the event 
list be form by a and the element of x. thi function can be call with the queue_step 
function in queuecomput by suppli a server.list object to the server argument. for 
the rest of thi paper we focu on algorithm 1 and 2 for their rel conceptu simplic 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 9 

and comput efficiency. 

3.3. discuss 

with the algorithm so far present we can simul from a veri gener set of queue 
system g(t)/g(t)/k(t)/∞/n/fcf in a comput effici manner. In contrast to 
the algorithm of kin and chan (2010), the state vector b be write over in each iteration. 
the memori usag for qdc therefor scale with o(n) rather than o(nk). 

tandem queue network can be simul by use the output of one queue system a 
the input to the next queue system. We demonstr thi idea with the airport simul 
exampl in section 8.2. fork/join queue network be address in the next section where 
we explain the implement detail of queuecomput with regard to the qdc algorithm. 

4. usag 

the purpos of the packag queuecomput be to compute, deterministically, the output of a 
queue system give the arriv and servic time for all customers. the most import 
function be queue_step. the first argument to queue_step be a vector of arriv times, the 
second argument be a vector of servic time and the third argument specifi the server 
available. 

R> library("queuecomputer") 

R> arriv <- cumsum(rexp(100)) 

R> head(arrivals) 

[1] 0.693512 1.693399 2.425550 3.952405 3.961906 4.405492 

R> servic <- rexp(100) 

R> departur <- queue_step(arrivals, servic = service, server = 2) 

R> departur 

# A tibble: 100 × 6 
arriv servic departur wait system_tim server 

<dbl> <dbl> <dbl> <dbl> <dbl> <dbl> 

1 0.693512 0.830158956 1.523671 0.000000e+00 0.830158956 1 

2 1.693399 0.817648174 2.511047 1.110223e-16 0.817648174 2 

3 2.425550 0.002675641 2.428226 2.138047e-16 0.002675641 1 

4 3.952405 0.667180991 4.619586 4.440892e-16 0.667180991 1 

5 3.961906 0.551920432 4.513827 4.440892e-16 0.551920432 2 

6 4.405492 1.069236762 5.583063 1.083341e-01 1.177570886 2 

7 4.594253 1.110448926 5.730035 2.533279e-02 1.135781711 1 

8 4.993053 0.766944956 6.350008 5.900099e-01 1.356954853 2 

9 6.047412 0.805061421 6.852474 1.110223e-16 0.805061421 1 

10 6.856338 1.317802131 8.174140 0.000000e+00 1.317802131 2 

# ... with 90 more row 



10 queuecomputer: comput effici simul of queue 

the output of a queue_step function be a queue_list object. We built a summari method 
for object of class queue_step, which we now demonstrate. 

R> summary(departures) 

total customers: 

100 

miss customers: 

0 

mean wait time: 

0.246 

mean respons time: 

1.11 

util factor: 

0.53 

mean queue length: 

0.301 

mean number of custom in system: 

1.36 

If the last element of y be zero it be possibl that some custom will never be served, thi be 
the “miss customers” output. the perform measur that follow be the mean wait 
time w̄, the mean respons time r̄ = d − a, the observ util factor b̄/k, the mean 
queue length and the mean number of custom in the system respectively. the util 
factor b̄/k take into account the chang number of open server k(t) where algorithm 2 
be used. We now explain the implement detail of package. 

5. implement 

the for loop within algorithm 1 and 2 be write in c++ with the armadillo librari 
(sanderson and curtin 2016). the c++ for loop be call use the R packag rcpp 
(eddelbuettel, françois, allaire, chambers, bates, and ushey 2011) and rcpparmadillo 
(eddelbuettel and sanderson 2014). We use R to provid wrapper function for the c++ 
code. 

the queue_step call the more primit queue function which be a wrapper for S3 method 
which implement algorithm 1, 2 or 4 depend on the class of the object suppli to the 
server argument of queue_step. If class(server) be numer then queue run algorithm 
1, if it be a server.stepfun then queue run algorithm 2, if it be a server.list then queue 
run algorithm 4. the queue function comput departur time d and server alloc p 
and the queue_step function add addit output such a wait time and queue length 
which be use in summari and plot methods. 

To simul fork/join network the queuecomput function wait_step provid a simpl 
wrapper to the base function pmax.int, thi function comput the maximum of each row for 
a set of two equal length numer vectors. the vector repres the departur time for each 
subjob and the departur time for the entir job be the maximum of each subjob. 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 11 

In simmer and simpi user suppli gener function for simul δ and servic time s, 
the user enter the set of input paramet θI for these gener function and start the 
simulation. the inter-arriv time be resampl after each arriv and the servic time be 
sampl when the server begin with a new customer. thi make it difficult to model queue 
where distribut for inter-arriv time do not make sense: like the immigr counter for 
an airport, where multipl flight gener customers; or when arriv time and servic time 
be not independent. In queuecomput sampl be “decoupled” from computation, the user 
sampl a and servic time s use ani method. the output d and p be then comput 
deterministically. 

We now demonstr the valid of queuecomputer’ output by replic result from the 
de packag simmer and simpy. We then replic equilibrium analyt result of perfor- 
manc measur for the m/m/2 queue. 

6. valid 

6.1. comparison with simmer and simpi 

To demonstr the valid of the algorithm we consid a m/m/2/∞/1000/fcf queue. 
If qdc be valid for ani m/m/k queue system then it be valid for ani g(t)/g(t)/k queue- 
ing system. thi be becaus ani non-zero (a, s) could conceiv come from two exponenti 
distributions, even if the probabl of the particular realiz be vanishingli small. We 
replic exact departur time comput with the simmer and simpi packag use queue- 
computer. first we gener a and s to be use a input to all three packages. 

R> set.seed(1) 

R> n_custom <- 10^4 

R> lambda_a <- 1/1 

R> lambda_ <- 1/0.9 

R> interarriv <- rexp(n_customers, lambda_a) 

R> arriv <- cumsum(interarrivals) 

R> servic <- rexp(n_customers, lambda_s) 

We now input these object into the three script use queuecomputer, simmer, or simpy. 
first we run the queuecomput script. the queuecomputer_output object be sort in 
ascend order so that the departur time can be compar to the de packages. 

R> queuecomputer_output <- queue_step(arriv = arrivals, 

+ servic = service, server = 2) 

R> head(sort(depart(queuecomputer_output))) 

[1] 1.340151 2.288112 2.639976 2.796572 3.249794 5.714967 

the de packag simmer and simpi be not built to allow user to input (a, s) directly. 
rather, the user suppli paramet for fδ and f so that inter-arriv and servic time can 
be sampl at each step when needed. To allow simmer and simpi to accept presampl input 



12 queuecomputer: comput effici simul of queue 

(a, s) we use gener function in place of the usual rexp(rate) or random.expovariate(rate) 
call in R and python respectively, detail of thi work can be found in the supplementari 
material. We creat an interfac to simmer so that it can be call in the same way a 
queuecomputer. 

R> simmer_output <- simmer_step(arriv = arrivals, 

+ servic = service, server = 2) 

R> head(simmer_output) 

[1] 1.340151 2.288112 2.639976 2.796572 3.249794 5.714967 

the same departur time be observed. similarli in python we creat an interfac to simpi 
so that it can be call in a similar way to queuecomputer. 

python> simpy_step(interarrivals, service)[0:6] 

array([ 1.34015149, 2.28811237, 2.63997568, 2.79657232, 3.24979406, 

5.7149671 ]) 

A check of all three sort vector of d from each packag reveal that all be equal to 
within 5 signific figur for everi di, i = 1 : 1000. 

6.2. replic theoret result for m/m/3 

We use a m/m/3/∞/5 × 106/fcf simul in queuecomput to replic theoret 
equilibrium result for key perform indic for a m/m/2/∞/∞/fcf queue sys- 
tem. We set λ to 1 and set µ to 2. 

theoret result 

We first note that the traffic intens be ρ of 2/3 = 0.6̇, which should correspond to the 
averag number of busi servers. the probabl of N custom in the system be give by 
equat 2. We perform thi comput up to N = 20 and display the result in figur 1. 
the expect wait time be e(w) be 0.4̇ and the expect number of custom in the system 
e(n) be 2.8̇. 

simul result 

the input a and s must first be generated. 

R> set.seed(1) 

R> n_custom <- 5e6 

R> lambda <- 2 

R> mu <- 1 

R> interarriv <- rexp(n_customers, lambda) 

R> arriv <- cumsum(interarrivals) 

R> servic <- rexp(n_customers, mu) 

R> K = 3 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 13 

We now use the queue_step function and the summari method for queue_list object 
summary.queue_list to return observ key perform measures. 

R> mm3 <- queue_step(arriv = arrivals, servic = service, server = K) 

R> summary(mm3) 

total customers: 

5000000 

miss customers: 

0 

mean wait time: 

0.445 

mean respons time: 

1.44 

util factor: 

0.666 

mean queue length: 

0.889 

mean number of custom in system: 

2.89 

● 

●● 

● 

● 

● 

● 

● 

● 

● 
● 

0.00 

0.05 

0.10 

0.15 

0.20 

0.00 0.05 0.10 0.15 0.20 

theoret p(n) for m/m/2 

O 
b 

er 
ve 

d 
P 

(N 
) 

fr 
om 

s 
im 

ul 
at 

io 
n 

N 
● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

comparison of theoret and simul p(n) 

figur 1: comparison of theoret equilibrium p(n) and observ proport from simu- 
lation. observ N = 1 be obscur by N = 2. 

We see that the observ time averag number of busi server be 0.6661402 which be close to 
0.6̇ the valu for ρ. We can see that the observ mean wait time be close to the expect 
mean wait time. the expect number of custom in the system, from the distribut 



14 queuecomputer: comput effici simul of queue 

p(n) be close to the observ number of custom in the system. the entir distribut of 
p(n) be replic in figur 1. 

7. benchmark 

7.1. method 

the compar the comput effici of each packag we comput the departur time 
from a m/m/2/∞/n/fcf queue system, with λ = 1 and µ = 1.1̇. To understand how 
n affect comput time we repeat the experi 100 time for n = 102, 103, 105 and 106. 
We could onli repeat the n = 106 experi 10 time for simmer becaus of memori issues, 
we also repeat the experi at n = 107 for queuecomputer. We compar the median time 
take for each combin of packag and n. 

the simul be conduct on a system with intel (r) core(tm) i7-6700 cpu @ 3.40ghz 
run debian gnu/linux. the version of R be 3.3.3 “anoth canoe” with simmer version 
3.6.1 and queuecomput version 0.8.1. the version of python be 3.4.2 with simpi modul 
version 3.6.1. 

To ass the comput time for queuecomput and simmer we use the microbenchmark 
function from the microbenchmark packag (mersmann 2015) with time = 100 and comput 
the median. full detail can be found in the supplementari material. 

7.2. result and discuss 

the median comput time for each packag and for vari number of custom from 
100 to 106 custom (up to 107 custom for queuecomputer) be show in figur 2. We 
observ phenomen speedup for queuecomput compar to both packages: compar to 
simpi speedup of 50 (at 100 customers) to 600 (at 106 customers) be observed, and for 
simmer speedup of 170 (at 100 customers) to 3100 (at 106 customers) be observed. the 
speedup be low for small n sinc queuecomput approach a minimum comput time. 

simul 10 million custom take less than 1 second for queuecomputer. We see no reason 
whi queue of differ arriv and servic distribut should not have similar speedups. thi 
be because, a mention earlier, ani non-neg (a, s) could come from two exponenti 
distributions. 

clearli qdc and it implement queuecomput be a more comput effici 
way to simul queue system of the form g(t)/g(t)/k/∞/m/fcf than convent 
de algorithm implement by simpi and simmer. 

8. exampl 

8.1. call centr 

We demonstr queuecomput by simul a call centre. the arriv time for each cus- 
tomer be the time that they called, the servic time be how long it take for their problem to 
be resolv onc they reach an avail custom servic representative. let’ assum that 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 15 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

● 

1 

100 

10000 

1e+03 1e+05 1e+07 

number of custom 

C 
om 

pu 
ta 

tio 
n 

tim 
e 

(m 
s) 

packag 
● 

● 

● 

queuecomput 

simmer 

simpi 

benchmark of packag for m/m/2 simul 

figur 2: comput time in millisecond for vari number of passeng for each 
des/queu package. each packag return exactli the same set of departur times, sinc 
the same arriv and servic time be supplied. the comput time report here be the 
median time of 100 run for each number of custom and each package. intel (r) core(tm) 
i7-6700 cpu @ 3.40ghz run debian gnu/linux. 

the custom arriv by a homogen poisson process over the cours of the day. 

R> library("queuecomputer") 

R> library("randomnames") 

R> library("ggplot2") 

R> set.seed(1) 

R> interarriv <- rexp(20, 1) 

R> arriv <- cumsum(interarrivals) 

R> custom <- randomnames(20, name.ord = "first.last") 

We also need a vector of servic time for everi customer. 

R> servic <- rexp(20, 0.5) 

R> head(service) 

[1] 2.4245155 1.1304372 0.3815756 0.5626325 2.0107932 1.4076141 



16 queuecomputer: comput effici simul of queue 

We put the arriv and servic time into the queue_step function to comput the departur 
times. here we have set the number of custom servic repres to two. the “servers” 
argument be use for thi input. 

R> queue_obj <- queue_step(arrivals, service, server = 2, label = customers) 

R> head(queue_obj$departures_df) 

# A tibble: 6 × 7 
label arriv servic departur wait system_tim server 

<chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> 

1 kwabena 0.7551818 2.6669670 3.422149 0.000000e+00 2.666967 1 

2 beatriz 1.9368246 1.2434810 3.180306 0.000000e+00 1.243481 2 

3 dashawn 2.0825313 0.4197332 3.600039 1.097774e+00 1.517507 2 

4 karina 2.2223266 0.6188957 4.041045 1.199822e+00 1.818718 1 

5 ilea 2.6583952 2.2118725 5.811911 9.416435e-01 3.153516 2 

6 brianna 5.5533638 1.5483755 7.101739 2.220446e-16 1.548376 1 

We can see that kwabena arriv first but leaf after beatriz. thi be possibl becaus there 
be two servers. kwabena’ servic take so long that the next two custom be serv 
by the other server. it’ easi to see how the departur time be comput in thi simpl 
example. kwabena and beatriz be the first custom for each server so we can comput 
their departur time by just add their servic time to their arriv times. 

R> firstcustom <- arrivals[1:2] + service[1:2] 

R> firstcustom 

[1] 3.422149 3.180306 

dashawn howev have to wait for an avail server, sinc he arriv after the first two 
custom arriv but befor the first two custom departed. He must wait until one of 
these custom depart befor he can be served. We add the departur time of the first 
custom (beatriz) to hi servic time to comput hi departur time. 

R> firstcustomers[2] + service[3] 

[1] 3.600039 

So the first two custom have no wait time but dashawn have to wait for an avail 
server. We can comput the wait time for all three custom in thi manner: 

R> depart(queue_obj)[1:3] - arrivals[1:3] - service[1:3] 

[1] 0.000000 0.000000 1.097774 

the depart function be a conveni function for retriev the departur time from a 
queue_list object. the queue_step function return a queue_list object. there be a 
summari method for thi object within the queuecomput package, thi can be access by 
call summary(departures). 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 17 

R> summary(queue_obj) 

total customers: 

20 

miss customers: 

0 

mean wait time: 

1.15 

mean respons time: 

3.69 

util factor: 

0.834 

mean queue length: 

0.858 

mean number of custom in system: 

2.42 

the plot method in queuecomput for queue_list object us the plot packag ggplot2 
(wickham 2009) to return a list of plots. We produc four plots: a histogram of the arriv 
and departur time (figur 3); a plot of the queue length and number of custom in the 
system over time (figur 4); a plot of the wait and servic time for each custom (figur 
5); and a plot of the empir cumul distribut function for arriv and departur time 
(figur 6). these plot correspond to select 2, 5 and 6 in the which argument, a similar 
api to the plot.lm method in the stat packag (R core team 2016). 

R> plot(queue_obj, which = c(2, 4, 5, 6) 

notic that in figur 5, if we draw a horizont line anywher on the left-hand plot it will 
never pa through more than two red bars. thi must be the case otherwis a server would 
be serv more than one custom at a time. 

8.2. intern airport termin 

the packag integr natur with the popular data manipul R packag dplyr (wick- 
ham and francoi 2016). We demonstr how to integr queuecomput and dplyr with a 
more complex airport termin than befor (figur 7). passeng from a set of 120 flight 
disembark at the arriv concourse, and proceed through immigr use either the “smart 
gate” or the “manual gate” route, we therefor have two queue in parallel. the rout take 
(smart gate or manual gate) by each passeng be predetermined, but the server use by the 
passeng within these separ queue system be not. 

their bag be unload from the flight and proceed to the baggag hall with a delay, the 
divis of a passeng and bag be a fork/join network. the bag and passeng be fork 
at the arriv concours and join at the baggag hall. after immigr the passeng 
proceed on to the baggag hall where they pick up their bags. 

We have a synthet dataset of passeng ID from 120 flight flightno, with an averag of 
103.8 passeng per flight for a total of 20,758 passengers. the dataset includ (for each 



18 queuecomputer: comput effici simul of queue 

arriv departur 

0 10 20 30 0 10 20 30 

0 

1 

2 

3 

4 

time 

co 
un 

t 

histogram of arriv and departur time 

figur 3: histogram of arriv and departur time for all customers. 

0 

1 

2 

3 

4 

5 

0 10 20 30 

time 

N 
um 

be 
r 

of 
c 

u 
to 

m 
er 

s 

type 

custom in entir system 

custom in queue 

step function plot of custom in queue and system 

figur 4: plot of queue length and number of custom in system over time. 

passeng id): their flight number flightno, the arriv time of that flight arrival, the rout 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 19 

custom server 

0 

10 

20 

30 

T 
im 

e 

statu 

servic 

wait 

line rang plot of custom and server statu 

figur 5: wait and servic time for each customer. 

take (smart/manu gate) by that passeng route_imm, the arriv time to immigr after 
they walk through the termin arrival_imm and the servic time need by the passeng 
at their immigr queue system service_imm. 

R> passenger_df 

## # A tibble: 25,012 × 7 
## ID flightno arriv route_imm arrive_imm service_imm 

## <chr> <fctr> <dbl> <fctr> <dbl> <dbl> 

## 1 cordell, megan abi481 564.85 manual 566.8549 0.29075606 

## 2 matheson, dylan abi481 564.85 manual 566.8532 0.15927226 

## 3 avitia, rene abi481 564.85 manual 567.2014 0.22450319 

## 4 woods, tyrel abi481 564.85 smart gate 566.8377 0.18222445 

## 5 pope, christiana abi481 564.85 smart gate 566.0994 0.09031344 

## 6 espinoza, mariah abi481 564.85 smart gate 566.8928 0.43900281 

## 7 pacheco, charleen abi481 564.85 manual 567.5558 0.12917143 

## 8 harmon, brendan abi481 564.85 smart gate 566.3114 0.30565961 

## 9 william, gerardo abi481 564.85 smart gate 567.2563 0.31975687 

## 10 hood, colen abi481 564.85 smart gate 567.2181 0.33944458 

## # ... with 25,002 more rows, and 1 more variables: bag_tim <dbl> 

immigr process be split into two rout with the route_imm variable. the "smart 
gate" rout have 5 servers, wherea the "manual" rout have 10 server befor time 600, 12 
server between time 600 and time 780 and 8 server from time 780 onwards. We store thi 
inform in a new datafram call server_df. 



20 queuecomputer: comput effici simul of queue 

0.00 

0.25 

0.50 

0.75 

1.00 

0 10 20 30 

time 

E 
m 

pi 
ric 

al 
c 

um 
ul 

at 
iv 

e 
di 

st 
rib 

ut 
io 

n 
fu 

nc 
tio 

n 

key 

arriv 

departur 

empir distribut plot of arriv and departur time 

figur 6: empir cumul distribut function for arriv and departur times. for 
each time the differ of the function be equal to the number of custom current in the 
system (in queue and current be served). 

R> server_df <- data.frame(immigration_rout = c("smart gate", "manual")) 

R> server_df$serv <- 

+ list(5, as.server.stepfun(x = c(600,780), y = c(10,12,8))) 

To comput the departur time from the parallel server we use the dplyr function group_by. 
the dataset be then process a if it have be split in two. 

R> passenger_df <- left_join(passenger_df, server_df) 

## joining, by = "route_imm" 

R> passenger_df <- passenger_df %>% 

+ group_by(route_imm) %>% 

+ mutate( 

+ departures_imm = 

+ queue(arrive_imm, service_imm, server = servers[[1]]) 

+ ) %>% 

+ ungroup() %>% 

+ mutate(departures_bc = pmax.int(departures_imm, bag_time)) 

R> passenger_df %>% 

+ select(flightno, arrive_imm, departures_imm, departures_bc) 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 21 

figur 7: diagram of larg airport scenario, there be 120 flight in total and two multi-serv 
queue system oper in parallel. passeng be preassign to travel through either the 
“manual” or “smart gate” rout through immigration. the passeng and bag be “forked” 
when each aircraft arriv be be “joined” at the baggag hall. 

## # A tibble: 25,012 × 4 
## flightno arrive_imm departures_imm departures_bc 

## <fctr> <dbl> <dbl> <dbl> 

## 1 abi481 566.8549 578.8443 578.8443 

## 2 abi481 566.8532 578.6479 578.6479 

## 3 abi481 567.2014 579.6133 579.6133 

## 4 abi481 566.8377 571.9148 574.6535 

## 5 abi481 566.0994 570.2073 574.7161 

## 6 abi481 566.8928 572.2135 574.7912 

## 7 abi481 567.5558 579.9953 579.9953 

## 8 abi481 566.3114 570.6290 574.8944 

## 9 abi481 567.2563 573.3438 574.8996 

## 10 abi481 567.2181 573.1459 574.9295 

## # ... with 25,002 more row 

the column departures_imm repres the time at which passeng depart immigr 
after have be serv either through the manual counter of smart gate. the column 
departures_bc repres the time that custom leav with their bag from the baggag 
hall. wait time can be summaris with the summaris function from dplyr, here we 
comput summari of wait time for each flightno and immigr rout route_imm 
and a summari of wait time onli by route_imm. 

R> passenger_df %>% 



22 queuecomputer: comput effici simul of queue 

+ group_by(flightno, route_imm) %>% 

+ summarise( 

+ waiting_imm = mean(departures_imm - service_imm - arrive_imm), 

+ waiting_bc = mean(departures_bc - departures_imm) 

+ ) 

## source: local data frame [240 x 4] 

## groups: flightno [?] 

## 

## flightno route_imm waiting_imm waiting_bc 

## <fctr> <fctr> <dbl> <dbl> 

## 1 abi481 manual 11.2718493 6.292506 

## 2 abi481 smart gate 4.9586928 12.276112 

## 3 aeb843 manual 0.8497289 16.594387 

## 4 aeb843 smart gate 1.0133830 16.412237 

## 5 arh364 manual 12.5063642 3.795084 

## 6 arh364 smart gate 7.3569441 8.169201 

## 7 bch445 manual 1.8033024 13.700561 

## 8 bch445 smart gate 1.4368622 15.087956 

## 9 bjn726 manual 19.5150170 2.064476 

## 10 bjn726 smart gate 7.2110772 9.751714 

## # ... with 230 more row 

R> passenger_df %>% 

+ group_by(route_imm) %>% 

+ summarise( 

+ waiting_imm = mean(departures_imm - service_imm - arrive_imm), 

+ waiting_bc = mean(departures_bc - departures_imm) 

+ ) 

## # A tibble: 2 × 3 
## route_imm waiting_imm waiting_bc 

## <fctr> <dbl> <dbl> 

## 1 manual 8.252137 9.559913 

## 2 smart gate 4.488549 12.786145 

We can quickli build a complex dynam queue model involv tandem, parallel and 
fork/join topologies. the model be effici to compute, modular and easili extended. thi 
be achiev by combin the queuecomput and dplyr packages. 

9. conclus 

the R packag queuecomput implement qdc. It can be use to simul ani queue sys- 
tem or tandem network of queue system of gener form g(t)/g(t)/k(t)/∞/n/fcfs. 
fast algorithm for multi-serv queue system have be propos in the past (krivulin 
1994; sutton and jordan 2010; kin and chan 2010). these algorithm have gener littl 



anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 23 

manual smart gate 

400 600 800 1000 1200 400 600 800 1000 1200 

0 

200 

400 

600 

time (min sinc 12am) 

Q 
ue 

ue 
le 

ng 
th 

figur 8: queue length over the cours of the day for “manual” and“smart gate” immigr 
routes. 

●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● 
● 
●● 
●●●● 
● 
●● 
●● 
●●● 
● 
● 
●● 
● 
●● 
● 
●● 
●● 
●●●● 
●●● 
● 
●●● 
●● 

0 

10 

20 

30 

immigr baggag entire_termin 

area of airport termin 

W 
ai 

tin 
g 

tim 
e 

(m 
in 

) 

route_imm 

manual 

smart gate 

boxplot of wait time 

figur 9: boxplot of wait time for each stage of passeng process within the interna- 
tional airport terminal. 

notice, even in the case where their comput effici be demonstr (kin and chan 
2010). qdc be conceptu simpler, more effici memory-wis and modular. 

We valid qdc with analyt result and by replic output gener by exist de 
packag simpi and simmer. We observ speedup of up to 3 order of magnitude. the speed 



24 queuecomputer: comput effici simul of queue 

of the packag will allow queue simul to be emb within abc algorithms, which 
will be address in futur work. unlik exist de packages, sampl and departur time 
comput be clearli ‘decoupled’ and therefor allow the user to simul queue system 
with arriv and servic time distribut of arbitrari complexity. the packag integr 
well with the data manipul packag dplyr and these two packag togeth allow the 
user to quickli and easili simul queue network with parallel, tandem and fork/join 
topologies. 

acknowledg 

thi work be support by the australian research council centr of excel for math- 
emat and statist frontier (acems). thi work be fund through the australian 
research council (arc) linkag grant “improv the product and effici of aus- 
tralian airports” (lp140100282). 

refer 

armero C (1994). “bayesian infer in markovian queues.” queue systems, 15(1-4), 
419–426. 

armero C, bayarri M (1999). “deal with uncertainti in queue and network of queues: 
A bayesian approach.” 

bertoli M, casal G, serazzi G (2009). “jmt: perform engin tool for system 
modeling.” sigmetr perform. eval. rev., 36(4), 10–15. issn 0163-5999. doi: 
http://doi.acm.org/10.1145/1530873.1530877. 

bhat UN (2015). An introduct to queue theory: model and analysi in applications. 
birkhäuser. 

brahimi M, worthington DJ (1991). “queue model for out-pati appoint sys- 
tems—a case study.” journal of the oper research society, 42(9), 733–746. url 
http://link.springer.com/article/10.1057/jors.1991.144. 

brown L, gan N, mandelbaum A, sakov A, shen H, zeltyn S, zhao L (2005). “statist 
analysi of a telephon call center: A queueing-scienc perspective.” journal of the 
american statist association, 100(469), 36–50. 

cao S (2013). queue network model of human perform in complex cognit 
multi-task scenarios. ph.d. thesis, univers of michigan. url https://deepblue.lib. 
umich.edu/bitstream/handle/2027.42/102477/shicao_1.pdf?sequence=1. 

cassandra cg, lafortun S (2009). introduct to discret event systems. springer-verlag. 

clark AB (1957). “maximum likelihood estim in a simpl queue.” the annal of 
mathemat statistics, 28(4), 1036–1040. 

dahl oj, nygaard K (1966). “simula: An algol-bas simul language.” commu- 
nicat of the acm, 9(9), 671–678. 

http://dx.doi.org/http://doi.acm.org/10.1145/1530873.1530877 
http://dx.doi.org/http://doi.acm.org/10.1145/1530873.1530877 
http://link.springer.com/article/10.1057/jors.1991.144 
https://deepblue.lib.umich.edu/bitstream/handle/2027.42/102477/shicao_1.pdf?sequence=1 
https://deepblue.lib.umich.edu/bitstream/handle/2027.42/102477/shicao_1.pdf?sequence=1 


anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 25 

dalleri Y, gershwin SB (1992). “manufactur flow line systems: A review of model 
and analyt results.” queue systems, 12(1-2), 3–94. url http://link.springer. 
com/article/10.1007/bf01158636. 

ebert A (2016). queuecomputer: comput effici queue simulation. R packag 
version 0.6.1, url https://cran.r-project.org/package=queuecomputer. 

eddelbuettel D, françoi R, allair J, chamber J, bate D, ushey K (2011). “rcpp: seamless 
R and c++ integration.” journal of statist software, 40(8), 1–18. 

eddelbuettel D, sanderson C (2014). “rcpparmadillo: acceler R with high-perform 
c++ linear algebra.” comput statist & data analysis, 71, 1054–1063. 

gan N, kool G, mandelbaum A (2003). “telephon call centers: tutorial, review, and 
research prospects.” manufactur & servic oper management, 5(2), 79–141. url 
http://pubsonline.informs.org/doi/abs/10.1287/msom.5.2.79.16071. 

glynn pw, whitt W (1991). “departur from mani queue in series.” the annal of 
appli probability, pp. 546–572. url http://www.jstor.org/stable/2959706. 

gosl J (2000). the java languag specification. addison-wesley professional. 

green L, kolesar P, svorono A (1991). “some effect of nonstationar on multiserv 
markovian queue systems.” oper research, 39(3), 502–511. 

hunt cs, foot BL (1995). “fast simul of open queue systems.” simulation, 65(3), 
183–190. url http://sim.sagepub.com/content/65/3/183.short. 

jackson JR (1957). “network of wait lines.” oper research, 5(4), 518–521. 

kendal DG (1953). “stochast process occur in the theori of queue and their 
analysi by the method of the imbed markov chain.” the annal of mathemat 
statistics, pp. 338–354. 

kiefer J, wolfowitz J (1955). “on the theori of queue with mani servers.” transact of 
the american mathemat society, 78(1), 1–18. url http://www.jstor.org/stable/ 
1992945. 

kim C, agrawala AK (1989). “analysi of the fork-join queue.” ieee transact on 
computers, 38(2), 250–255. url http://ieeexplore.ieee.org/abstract/document/ 
16501/. 

kin W, chan V (2010). “gener lindley-typ recurs represent for multiserv 
tandem queue with blocking.” acm transact on model and comput simul 
(tomacs), 20(4), 21. url http://dl.acm.org/citation.cfm?id=1842726. 

koopman BO (1972). “air-termin queue under time-depend conditions.” oper 
research, 20(6), 1089–1114. 

kozan E (1997). “comparison of analyt and simul plan model of seaport 
contain terminals.” transport plan and technology, 20(3), 235–248. url 
http://www.tandfonline.com/doi/abs/10.1080/03081069708717591. 

http://link.springer.com/article/10.1007/bf01158636 
http://link.springer.com/article/10.1007/bf01158636 
https://cran.r-project.org/package=queuecomput 
http://pubsonline.informs.org/doi/abs/10.1287/msom.5.2.79.16071 
http://www.jstor.org/stable/2959706 
http://sim.sagepub.com/content/65/3/183.short 
http://www.jstor.org/stable/1992945 
http://www.jstor.org/stable/1992945 
http://ieeexplore.ieee.org/abstract/document/16501/ 
http://ieeexplore.ieee.org/abstract/document/16501/ 
http://dl.acm.org/citation.cfm?id=1842726 
http://www.tandfonline.com/doi/abs/10.1080/03081069708717591 


26 queuecomputer: comput effici simul of queue 

krivulin NK (1994). “A recurs equat base represent for the g/g/m 
queue.” appli mathemat letters, 7(3), 73–77. url http://www.sciencedirect. 
com/science/article/pii/0893965994901163. 

lin M, zhang L, wierman A, tan J (2013). “joint optim of overlap 
phase in mapreduce.” perform evaluation, 70(10), 720–735. url http://www. 
sciencedirect.com/science/article/pii/s0166531613000916. 

lindley DV (1952). “the theori of queue with a singl server.” In mathemat proceed 
of the cambridg philosoph society, volum 48, pp. 277–289. cambridg univ press. 
url http://journals.cambridge.org/article_s0305004100027638. 

lipski L (2008). queue theory: A linear algebra approach. springer-verlag. 

lünsdorf O, scherfk S (2013). simpy: discret event simul for python. python 
packag version 3.0.10, url https://simpy.readthedocs.io/en/latest/index.html. 

malon KM (1995). dynam queue systems: behavior and approxim for individu 
queue and for networks. ph.d. thesis, massachusett institut of technology. 

mersmann O (2015). microbenchmark: accur time functions. R packag version 
1.4-2.1, url https://cran.r-project.org/package=microbenchmark. 

muddapur M (1972). “bayesian estim of paramet in some queue models.” annal 
of the institut of statist mathematics, 24(1), 327–331. 

nanc RE (1981). “the time and state relationship in simul modeling.” communi- 
cation of the acm, 24(4), 173–179. 

R core team (2016). R: A languag and environ for statist computing. R founda- 
tion for statist computing, vienna, austria. url https://www.r-project.org/. 

rio insua D, ruggeri F, wiper M (2012). bayesian analysi of stochast process models, 
volum 978. john wiley & sons. 

sanderson C, curtin R (2016). “armadillo: A template-bas c++ librari for linear 
algebra.” journal of open sourc software, 1(2), 26–32. 

sunn̊ak M, busetto ag, numminen E, corand J, foll M, dessimoz C (2013). “approxi- 
mate bayesian computation.” plo comput biol, 9(1), e1002803. 

sutton C, jordan MI (2011). “bayesian infer for queue network and model of 
internet services.” the annal of appli statistics, pp. 254–282. 

sutton ca, jordan MI (2010). “infer and learn in network of queues.” In ais- 
tats, pp. 796–803. url http://www.jmlr.org/proceedings/papers/v9/sutton10a/ 
sutton10a.pdf. 

takagi H, kanai Y, misu K (2016). “queue network model for obstetr patient flow 
in a hospital.” health care manag science, pp. 1–19. url http://link.springer. 
com/article/10.1007/s10729-016-9363-5. 

http://www.sciencedirect.com/science/article/pii/0893965994901163 
http://www.sciencedirect.com/science/article/pii/0893965994901163 
http://www.sciencedirect.com/science/article/pii/s0166531613000916 
http://www.sciencedirect.com/science/article/pii/s0166531613000916 
http://journals.cambridge.org/article_s0305004100027638 
https://simpy.readthedocs.io/en/latest/index.html 
https://cran.r-project.org/package=microbenchmark 
https://www.r-project.org/ 
http://www.jmlr.org/proceedings/papers/v9/sutton10a/sutton10a.pdf 
http://www.jmlr.org/proceedings/papers/v9/sutton10a/sutton10a.pdf 
http://link.springer.com/article/10.1007/s10729-016-9363-5 
http://link.springer.com/article/10.1007/s10729-016-9363-5 


anthoni ebert, paul wu, kerri mengersen, fabrizio ruggeri 27 

thomopoulo NT (2012). fundament of queu systems: statist method for analyz- 
ing queu models. springer-verlag. 

ucar I, smeet B (2016). simmer: discrete-ev simul for R. R packag version 3.5.1, 
url https://cran.r-project.org/package=simmer. 

van rossum G, drake FL (2014). “the python languag reference.” https://docs.python. 
org/release/3.4.2/reference/index.html#reference-index. 

van woensel T, vandael N (2007). “model traffic flow with queue models: A 
review.” asia-pacif journal of oper research, 24(04), 435–461. url http: 
//www.worldscientific.com/doi/abs/10.1142/s0217595907001383. 

weinberg J, brown ld, stroud JR (2007). “bayesian forecast of an inhomogen pois- 
son process with applic to call center data.” journal of the american statist 
association, 102(480), 1185–1198. 

wickham H (2009). ggplot2: eleg graphic for data analysis. springer-verlag new york. 
isbn 978-0-387-98140-6. url http://ggplot2.org. 

wickham H, francoi R (2016). dplyr: A grammar of data manipulation. R packag version 
0.5.0, url https://cran.r-project.org/package=dplyr. 

worthington D (2009). “reflect on queue model from the last 50 years.” journal of 
the oper research society, 60(1), s83–s92. 

Wu ppy, mengersen K (2013). “A review of model and model usag scenario for an 
airport complex system.” transport research part A: polici and practice, 47, 124– 
140. 

affiliation: 

anthoni ebert 
school of mathemat scienc 
scienc and engin faculti 
queensland univers of technolog 
brisban queensland 4000, australia 
e-mail: ac.ebert@qut.edu.au 
url: https://bragqut.wordpress.com/people/anthony-ebert/ 

https://cran.r-project.org/package=simm 
https://docs.python.org/release/3.4.2/reference/index.html#reference-index 
https://docs.python.org/release/3.4.2/reference/index.html#reference-index 
http://www.worldscientific.com/doi/abs/10.1142/s0217595907001383 
http://www.worldscientific.com/doi/abs/10.1142/s0217595907001383 
http://ggplot2.org 
https://cran.r-project.org/package=dplyr 
mailto:ac.ebert@qut.edu.au 
https://bragqut.wordpress.com/people/anthony-ebert/ 


28 queuecomputer: comput effici simul of queue 

type notat definit 

queue 
specif 

λ rate paramet of exponenti inter-arriv distribut fδ = 
exp(λ) for m/m/k queue. 

µ rate paramet of exponenti servic distribut f = 
exp(µ) for m/m/k queue. 

ρ := λkµ traffic intensity, defin onli for m/m/k queues. 

θI paramet of arriv and servic joint distribut for qdc, 
(a, s) ∼ fa,s(·|θi). 

K number of servers. 
C capac of system. 
n total number of customers. 
R servic disciplin of queue. 
fcf first come first serv (type of servic discipline) 
L number of knot locat for server chang 

input/output 

a = (a1, · · · , an) arriv process, where ai be the time at which the ith cus- 
tomer arriv at the queue. 

δ = (δ1, · · · , δn) inter-arriv process, where δi be ai − ai−1 ∀i ∈ 1 : n and 
δ1 = a1. 

s = (s1, · · · , sn) servic process, where si be the servic time of the ith cus- 
tomer. 

d = (d1, · · · , dn) departur process, where di be the time at which the ith 
custom leaf the queue after be served. 

p = (p1, · · · , pn) server process, where pi be the server who serv the ith 
customer. 

b = (b1, · · · , bk) thi vector repres the time at which each server 1 : K 
will next be free. We consid thi vector to be the state of 
the system. 

x = (x1, · · · , xl) chang time for number of open servers. 
y = (y1, · · · , yl+1) number of open server in each epoch. 

perform 
measur 

n(t) number of custom in system at time t. 
B̄ time averag number of busi servers, refer to a “re- 

sourc utilization”. 
w̄ averag wait time per customer. 

tabl 1: notat and definitions. 


introduct 
queue theori 
queue departur comput 
fix number of server 
chang number of server 
condit case 
uncondit case 

discuss 

usag 
implement 
valid 
comparison with simmer and simpi 
replic theoret result for m/m/3 
theoret result 
simul result 


benchmark 
method 
result and discuss 

exampl 
call centr 
intern airport termin 

conclus 

