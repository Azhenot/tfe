


















































(leader/randomization/signature)-fre byzantin consensu for 
consortium blockchain 

tyler crain† vincent gramoli†,‡ mikel larrea†,§ michel raynal?,◦ 

† univers of sydney, australia 
{tyler.crain,vincent.gramoli}@sydney.edu.au 

‡ data61-csiro, australia 
§ univers of the basqu countri upv/ehu, spain 

mikel.larrea@ehu.eu 
? institut universitair de franc 

◦ irisa, université de rennes, franc 
raynal@irisa.fr 

may 5, 2017 

abstract 

thi paper present a new resili optim byzantin consensu algorithm target consortium 
blockchains. To thi end, it first revisit the consensu valid properti by requir that the decid valu 
satisfi a predefin predicate, which do not systemat exclud a valu propos onli by byzantin 
processes, therebi gener the valid properti found in the literature. then the paper present a 
simpl and modular byzantin consensu algorithm that reli neither on a leader, nor on signatures, nor 
on randomization. It consist of a reduct of multivalu byzantin consensu to binari byzantin con- 
sensu satisfi thi valid property. thi reduct termin after a constant-s sequenc of binari 
byzantin consensu instances. the idea be to spawn concurr instanc of binari consensu but to decid 
onli after a sequenc of two of these instances. the binari consensu instanc result in a bitmask that the 
reduct appli to a vector of multivalu propos to filter out a valid propos valu that be decided. the 
paper then present an underli binari byzantin consensu algorithm that assum eventu synchroni 
to terminate. 

keywords: asynchron message-pass system, binari consensus, byzantin process, consen- 
sus, consortium blockchain, eventu synchrony, leader-freedom, modularity, optim resilience, 
reduction, signature-freedom. 



1 introduct 

blockchain: a state machin replic paradigm blockchain, a origin coin in the semin bitcoin 
paper [56], be a promis technolog to track ownership of digit asset within a distribut ledger. thi 
technolog aim at allow process to agre on a seri of consecut block of transact that may 
invok contract function to exchang these assets. while the first instanc of these distribut ledger be 
access by internet user with no specif permissions, compani have sinc then success deploy other 
instanc in a consortium context, restrict the task of decid block to a set of care select institut 
with appropri permiss [11]. 

In 2016, multipl scientif event devot to blockchain-rel topic outlin the grow interest of the 
distribut comput commun in thi technology. these event includ dccl1, a satellit workshop of 
acm podc 2016 on the topic, and keynot talk present by C. cachin [12] and M. herlihi [31] at major 
distribut comput conferences. for the distribut comput community, a blockchain may seem like 
the applic of classic state machin replic [39, 62], where process can be byzantin [42], to the 
cryptocurr context. In the classic state machin replic paradigm, each command (or operation) can 
be invok at ani time by ani process, and be appli to the state machine, regardless of the previous appli 
commands. the goal in blockchain be for process to agre on the next block of transact to be append 
to the chain while the goal of a state machin replic be to agre on the next batch of command to appli to 
the state machine: both requir consecut consensu instances. 

A major distinct between blockchain and state machin replic is, however, the relat between 
consecut consensu instances. A blockchain requir each of it consensu instanc to be explicitli relat 
to the previou one. more precisely, for a block to be append it must explicitli contain inform point 
to the last block previous append to the blockchain. thi be typic implement use a collision- 
resili hash function that, when appli to the content of a block, output a hash identifi thi block. To 
be decided, a block propos in consensu instanc number x must emb the hash of the block decid at 
instanc number (x− 1). thi be the reason whi a blockchain typic start with process know about a 
special sentinel block that do not emb ani hash, name the genesi block. By contrast, the classic state 
machin replic simpli concaten consensu instanc one after the other without relat the input of a 
consensu instanc to the previou consensu instance: the result of a command may depend on the previou 
commands, but not the fact that it can be applied. In the terminolog use in [32], each command be total. 
while the total order be implementation-defin in classic state machin replication, it be determin (bi an 
application-defin hash function) in the blockchain. 

which kind of consensu for blockchains? thi relat between instanc be interest a it entail a 
natur mechan dure a consensu instanc for discard fake propos or, instead, consid that a 
propos be valid and could potenti be decided. provid that process have a copi of the blockchain 
and the hash function, they can local evalu whether each new block they receiv be a valid candid 
for a consensu instance: they simpli have to re-hash a block and compar the result to the hash emb 
in the new propos block. If the two hash differ, the new block be consid an invalid propos and be 
simpli ignored. If the hash be identical, then the block could potenti be decided. (whether thi block 
be eventu decid depend on addit well-formed properti of the block and the execut of the 
consensu instance.) thi valid gener common definit of byzantin consensus, that either assum 
that no valu propos onli by byzantin process can be decid [19, 49, 53], or, in the case where not all 
non-faulti process propos the same value, that ani valu can be decid (i.e., possibl a valu propos by 
a byzantin process) [21, 34, 45, 46, 61]. 

As it be imposs to solv consensu in asynchron message-pass system where even a singl pro- 
ce may crash (unexpect prematur stop) [24], it follow that it be also imposs to solv consensu in 
a more gener model like the one mention above. We list below the classic approach use in the past to 
circumv thi impossibility, name failur detectors, conditions, randomization, and eventu synchrony, and 
describ whi we believ that the addit synchroni assumpt be the most suit one for blockchains. 
• A classic approach in asynchron crash-pron system consist in provid process with informa- 

tion on failures. thi be the failur detector-bas approach [18]. It be show in [17] that the eventu 
leader failur detector Ω be the weak failur detector that allow consensu to be solv in the presenc 
of asynchroni and process crashes. failur detector suit to byzantin failur have be propos 

1https://www.zurich.ibm.com/dccl/. 

1 

https://www.zurich.ibm.com/dccl/ 


(e.g., [26, 34]), but, a they all be defin from the actual failur pattern, they be helpless when byzan- 
tine process propos valid values. moreover, when consid eventu leadership, a process may 
behav correctli from a leader elect point of view and behav in a byzantin way onc it have be 
elect leader. hence, leader-bas algorithm do not seem appropri to solv agreement issu on 
valid valu in the presenc of process with a byzantin behavior. 
• A second approach, call condition-based, consist in restrict the set of possibl input vector [51]. 

An input vector be a vector where each entri contain the valu propos by the correspond pro- 
cess. thi approach establish a strong connect relat byzantin agreement and error-correct 
code [25]. As the previou eventu leader-bas approach and due to the restrict it impos on input 
vectors, thi approach do not seem suit to blockchain-bas applic where process be not a 
priori restrict in their proposals. 
• A third approach consist in look for random consensu algorithm (e.g., [2, 4, 35, 49, 60]). In the 

context of byzantin failures, thi approach have mainli be investig for binari consensu algorithm 
(where the set of valu that can be propos be {0, 1}). algorithm that reduc multivalu byzantin 
consensu to binari byzantin consensu have be propos for both synchron system (e.g., [65]) 
and asynchron system (e.g., [53]). binari random algorithm reli on local coin (one coin per 
process [4]) or a common coin (a coin share by all process [60]). when local coin be used, the 
converg time to obtain the same valu be potenti exponential. when a common coin be used, the 
expect number of round can be a small constant (e.g., 4 round in [49]). however, the implement 
of a distribut common coin introduc an inher complex [15]. hence, it do not seem appropri 
for blockchain repeat consensus. 
• the fourth (but first in chronolog order) approach to circumv the asynchron consensu im- 

possibl in the presenc of faulti process be to enrich the system with an appropri synchroni 
assumpt [20, 21]. the weak synchroni assumpt that allow consensu to be solv be present 
in [8]. thi last approach (addit synchroni assumption) be the one we consid in thi paper. As 
the synchroni assumpt be assum to hold eventually, the consensu algorithm be indulg to initi 
arbitrari delay [28]: it alway preserv safety, and guarante live onc the synchroni assumpt 
holds. 

content of the paper thi paper present a time and resili optim byzantin consensu algorithm suit 
to consortium blockchains. As far a we know the term consortium blockchain be initi use in a blog 
post2 of the founder of ethereum [66], vitalik buterin, to refer to an intermedi blockchain model between 
public and fully-priv blockchain where onli a pre-select set of process can particip in the consensu 
and where the blockchain could potenti be access by anyone. the consortium blockchain be gener in 
contrast with public blockchains, where ani internet user could particip in the consensu algorithm, and 
fully-priv blockchains, where onli user of an institut can updat the state of the blockchain. public 
blockchain like bitcoin be gener pseudonym while fully-priv blockchain be typic centralized, 
which make consortium blockchain an appeal altern blockchain model for companies. A typic ex- 
ampl of consortium blockchain be the testb ran by r3, a consortium of more than 70 financi institut 
around the world.3 In 2016, R3 lead some experi on an ethereum consortium blockchain where ani insti- 
tution of the consortium could particip activ in the consensu instance. It be import to note that even 
within a consortium, one cannot reason assum synchron commun or failur limit to crashes. 
typically, the member of the consortium often have conflict interests—in the R3 consortium example, the 
bank of the consortium be competitors—and process cannot control the delay of messag a they typic 
use internet to commun where congest cannot be avoided. 

the byzantin consensu algorithm propos in the paper be design to compli with an extend definit 
of the consensu valid property. from a structur point of view, it be make of two components. 
• the first compon be a reduct of multivalu consensu to binari consensus. the reduction, which 

be fulli asynchronous, us neither randomization, nor an eventu leader, nor signatures. As far a we 
know, thi be the first asynchron reduct that alway decid a non-predetermin valu in o(1) 
sequenc of binari consensus. the reduct onli wait for the earli termin of the concurr 
reliabl broadcast instanc befor spawn binari consensu instances. As it assum t < n/3, where 
n be the number of process and t be an upper bound on the number of faulti processes, thi reduct be 

2https://blog.ethereum.org/2015/08/07/on-public-and-private-blockchains/. 
3http://www.r3cev.com/. 

2 

https://blog.ethereum.org/2015/08/07/on-public-and-private-blockchains/ 
http://www.r3cev.com/. 


resili optimal. 

• the second compon be a binari byzantin consensu (bbc) algorithm that requir neither random- 
ization, nor an eventu leader, nor signatures. It be base on an appropri binary-valu broadcast 
(bv-broadcast) abstraction, introduc for random consensu [49]. from a comput point of 
view, the bbc algorithm requir t < n/3 (a the previou reduction), and an addit synchroni as- 
sumption, namely, there be a time after which the transfer delay of the messag sent by the non-faulti 
process be upper bound by some constant (but neither the time at which thi occurs, nor the constant 
be know by the process [20, 21]). practically, thi mean that the bbc algorithm alway termin 
except if transfer delay be alway increas (in thi case, a differ synchroni assumpt such a the 
one describ in [50] can be used). the binari byzantin consensu alway termin in time o(1) if 
all non-faulti process propos the same value, otherwis it may still termin in constant time but be 
guarante to termin in o(t) time, which be optim [23]. 

the result multivalu byzantin consensu algorithm be resili optim (t < n/3) but also time optim 
a it termin in o(t). In addit to it optim and conceptu simplicity, the result multivalu 
byzantin consensu algorithm be well suit for consortium blockchain for the three follow reasons: 

1. the algorithm do not use an elect leader (that favor the valu propos by a particular process) or 
proof-of-work, mean that everi consensu particip play an equal role in propos a value. In 
particular, becaus it do not reli on the proof-of-work altern a in bitcoin or ethereum, a node 
of the consortium cannot outweigh other vote dure consensus. We alreadi note that one machin 
among the 50 machin of the R3 ethereum consortium in june 2016 own 12% of the total mine 
power of the R3 ethereum consortium blockchain, which give a signific advantag to thi machin 
to attack the blockchain [57]. 

2. the algorithm be indulg [28] in that it be alway safe despit arbitrari delays. We believ thi be an 
import properti for blockchain applic that trade million of us$ volum everi day4 a financi 
institut may prefer their blockchain servic to be unavail rather than compromis after conges- 
tion affect the internet commun delays. thi be typic in contrast with the ethereum algorithm 
use a a testb for the R3 consortium, where an attack can exploit network delay to doubl spend 
by decid two conflict block [58]. 

3. finally, becaus we focu on the consortium blockchain model where consensu particip be re- 
strict to the member of the consortium, we can assum that the ident of the n consortium mem- 
ber be know by all the participants. typic onli a subset of all blockchain particip particip 
in the consensus, e.g., onli n = 15 out of 50 process of R3 be particip in the consensu [57]. 
these ident provid a natur protect to our algorithm against sybil attack without the need for 
ani costli proof-of-work mechanisms. 

roadmap the paper be structur in 7 sections. section 2 present the comput model. section 3 intro- 
duce the blockchain byzantin consensus. section 4 present a reduct of multivalu byzantin consensu 
to binari byzantin consensus, and section 5 present a binari byzantin consensu that reli on an eventu 
synchroni assumption. the composit of these two algorithm provid a leader-free, randomization-fre and 
signature-fre multivalu byzantin consensus. section 6 present relat works. finally, section 7 conclud 
the paper. 

2 basic byzantin comput model and reliabl broadcast 
2.1 base comput model 

asynchron process the system be make up of a set Π of n asynchron sequenti processes, name 
Π = {p1, . . . , pn}; i be call the “index” of pi. “asynchronous” mean that each process proce at it 
own speed, which can vari with time and remain unknown to the other processes. “sequential” mean that a 
process execut one step at a time. thi do not prevent it from execut sever thread with an appropri 
multiplexing. 

As local process time be neglig with respect to messag transfer delays, they be consid a 
be equal to zero. (we show how to relax thi assumpt in appendic B and c.) both notat i ∈ Y and 
pi ∈ Y be use to say that pi belong to the set Y . 

4https://coinmarketcap.com/. 

3 

https://coinmarketcap.com/ 


commun network the process commun by exchang messag through an asynchron 
reliabl point-to-point network. “asynchronous” mean that there be no bound on messag transfer delays, but 
these delay be finite. “reliable” mean that the network do not lose, duplicate, modify, or creat messages. 
“point-to-point” mean that ani pair of process be connect by a bidirect channel. hence, when a 
process receiv a message, it can identifi it sender. 

A process pi send a messag to a process pj by invok the primit “send tag(m) to pj”, where tag 
be the type of the messag and m it content. To simplifi the presentation, it be assum that a process can send 
messag to itself. A process pi receiv a messag by execut the primit “receive()”. the macro-oper 
broadcast tag(m) be use a a shortcut for “for each pi ∈ Π do send tag(m) to pj end for”. 

failur model Up to t process can exhibit a byzantin behavior [59]. A byzantin process be a process 
that behav arbitrarily: it can crash, fail to send or receiv messages, send arbitrari messages, start in an arbi- 
trari state, perform arbitrari state transitions, etc. moreover, byzantin process can collud to “pollute” the 
comput (e.g., by send messag with the same content, while they should send messag with distinct 
content if they be non-faulty). A process that exhibit a byzantin behavior be call faulty. otherwise, it be 
non-faulty. 

let u notic that, a each pair of process be connect by a channel, no byzantin process can imperson 
anoth process. byzantin process can control the network by modifi the order in which messag be 
received, but they cannot postpon forev messag receptions. 

notat the acronym bampn,t[∅] be use to denot the previou basic byzantin asynchron message- 
pass comput model; ∅ mean that there be no addit assumption. 

2.2 reliabl broadcast in byzantin system 

definit thi broadcast abstract (in short, rb-broadcast) be propos by G. bracha [9]. It be a one-shot 
one-to-al commun abstraction, which provid process with two oper denot rb_broadcast() 
and rb_deliver(). when pi invok the oper rb_broadcast() (resp., rb_deliver()), we say that it “rb- 
broadcasts” a messag (resp., “rb-delivers” a message). An rb-broadcast instance, where process px be the 
sender, be defin by the follow properties. 
• rb-validity. If a non-faulti process rb-deliv a messag m from a non-faulti process px, then px 

rb-broadcast m. 
• rb-unicity. A non-faulti process rb-deliv at most one messag from px. 
• rb-termination-1. If px be non-faulti and rb-broadcast a messag m, all the non-faulti process 

eventu rb-deliv m from px. 
• rb-termination-2. If a non-faulti process rb-deliv a messag m from px (possibl faulty) then all 

the non-faulti process eventu rb-deliv the same messag m from px. 
the rb-valid properti relat the output to the input, while rb-unic state that there be no messag 

duplication. the termin properti state the case where process have to rb-deliv messages. the 
second of them be what make the broadcast reliable. It be show in [10] that t < n/3 be an upper bound on t 
when one have to implement such an abstraction. 

let u remark that it be possibl that a valu may be rb-deliv by the non-faulti process while it sender 
be actual byzantin and have not invok rb_broadcast(). thi may occur for exampl when the byzantin 
sender play at the network level, at which it sent sever messag to differ subset of processes, and the 
rb-deliveri predic of the algorithm implement the rb-broadcast abstract be eventu satisfi for 
one of these messages. when thi occurs, by abus of language, we say that the sender invok rb-broadcast. 
thi be motiv by the fact that, in thi case, a non-faulti process cannot distinguish if the sender be faulti or 
not. 

notat the basic comput model strengthen with the addit constraint t < n/3 be denotedbampn,t[t < 
n/3]. 

algorithm the algorithm describ in [9] implement rb-broadcast in bampn,t[t < n/3]. hence, it be 
t-resili optimal. thi algorithm requir three commun step to broadcast an applic message. 
An algorithm requir onli two commun step in the system model bampn,t[t < n/5] be present 
in [33]. 

4 



3 blockchain byzantin consensu 

As in all message-pass consensu algorithms, it be assum (in both the multivalu and binari consensu 
algorithm present below) that all non-faulti process propos a value. 

3.1 multivalu byzantin consensu with predicate-bas valid 
In thi paper we consid a gener of the classic byzantin consensu problem, inform state in the 
introduction. As it valid requir be motiv by blockchain and reli on an application-specif valid() 
predic to indic whether a valu be valid, we call thi problem the valid predicate-bas byzantin 
consensu (denot vpbc) and defin it a follows. assum that each non-faulti process propos a valid 
value, each of them have to decid on a valu in such a way that the follow properti be satisfied.5 

• vpbc-termination. everi non-faulti process eventu decid on a value. 
• vpbc-agreement. No two non-faulti process decid on differ values. 
• vpbc-validity. A decid valu be valid, it satisfi the predefin predic denot valid(). 

thi definit gener the classic definit of byzantin consensus, which do not includ the pred- 
icat valid(). As an example, in the crash failur model, ani propos valu be valid. In the basic byzantin 
consensus, ani propos valu be valid, except when all non-faulti process propos the same valu v, in 
which case onli v be valid. thi predic be introduc to take into account the distinct characterist of 
consortium blockchains, and possibl other specif byzantin consensu problems. In the context of consor- 
tium blockchains, a propos be not valid if it do not contain an appropri hash of the last block add to the 
blockchain. 

3.2 binari byzantin consensu 
the implement of multivalu vpbc reli on an underli binari byzantin consensu (denot bbc). 
A leader-free, randomization-fre and signature-fre implement of it will be describ in section 5. 

the valid properti of thi binari byzantin consensu be the following: if all non-faulti process pro- 
pose the same value, no other valu can be decided. To prevent confusion, the validity, agreement and termina- 
tion properti of bbc be denot bbc-validity, bbc-agreement and bbc-termination. 

4 from multivalu to binari consensu in a byzantin system 

thi section describ a reduct of multivalu byzantin consensu to the previou binari byzantin con- 
sensus. our reduct be guarante to termin after a sequenc of 2 binari consensu instances. thi is, a far 
a we know, the first reduct that decid a non-predetermin valu in a sequenc of o(1) binari consensu 
instances. other reduct either return a predefin ⊥ valu a if the consensu abort [19, 54, 65], or do 
not toler byzantin failur and requir the execut of dlog ne sequenti binari consensu instanc [67]. 
our reduct be base on the rb-broadcast commun abstraction, and underli instanc of binari 
byzantin consensus. let bbc denot the comput power need to solv binari byzantin consen- 
sus. hence, the “multivalu to binary” reduct work in the model bampn,t[t < n/3,bbc], which be 
resili optimal. 

4.1 the reduct 

binari consensu object As just said, in addit to the rb-broadcast abstraction, the process cooper 
with an array of binari byzantin consensu object denot bin _con [1..n]. the instanc bin _con [k] 
allow the non-faulti process to find an agreement on the valu propos by pk. thi object be implement 
with the binari byzantin consensu algorithm present in section 5. 

To simplifi the presentation, we consid that a process pi launch it particip in bin _con [k] by 
invok bin _con [k].bin_propose(v), where v ∈ {0, 1}. then, it execut the correspond code in a 
specif thread, which eventu return the valu decid by bin _con [k]. 

5 note that our consensu definit decoupl the valid of a valu from the natur (faulti or non-faulty) of the process propos 
it. We assum that everi non-faulti process propos a valid valu for the sake of simplicity. however, if we assum that the byzantin 
behavior of a process be relat onli to it code and not to it input valu (which be application-dependent), our algorithm remain 
correct a long a at least one non-faulti process propos a valid value. 

5 



local variabl each process pi manag the follow local variables; ⊥ denot a default valu that cannot 
be propos by a (faulti or non-faulty) process. 

• An array propos i[1..n] initi to [⊥, · · · ,⊥]. the aim of propos i[j] be to contain the valu 
propos by pj . 
• An array bin_decis i[1..n] initi to [⊥, · · · ,⊥]. the aim of bin_decis i[k] be to contain the 

valu (0 or 1) decid by the binari consensu object bin _con [k]. 

oper mv_propose(vi) be 
(01) rb_broadcast val(vi); 
(02) repeat if 

( 
∃ k : (proposalsi[k] 6= ⊥) ∧ (bin _con [k].bin_propose() not invoked) 

) 
(03) then invok bin _con [k].bin_propose(1) end if; 
(04) until (∃` : bin_decisionsi[`] = 1) end repeat; 
(05) for each k such that bin _con [k].bin_propose() not yet invok 
(06) do invok bin _con [k].bin_propose(0) end for; 
(07) wait_until ( 

∧ 
1≤x≤n bin_decisionsi[x] 6= ⊥); 

(08) j ← min{x such that bin_decisionsi[x] = 1}; 
(09) wait_until (proposalsi[j] 6= ⊥); 
(10) return(proposalsi[j]). 

(11) when val(v) be rb-deliv from pj do if valid(v) then proposalsi[j]← v end if. 

(12) when bin _con [k].bin_propose() return a valu b do bin_decisionsi[k]← b. 

figur 1: from multivalu to binari byzantin consensu in bampn,t[t < n/3,bbc] 

the algorithm the algorithm reduc multivalu byzantin consensu to binari byzantin consensu be 
describ in figur 1. In thi algorithm, a process invok the oper mv_propose(v), where v be the valu 
it propos to the multivalu consensus. the behavior of a process pi can be decompos into four phases. 

• phase 1: pi dissemin it valu (line 01 and 11). A process pi first send it valu to all the process 
by invok the rb-broadcast oper (line 01). when a process rb-deliv the valu v rb-broadcast 
by a process pj , it store it in proposalsi[j] if v be valid (line 11). 
• phase 2: pi start particip in a first set of binari consensu instanc (line 02-04). 

then, pi enter a loop in which it start particip in the binari consensu instanc bin _con [k], 
to which it propos the valu 1, associ with each process pk from which it have rb-deliv the 
propos valu (line 02-03). thi loop stop a soon a pi discov a binari consensu instanc 
bin _con [`] in which 1 be decid (line 04). (the binari consensu we propos late allow to 
reach the end of phase (2) after onli o(1) messag delays.) 
• phase 3: pi start particip in all other binari consensu instanc (line 05-06). 

after it know a binari consensu instanc decid 1, pi invok bin_propose(0) on all the binari con- 
sensu instanc bin _con [k] in which it have not yet participated. let u notic that it be possibl that, 
for some of these instanc bin _con [k], no process have rb-deliv a valu from the associ 
process pk. the aim of these consensu particip be to ensur that all binari consensu instanc 
eventu terminate. 
• phase 4: pi decid a valu (line 07-10 and 12). 

final pi consid the first (accord to the process index order) among the success binari consensu 
objects, i.e., the one that return 1 (line 08).6 let bin _con [j] be thi binari consensu object. As 
the associ decid valu be 1, at least one non-faulti process propos 1, which mean that it rb- 
deliv a valu from the process pj (line 02-03). let u observ that, due to the rb-termination-2 
property, thi valu be eventu rb-deliv by everi non-faulti process. consequently, pi decid it 
(line 09-10). 

4.2 correct proof 
lemma 1. there be at least one binari consensu instanc that decid valu 1, and all non-faulti process 
exit the repeat loop. 

6one could replac min by a determinist function suit for blockchain that return the valu that repres the block with the 
maximum number of transact to prevent a byzantin process from exploit a lack of fair to it own benefit. 

6 



from an oper point of view, thi lemma can be re-stat a follows: there be at least one ` ∈ [1..n] such 
that at each non-faulti process pi, we eventu have bin_decis i[`] = 1. 
proof the proof be by contradiction. let u assum that, at ani non-faulti process pi, no bin_decis i[`], 
1 ≤ ` ≤ n, be ever set to 1 (line 12). It follow that no non-faulti process exit the “repeat” loop (line 02- 
04). As a non-faulti process pj rb-broadcast a valid value, it follow from the rb-termination-1 property, 
that each non-faulti process pi rb-deliv the valid propos of pj , and consequ we eventu have 
propos i[j] 6= ⊥ at each non-faulti process pi (line 11). 

It follow from the first sub-pred of line 02 that all non-faulti process pi invok bin_propose(1). 
on the bbc object bin _con [j]. hence, from it bbc-termination, bbc-agreement, bbc-validity, and 
intrusion-toler properties, thi bbc instanc return the valu 1 to all non-faulti processes, which exit the 
“repeat” loop. 2lemma 1 

lemma 2. A decid valu be a valid valu (i.e., it satisfi the predic valid()). 

proof let u first observ that, for a valu propos i[j] to be decid by a process pi, we need to have 
bin_decis i[j] = 1 (line 08-10). 

If the valu 1 be decid by bin _con [j], bin_decis i[j] = 1 be eventu true at each non-faulti 
process pi (line 12). If follow from (i) the fact that the valu 1 can be propos to a bbc instanc onli 
at line 03, and (ii) the intrusion-toler properti of bin _con [j], that at least one non-faulti process 
pi invok bin _con [j].bin_propose(1). due to the predic of line 02, thi non-faulti process pi be 
such that propos i[j] 6= ⊥ when it invok bin _con [j].bin_propose(1). due to line 11, it follow that 
propos i[j] contain a valid value. 2lemma 2 

lemma 3. No two non-faulti process decid differ values. 

proof let u consid ani two non-faulti process pi and pj , such that pi decid propos i[k1] and pj 
decid proposalsj [k2]. It follow from line 08 that k1 = min{x such that bin_decis i[x] = 1} and k2 = 
min{x such that bin_decisionsj [x] = 1}. 

On the one hand, it follow from line 07 that ( 
∧ 

1≤x≤n bin_decis i[x] 6= ⊥) and 
( 
∧ 

1≤x≤n bin_decisionsj [x] 6= ⊥), from which we conclud that both pi and pj know the binari valu decid 
by each binari consensu instanc (line 12). due to the bbc-agreement properti of each binari consensu 
instance, we also have ∀x : bin_decis i[x] = bin_decisionsj [x]. let dec[x] = bin_decis i[x] = 
bin_decisionsj [x]. It follow then from line 08 that k1 = k2 = min{x such that dec[x] = 1} = k. hence, 
dec[k] = 1. 

On the other hand, it follow from the intrusion-toler properti of bin _con [k] that a non-faulti 
process p` invok bin _con [k].bin_propose(1). As thi invoc can be issu onli at line 03, we 
conclud (from the predic of line 02) that proposals`[k] = v 6= ⊥. As p` be non-faulty, it follow from the 
rb-unic and rb-termination-2 properti that all non-faulti process rb-deliv v from pk. hence, we 
eventu have propos i[k] = proposalsj [k], which conclud the proof of the lemma. 2lemma 3 

lemma 4. everi non-faulti process decid a value. 

proof It follow from lemma 1 that there be some pj such that we eventu have bin_decis i[j] = 1 at 
all non-faulti processes, and no non-faulti process block forev at line 04. hence, all non-faulti process 
invok each binari consensu instanc (at line 03 or line 06). moreover, due to their bbc-termin property, 
each of the n binari consensu instanc return a result at each non-faulti process (line 12). It follow that 
no non-faulti process pi block forev at line 07. finally, a see in the proof of lemma 3, the predic of 
line 09 be eventu satisfi at each non-faulti process, which conclud the proof of the lemma. 2lemma 4 

theorem 1. the algorithm describ in figur 1 implement multivalu byzantin consensu (vpbc) in the 
system model bampn,t[t < n/3,bbc]. 

proof follow from lemma 2 (vpbc-validity), lemma 3 (vpbc-agreement), and lemma 4 (vpbc-termination). 
2theorem 1 

7 



5 binari consensu in eventu synchron byzantin system 

thi section describ the underli binari byzantin consensu algorithm bbc, which provid the process 
with the oper bin_propose(). An advantag of thi algorithm be that it be guarante to termin if all 
non-faulti process propos the same value, even without synchrony, and alway in a constant number of 
messag delays. thi algorithm may termin in constant time, thi happen for exampl if all non-faulti 
process propos the same value. thi algorithm reli on an all-to-al binari commun abstract (bv- 
broadcast) and an eventu synchroni assumption, which be describ in the next subsections. the algorithm 
be built incrementally. We first present a simpl algorithm that satisfi onli the consensu safeti properti 
(bbc-valid and bbc-agreement). thi algorithm be then extend with the eventu synchroni assumpt 
to satisfi the consensu live properti (bbc-termination). the aim of thi increment approach be to 
facilit the understand and the proofs. 

5.1 the bv-broadcast all-to-al commun abstract 
the binari valu broadcast (bv-broadcast) commun abstract have be introduc in [49] (it imple- 
mentat be recal in appendix a). 

definit bv-broadcast be an all-to-al commun abstract that provid the process with a singl 
oper denot bv_broadcast(). when a process invok bv_broadcast tag(m), we say that it “bv- 
broadcast the messag tag(m)”. the content of a messag m be 0 or 1 (henc the term “binary-value” in the 
name of thi commun abstraction). 

In a bv-broadcast instance, each non-faulti process pi bv-broadcast a binari valu and obtain a set of 
binari values, store in a local read-onli set variabl denot bin_valu i. thi set, initi to ∅, increas 
when new valu be received. bv-broadcast be defin by the four follow properties. 

• bv-obligation. If at least (t + 1) non-faulti process bv-broadcast the same valu v, v be eventu 
add to the set bin_valu i of each non-faulti process pi. 
• bv-justification. If pi be non-faulti and v ∈ bin_valu i, v have be bv-broadcast by a non-faulti 

process. 
• bv-uniformity. If a valu v be add to the set bin_valu i of a non-faulti process pi, eventu v ∈ 
bin_valuesj at everi non-faulti process pj . 
• bv-termination. eventu the set bin_valu i of each non-faulti process pi be not empty. 

A bv-broadcast properti the follow properti be an immedi consequ of the previou proper- 
ties. eventu the set bin_valuesi of the non-faulti process pi (i) becom non-empty, (ii) becom equal, 
(iii) contain all the valu broadcast by non-faulti processes, and (iv) never contain a valu broadcast onli by 
byzantin processes. however, no non-faulti process know when (ii) and (iii) occur. 

5.2 A safe binari byzantin consensu algorithm in bampn,t[t < n/3] 
figur 2 describ a simpl binari byzantin consensu algorithm, which satisfi the bbc-valid and bbc- 
agreement properti in the system model bampn,t[t < n/3]. thi algorithm, which be round-bas and 
reli on the previou bv-broadcast abstraction, have the same structur a the random consensu algorithm 
introduc in [49]. 

local variabl each process pi manag the follow local variables. 

• esti: local current estim of the decid value. It be initi to the valu propos by pi. 
• ri: local round number, initi to 0. 
• bin_valu i[1..]: array of binari values; bin_valu i[r] (initi to ∅) store the local output set fill 

by bv-broadcast associ with round r. (thi unbound array can be replac by a singl local 
variabl bin_valu i, reset to ∅ at the begin of everi round. We consid here an array to simplifi 
the presentation.) 
• bi: auxiliari binari value. 
• valu i: auxiliari set of values. 

messag type the algorithm us two messag types, denot est and aux. both be use in each round, 
henc they alway appear with a round number. 

8 



• est[r]() be use at round r by pi to bv-broadcast it current decis estim esti. 
• aux[r]() be use by pi to dissemin it current valu of bin_valu i[r] (with the help of the broadcast() 

macro-operation). 

the algorithm let u consid figur 2. after it have deposit it binari propos in esti (line 01), each 
non-faulti process pi enter a sequenc of asynchron rounds. each round r us a bv-broadcast instanc 
whose associ local variabl at process pi be bin_valu i[r]. 

oper bin_propose(vi) be 
(01) esti ← vi; ri ← 0; 
(02) while (true) do 
(03) ri ← ri + 1; 
(04) bv_broadcast est[ri](esti); 
(05) wait_until 

( 
bin_valuesi[ri] 6= ∅ 

) 
; 

(06) broadcast aux[ri](bin_valuesi[ri]); 
(07) wait_until 

( 
messag aux[ri](b_valp(1)), ..., aux[ri](b_valp(n−t)) have be receiv 
from (n− t) differ process p(x), 1 ≤ x ≤ n− t, and their content be 
such that ∃ a non-empti set valuesi such that (i) valuesi ⊆ bin_valuesi[ri] 
and (ii) valuesi = ∪1≤x≤n−tb_valx 

) 
; 

(08) bi ← ri mod 2; 
(09) if (valuesi = {v}) // valuesi be a singleton whose element be v 
(10) then esti ← v; if (v = bi) then decide(v) if not yet do end if; 
(11) els esti ← bi 
(12) end if; 
(13) end while. 

figur 2: A safe algorithm for binari byzantin consensu in bampn,t[t < n/3] 
the behavior of a non-faulti process pi dure a round r can be decompos in three phases. 

• phase 1: coordin exchang of current estim (line 03-05). 
process pi first progress to the next round, and bv-broadcast it current estim (line 04). then pi 
wait until it set bin_valu i[r] be not empti (let u recal that, when bin_valu i[r] becom non-empty, 
it have not necessarili it final value). 
• phase 2: second exchang of estim to favor converg (line 06-07). 

In thi second phase, pi broadcast (hence, thi be neither a bv-broadcast nor a rb-broadcast) a messag 
aux[r]() whose content be bin_valu i[r] (line 06). then, pi wait until it have receiv a set of valu 
valu i satisfi the two follow properties. 

– valu i ⊆ bin_valu i[r]. thank to the bv-justif property, thi ensur that (even if byzan- 
tine process send fake messag aux[r]() contain valu propos onli by byzantin pro- 
cesses) valu i will contain onli valu broadcast by non-faulti processes. 

– the valu in valu i come from the messag aux[r]() of at least (n− t) differ processes. 
hence, at ani round r, after line 07, valu i ⊆ {0, 1} and contain onli valu bv-broadcast at line 04 
by non-faulti processes. 
• phase 3: tri to decid (line 08-12). 

thi phase be a pure local comput phase, dure which (if not yet done) pi tri to decid the valu 
b = r mod 2 (line 08 and 10), depend on the content of valu i. 

– If valu i contain a singl element v (line 09), then v becom pi’ new estimate. moreover, v be 
candid to be decided. To ensur bbc-agreement, v can be decid onli if v = b. the decis 
be realiz by the statement decide(v) (line 10). 

– If valu i = {0, 1}, then pi cannot decide. As both valu have be propos by non-faulti 
processes, to entail converg to agreement, pi select one of them (b, which be the same at all 
non-faulti processes) a it new estim (line 11). 

let u observ that the invoc of decide(v) by pi do not termin the particip of pi in the 
algorithm, name pi continu loop forever. the algorithm can be make terminating, use the ran- 
domiz techniqu present in [49]. instead we preserv the simplic of thi algorithm and postpon 
a determinist termin solut in section 5.5. 

9 



5.3 safeti proof 
process pi be a non-faulti process, let valuesri denot the valu of the set valu i which satisfi the pred- 
icat of line 07. moreover, let u recal that, give a run, C denot the set of non-faulti process in thi 
run. 

lemma 5. let t < n/3. If at the begin of a round r, all non-faulti process have the same estim v, 
they never chang their estim valu thereafter. 

proof let u assum that all non-faulti process (which be at least n− t > t+ 1) have the same estim v 
when they start round r. hence, they all bv-broadcast the same messag est[r](v) at line 04. It follow from 
the bv-justif and bv-oblig properti that each non-faulti process pi be such that bin_valu i[r] = 
{v} at line 05, and consequ can broadcast onli aux[r]({v}) at line 06. consid ani non-faulti process 
pi, it then follow from the predic of line 07 (valu i contain onli v), the predic of line 09 (valu i be a 
singleton), and the assign of line 10, that esti keep the valu v. 2lemma 5 

lemma 6. let t < n/3. 
( 
(pi, pj ∈ C) ∧ (valuesri = {v}) ∧ (valuesrj = {w}) 

) 
⇒ (v = w). 

proof let pi be a non-faulti process such that valuesri = {v}. It follow from line 07 that pi receiv the 
same messag aux[r]({v}) from (n − t) differ processes, i.e., from at least (n − 2t) differ non-faulti 
processes. As n− 2t ≥ t+ 1, thi mean that pi receiv the messag aux[r]({v}) from a set Qi includ at 
least (t+ 1) differ non-faulti processes. 

let pj be a non-faulti process such that valuesrj = {w}. hence, pj receiv aux[r]({w}) from a set Qj of 
at least (n− t) differ processes. As (n− t) + (t+ 1) > n, it follow that Qi ∩qj 6= ∅. let pk ∈ Qi ∩qj . 
As pk ∈ qi, it be a non-faulti process. hence, at line 06, pk sent the same messag aux[r]({}) to pi and pj , 
and we consequ have v = w. 2lemma 6 

lemma 7. let t < n/3. the valu decid by a non-faulti process be propos by a non-faulti process. 

proof let u consid the round r = 1. due to the bv-justif properti of the bv-broadcast of line 04, 
it follow that the set bin_valu i[1] contain onli valu propos by non-faulti processes. consequently, 
the non-faulti process broadcast at line 06 messag aux[1]() contain set with valu propos onli by 
non-faulti processes. It then follow from the predic (i) of line 07 (values1i ⊆ bin_valu i[1]), and the bv- 
justif properti of the bv-broadcast abstraction, that the set values1i of each non-faulti process contain 
onli valu propos by non-faulti processes. hence, the assign of esti (be it at line 10 or 11) provid it 
with a valu propos by a non-faulti process. the same reason appli to round r = 2, r = 3, etc., which 
conclud the proof of the lemma. 2lemma 7 

lemma 8. let t < n/3. No two non-faulti process decid differ values. 

proof let r be the first round dure which a non-faulti process decides, let pi be a non-faulti process that 
decid in round r (line 10), and let v be the valu it decides. hence, we have valuesri = {v} where v = 
(r mod 2). 

If anoth non-faulti process pj decid dure round r, we have valuesrj = {w}, and, due to lemma 6, 
we have w = v. hence, all non-faulti process that decid in round r, decid v. moreover, each non-faulti 
process that decid in round r have previous assign v = (r mod 2) to it local estim esti. 

let pj be a non-faulti that do not decid in round r. As valuesri = {v}, and pj do not decid in round 
r, it follow from lemma 6 that we cannot have valuesrj = {1 − v}, and consequ valuesrj = {0, 1}. 
hence, in round r, pj execut line 11, where it assign the valu (r mod 2) = v to it local estim estj . 

It follow that all non-faulti process start round (r+1) with the same local estim v = r mod 2. due to 
lemma 5, they keep thi estim valu forever. hence, no differ valu can be decid in a futur round by 
a non-faulti process that have not decid dure round r, which conclud the proof of the lemma. 2lemma 8 

lemma 9. let the system model be bampn,t[t < n/3]. No non-faulti process remain block forev in a 
round. 

10 



proof let u assum by contradict that there be a first round in which some non-faulti process pi remain 
block forever. As all non-faulti process termin round (r − 1), they all start round r and all invok the 
round r instanc of bv-broadcast. due to the bv-termin property, the wait_until() statement of line 05 
termin at each non-faulti process. then, a all non-faulti process broadcast a messag aux[r]() (line 06), 
it follow that the wait_until() statement of line 07 termin at each non-faulti process. It follow that there 
be no first round at which a non-faulti process remain block forev dure round r. 2lemma 9 

lemma 10. let the system model be bampn,t[t < n/3]. If all non-faulti process pi termin a round r 
with valuesri = {v}, they all decid by round (r + 1). 

proof If all non-faulti process be such that valuesri = {v}, and the round r be such that v = (r mod 2), it 
follow from line 08-10 that (if not yet done) each non-faulti process decid dure round r. 

If r be such that v 6= (r mod 2), each non-faulti process set it current estim to v (line 10). As dure 
the next round we have v = ((r + 1) mod 2), and valuesr+1i = bin_valu i[r + 1] = {v} at each non-faulti 
process pi, each non-faulti process decid dure round (r + 1). 2lemma 10 

lemma 11. let the system model be bampn,t[t < n/3]. If everi non-faulti process pi termin a round r 
with valuesri = {0, 1}, they it decid by round (r + 2). 

proof If everi non-faulti process pi be such that valuesri = {0, 1}, it execut line 11 dure round r, and 
we have esti = (r mod 2) = v when it start round (r + 1). due to lemma 5, it keep thi estim forever. 
As all non-faulti process execut round (r + 1) and (r + 2) (lemma 9) and v = ((r + 2) mod 2), we 
have valuesr+2i = {v}, at each non-faulti process pi. It follow that each non-faulti process decid at line 10. 

2lemma 11 

theorem 2. the algorithm describ in figur 2 satisfi the safeti consensu properties. 

proof the proof follow from lemma 7 (bbc-validity) and lemma 8 (bbc-agreement). 2theorem 2 

decis the algorithm describ in figur 2 do not guarante decision. thi may occur for exampl when 
some non-faulti process propos 0, the other non-faulti process propos 1, and the byzantin process 
play doubl game, each propos 0 or 1 to each non-faulti process, so that it never happen that at the end of 
a round all non-faulti process have either valu i = {0, 1}, or they all have valu i = {v} with v either 0 or 
1. In other words, if not all non-faulti process propos the same initi value, byzantin process can make, 
round after round, some non-faulti process have valu i = {0, 1}, while the rest of non-faulti process 
have valu i = {v}, with v 6= (r mod 2), avoid them to decide.7 

5.4 eventu synchroni assumpt 

consensu imposs It it well-known that there be no consensu algorithm ensur both safeti and live- 
ness properti in fulli asynchron message-pass system in which even a singl process may crash [24]. 
As the crash failur model be less sever than the byzantin failur model, the consensu imposs remain 
true if process may commit byzantin failures. 

To circumv such an impossibility, and ensur the consensu termin property, the model must be 
enrich with addit comput power. exampl of such a power can be provid with failur de- 
tector [18, 26, 34], constraint on the set of input vector [25, 51], random [4, 49, 60], or synchroni 
assumpt [20, 21] (see [61] for more developments). As announced, we consid here the approach base 
on addit synchroni assumptions. 

addit synchroni assumpt In the following, it be assum that after some finit time τ , there be 
an upper bound δ on messag transfer delays. thi assumpt be denot 3synch (eventu synchroni 
assumption). To exploit it through the use of timers, we also assum that process can measur accur 
interv of time, although they do not need to have synchron clocks. 

notat the model bampn,t[t < n/3] enrich with 3synch be denot bampn,t[t < n/3,3synch]. 
7in the case of the random binari consensu algorithm of [49], the common coin guarante termin with probabl 1, 

becaus eventu the singleton valu in valuesi will match the coin. 

11 



5.5 A binari byzantin consensu algorithm in bampn,t[t < n/3,3synch] 
In thi section, we describ our binari byzantin consensu algorithm that be guarante to termin in o(t) 
rounds, which be know to be optim [23]. the algorithm describ in figur 3 be an extens of the safe 
algorithm of figur 2, whose aim be to add the consensu termin property. the line with the same 
number be the same in both algorithms. the new line in figur 3 be number “newx”, where x be an 
integer, and the line that be modifi be prefix by “m-”. In addit to the use of local timers, to eventu 
benefit from the 3synch assumption, thi extend round-bas algorithm us the round coordin notion: 
in each round a predetermin process play a special role, namely, the round coordin strive to impos 
a valu that the other process would decide. To thi end, each process in turn play the round coordin 
role [18, 21]. more precisely, the process be p1, .., pn, the coordin of round r be the process pi such 
that i = ((r − 1) mod n) + 1.8 

addit local variabl and messag type In addit to esti, ri, bin_valu i[r], and valu i, each 
process pi manag the follow local variables. 

• timeri be a local timer, and timeouti a timeout value, both use to exploit the assumpt 3synch . 
• coordi be the index of the current round coordinator. 
• auxi be an auxiliari set of values, use to store the valu (if any) that the current coordin strive to 

impos a decis value. 

the coordin of round r, us the messag type coord_value[r]() to broadcast the valu it tri to 
favor to becom the decid value. 

oper bin_propose(vi) be 
(01) esti ← vi; ri ← 0; 

timeouti ← 0; 
(02) while (true) do 
(03) ri ← ri + 1; 
(new1) coord i ← ((ri − 1) mod n) + 1; 

timeouti ← timeouti + 1; set timeri to timeouti; 
(04) bv_broadcast est[ri](esti); 
(new2) if (i = coord i) then 

wait_until (bin_valuesi[ri] = {w}); // w be the first valu to enter bin_valuesi[ri] 
broadcast coord_value[ri](w) 

end if; 
(m-05) wait_until 

( 
(bin_valuesi[ri] 6= ∅) ∧ (timeri expired) 

) 
; 

(new3) set timeri to timeouti; 
(new4) if 

( 
(coord_value[ri](w) receiv from pcoordi ) ∧ (w ∈ bin_valuesi[ri]) 

) 
then auxi ← {w} 
els auxi ← bin_valuesi[ri] 

end if; 
(m-06) broadcast aux[ri](auxi); 
(m-07) wait_until 

( 
(messag aux[ri](b_valp(1)), ..., aux[ri](b_valp(n−t)) have be receiv 
from (n− t) differ process p(x), 1 ≤ x ≤ n− t, and their content be 
such that ∃ a non-empti set valuesi such that (i) valuesi ⊆ bin_valuesi[ri] 
and (ii) valuesi = ∪1≤x≤n−tb_valx) ∧ (timeri expired) 

) 
; 

(new5) if (when consid the whole set of the messag aux[ri]() received, sever set 
values1i, values2i, ... satisfi the previou wait predicate) ∧ (one of them be auxi) 

then valuesi ← auxi end if; 
(08) bi ← ri mod 2; 
(09) if (valuesi = {v}) // valuesi be a singleton whose element be v 
(10) then esti ← v; if (v = bi) then decide(v) if not yet do end if; 
(11) els esti ← bi 
(12) end if; 
(13) end while. 

figur 3: A safe and live algorithm for binari byzantin consensu in bampn,t[t < n/3,3synch] 

descript of the extend algorithm the follow item explain the new and modifi statement that 
appear in figur 3. 

8let u notic that the notion of round coordin be differ from the notion of an eventu leader. A round coordin be a simpl 
algorithm mechan which can be implement in bampn,t[t < n/3], while an eventu leader be an oracl which cannot be 
implement in bampn,t[t < n/3]. 

12 



• At line new1, pi comput the current round coordinator, and set it local timer whose expiri be use in 
the predic of line m-05. the timeout valu be initi befor enter the loop, and then increas 
at everi round. 
• line new3 be a simpl reset of the timer, whose expiri be use in the predic of the modifi line m-07. 
• line new2, new4, m-06, and new5 realiz a mechan that allow the current round coordin to 

tri to impos the first valu that enter into it bin_valu set a the decid value9. combin with the 
fact that there be a time after which the messag exchang by the non-faulti process be timely, thi 
ensur that there will be a round dure which the non-faulti process will have a singl valu in their 
set valu i (which –bi lemma 10– entail their decision). 
• modifi line m-05 and m-07: addit of the timer expir in the predic consid at the corre- 

spond line. 

As just seen, the idea make oper by these new or modifi statement be the following: benefit from 
a non-faulti round coordin to entail decision, by requir thi process to broadcast a propos valu so 
that all non-faulti process adopt it. To thi end: 

• the round coordin pk broadcast the messag coord_value[ri](w), where w be the first valu that 
enter it bin_valu set (line new2). If pk be non-faulty, the timeout valu of the non-faulti process 
be big enough, and there be a bound on messag transfer delays, all non-faulti process will receiv it 
befor their timer expir at line m-06. 
• then, assum the previou item, all non-faulti process set auxi to {w} (line new4), and broadcast it 

(line m-06). the predic w ∈ bin_valu i[ri] be use to prevent a byzantin coordin to send fake 
valu that would foil non-faulti processes. 
• finally, all the non-faulti process will receiv the messag aux[ri]({w}) from (n − t) differ pro- 

cesses, and by line new5 will set valu i = {w}. thi will entail their decis dure the round (r+ 1) 
or (r + 2). 

from asynchroni to synchroni In order to guarante decision, after the eventu synchroni assumpt 
hold and the timeout valu at each non-faulti process be big enough (i.e., big than the upper bound on 
messag transmiss delay), we need that eventu all non-faulti process execut round synchronously. 
observ that, due to initi asynchrony, non-faulti process can start the consensu algorithm at differ 
instants. moreover, due to the potenti particip of byzantin processes, some non-faulti process can 
advanc rounds, without deciding, while other non-faulti process be still execut previou rounds. By 
use a timeout that grow by 1 each round all process eventu reach a round from which they behav 
synchronously. 

lemma 12. let u consid the algorithm of figur 3. eventu the non-faulti process attain a round from 
which they behav synchronously. 

proof By 3synch there be eventu an unknown bound δ on messag transfer delays. As indic in 
section 2, it be assum that local process time be equal to zero. (alternatively, two addit proof be 
provid in appendic B and C that do not reli on thi assumption.) In the following, time unit will be give 
in integers. the notat twith a subscript (for exampl tfirst0) wil be use to repres a time measur that 
be give by the number of time unit that have pass sinc the algorithm started, a measur by an omnisci 
global observ G. G observ time pass at the same rate a the non-faulti process and event can occur 
on integ time units. 

We will use the follow definitions: 
• tfirstr be the time a measur by G at which the first non-faulti process pfirst reach round r (tfirst0 be 

the time when the first non-faulti process start the consensus). 
• tlastr be the time a measur by G at which the last non-faulti process plast reach round r (tlast0 be the 

time when the last non-faulti process start the consensus). 
for a round to be synchronous, all non-faulti process must arriv at that round with enough time to 

broadcast their messag to all non-faulti process befor the timeout of that round expir at ani non-faulti 
process. In the case that the last non-faulti process to arriv at the round be the coordinator, it may take up to 

9A similar mechan base on a round coordin and the same messag exchang pattern be use in the byzantin synchron 
algorithm present in [3] and in [52] to solv asynchron k-set agreement with restrict failur detectors. 

13 



3 messag delay befor it coord_value[r]() messag be receiv by all non-faulti process (thi includ 
up to 2 messag delay until a valu enter it bin_values[r] and an addit messag delay to broadcast 
coord_value[r]()). therefore, we must have a round r where 

tlastr + δ ≤ tfirstr + timeoutr. (1) 

note that give the timeout start at 0 on round 0 and grow by one each round, we can replac timeoutr for r 
for ani round r. 

consid the first round r′ where timeoutr′ ≥ δ be satisfied. for ani round r′′ where r′′ ≥ r′ the maximum 
amount of time for plastr′′ to complet the round will be 2 × timeoutr′′ . thi be due to the fact that the last 
non-faulti process to arriv at a round will not have to wait longer than δ to receiv the messag need to 
satisfi the condit on line m-05 and m-07, thu the time take to execut the round will be no more than 
the length of the two timeouts. all other non-faulti process will take at least 2 × timeoutr′′ to complet 
round r′′. 

from thi the time where the last non-faulti process reach some round r′′ can be write as: 

tlastr′′ = tlastr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
. 

and the time when the first non-faulti process reach round r′′ as: 

tfirstr′′ ≥ tfirstr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
. 

plug thi into inequ 1 result in: 

tlastr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
+ 3× δ ≤ tfirstr′ + 2 

( 
r′′−1∑ 
x=r′ 

x 

) 
+ r′′. 

remov equal compon we have: 

tlastr′ + 3× δ ≤ tfirstr′ + r 
′′. 

thus, by round r′′ = tlastr′ + 3× δ − tfirstr′ synchroni be ensured. 
It will now be show that onc inequ (1) be satisfi for one round r′′ (where timeoutr′′ ≥ δ), it will 

remain satisfi in the all follow rounds. consid round r′′ + 1, give that inequ (1) be satisfi for 
round r′′, we have: 

tlastr′′ + 3× δ ≤ tfirstr′′ + timeoutr′′ . (2) 

and it need to be show that the follow inequ be true: 

tlastr′′+1 + 3× δ ≤ tfirstr′′+1 + timeoutr′′+1 (3) 

use the same argument a above, the time at which the last and first process arriv at round r′′ + 1 are: 
tlastr′′+1 = tlastr′′ + 2 × timeoutr′′ and tfirstr′′+1 ≥ tfirstr′′ + 2 × timeoutr′′ . plug thi into inequ 
(3) result in: 

tlastr′′ + 2× timeoutr′′ + 3× δ ≤ tfirstr′′ + 2× timeoutr′′ + timeoutr′′+1. 

remov equal part lead to: 

tlastr′′ + 3× δ ≤ tfirstr′′ + timeoutr′′+1. 

thi inequality, which be equival to inequ (3) have the same compon a inequ (2), except have 
timeoutr′′+1 instead of timeoutr′′ . therefore, inequ (3) must be satisfied, give that inequ (2) be 
satisfied. By induct thi hold true for ani round after r′′. 2lemma 12 

14 



5.6 proof of the 3synch-bas algorithm 
the proof consist of two parts: (i) show that the add statement preserv the consensu safeti properti 
prove for the time-fre algorithm of figur 2, and (ii) show that all non-faulti process eventu decide. 

lemma 13. the algorithm describ in figur 3 satisfi the bbc-valid and bbc-agreement properties. 

proof the proof consist in show that the lemma 5, 6, 7 and 8 remain correct when consid the 
algorithm of figur 3. basically, these proof remain correct because, a the new and modifi statement 
do not assign valu to the set bin_valu i[r] at the non-faulti processes, and no properti of bin_valu i 
be relat to a time assumption, the set bin_valu i[r] of a non-faulti process pi can never contain valu 
propos by byzantin process only. It follow from thi observ that the local variabl esti and valu i 
of ani non-faulti process (defin or updat at line m-07, new5, 10, or 11) can contain onli valu from 
non-faulti processes. more specif we have the following. 

• lemma 5. let r be the consid round, and v be the current estim of the non-faulti processes. We 
then have bin_valu i[r] = {v} at line m-05 of everi non-faulti process pi. 

– If the round coordin pk be non-faulty, we have at everi non-faulti process auxi = bin_valu i[r] = 
{v}. It then follow that valuesri = {v} and the lemma remain true due to line 09 and 10. 

– If the round coordin pk be byzantin and send possibl differ valu to the non-faulti pro- 
cesses, let u consid a non-faulti process that receiv the messag coord_value[r]({1− v}). 
As (1 − v) /∈ bin_valu i[r], at line new4, pi execut the “else” part where it set auxi to {v} 
(the onli valu in bin_valu i[r]), and the lemma follows. 

• lemma 6. As it do not depend on the timers, and be relat onli to the fact that each of the set valuesri 
and valuesrj of two non-faulti process be singletons, the proof remain valid. 
• lemma 7. the proof follow from the fact that the set bin_valu i of ani non-faulti process can contain 

onli valu propos by non-faulti processes. 
• lemma 8. As it reli onli on the set valuesri of the non-faulti processes, thi proof remain correct.2lemma 13 

lemma 14. the algorithm describ in figur 3 ensur that everi non-faulti process decides. 

proof let u first observ that, a timer alway expire, the “wait” statement (modifi line m-05 and M- 
07) alway terminate, and consequ lemma 9 remain true. the reader can also check that the proof of 
lemma 10 remain valid. 

It remain to show that there be eventu a round r at the end of which all non-faulti process pi have 
the same valu w in their set variabl (valuesri = {w}) (from which decis follow due to lemma 10) the 
proof show that, due to (a) the eventu synchroni assumption, (b) the round coordin mechanism, and (c) 
the messag coord_value[ ]() sent by the round coordinators, there be a round r such that valuesri = {w} 
at each non-faulti process. 

let u consid a time τ from which (due to lemma 12) the system behav synchron (the timeout 
valu of all non-faulti process be such that all the messag exchang by the non-faulti process arriv 
timely). let r be the small round number coordin by a non-faulti process pk after τ . At line new2 of 
round r, pk broadcast coord_value[r](w), be w the first valu that enter it set bin_valuesk[r]. the 
messag coord_value[r](w) be receiv time by all non-faulti processes, that set auxi to {w} in line 
new4. consequently, in line m-06 all non-faulti process broadcast aux[r]({w}), and receiv in line m-07 
(n− t) aux[r]({w}) messag from differ processes, set in line new5 valu i to {w}. By lemma 10, 
all non-faulti process decid w by round r + 1, which conclud the proof of the lemma. 2lemma 14 

theorem 3. the algorithm describ in figur 3 solv binari byzantin consensu in the system model 
bampn,t[t < n/3,3synch]. 

proof the proof follow directli from lemma 13 (bbc-valid and bbc-agreement) and lemma 14 (bbc- 
termination). 2theorem 3 

15 



6 relat work 

byzantin consensu our valid predicate-bas consensu differ from previou definit in the way 
valid be defined. the semin paper on the agreement between byzantin gener consid a singl source; 
it valid requir that if the sourc propos onli one value, then onli thi valu can be decid [42]. In 
the case where multiple, potenti byzantine, process propos values, valid often requir that if all non- 
faulti process propos the same valu then thi valu should be decid [21]. the classic valid use in 
the crash model be sometim use in the byzantin model requir that a decid valu be propos by some 
process [18] but the notion of valid valu propos by a byzantin process can be unclear. A predic be 
previous use to ass whether a valu be valid, however, the result predicate-bas valid requir that 
if all non-faulti process propos the same valid valu then thi valu should be decid [37]. A variant of 
thi definit do not requir the valu propos by all correct to be decid but can be violat with a non- 
null probabl [14]. It have be inform suggest for random consensu that a binari valu could be 
decid if it be provid along with some valid data [15]. when valu be not necessarili binary, the 
decid valu must sometim be within the rang of the valu propos by the non-faulti process [6] or 
suffici close to the median of valu propos by non-faulti process [64]. finally, valid sometim 
requir that the decid valu be either a special valu ⊥ or be a valu propos by a non-faulti process [19]. 
As ⊥ be a predefin value, decid thi valu be similar to abort [29]. our valid properti allow for a 
valid valu propos onli by byzantin process to be decid rather than aborting. 

multivalu to binari consensu reduct despit it simplic of presentation, there be surprisingli few 
reduct of multivalu consensu to binari consensus. the first reduct be design for the synchron 
model [65]. the key idea be to use a singl binari consensu instanc such that a non-faulti process would 
onli propos valu 1 in a round if it know that all non-faulti process receiv the same valu before. In the 
crash model, some reduct execut multipl binari consensu instances, but alway sequenti [55, 67]. 
the first crash-resili reduct complet after n binari consensu instanc [55] wherea the second one 
improv upon it to complet after dlog ne sequenti binari consensu instanc [67]. By contrast, our reduc- 
tion algorithm, besid appli to the byzantin model, execut all binari consensu instanc in parallel. 
interestingly, a veri similar algorithm to our reduct be use to solv agreement on a common subset in 
order to acheiv secur comput [5]. the same singl binari instanc reduct to [65] be late use in 
the asynchron model for random consensu [19, 54]. besid be randomized, the drawback of these 
reduct be that they may have to return ⊥ in case no decis can be take regard the propos value. By 
contrast, our reduct decid a valid valu that be proposed. 

As far a we know, eventually-synchron signature-fre byzantin consensu algorithm do not use re- 
duction. the classic implement can onli termin in a round coordin by a non-faulti process if the 
faulti coordin send inappropri valu [21], a drawback our algorithm do not have. 

leader-bas consensu It be well know that leader-bas consensu algorithm have some drawbacks. 
In crash-pron systems, the weak class of failur detector that allow to solv the consensu problem be 
3S [18] (which be equival to the eventu leader failur detector Ω introduc in [17]). it eventu accuraci 
properti guarante that there be a time after which there be a non-faulti process that be never suspect by 
the non-faulti processes. build upon thi guarantee, sever consensu algorithm be proposed, namely, 
the process proceed in asynchron round manag by a pre-determin leader or coordin that tri to 
impos a valu a the decision. the approach be similar to our binari byzantin consensu algorithm, with the 
differ that we do not reli on ani failur detector or eventu leader. moreover, 3S and Ω cannot be easili 
implement in byzantin systems. 

leader-bas algorithms, like pbft [16], fab [46] or zyzzyva [36], do not adopt the rotat coordin 
approach. the drawback of classic rotat coordin approach be that they may have to run through the 
t+ 1 round even in period of synchroni [21]. instead, leader-bas algorithm may termin faster in period 
of synchroni if the leader be non-faulti becaus they do not have to run through the t+ 1 rounds, a explain 
in [13]. these leader-bas approach requir a period of synchroni long enough not onli for consensu to 
terminate, provid that the leader be non-faulti or the valu be stabl [46], but also to elect a non-faulti leader 
or obtain a stabl value. anoth interest point be that pbft execut o(t) round in which all non-faulti 
process broadcast 2t + 1 checkpoint messages, which result in o(n4) bit exchang when t = ω(n), 
wherea in our multivalu consensu algorithm, all the non-faulti process broadcast in each of o(t) round 
of n binari consensu instances, lead to the same o(n4) bit complexity. 

16 



To bypass the difficulti of elect a leader in the presenc of byzantin failures, a synchron byzantin 
agreement that implement a virtual leader be propos [41], it avoid have to detect and remov a malici 
leader. similar to our algorithm, process exchang propos that they record in a vector where propos 
from non-faulti process be identical. the main differ be that it assum that process synchron their 
clock a it requir the vector to be full and contain propos from all non-faulti process within some fix 
time ∆ [40]. our approach be differ a we do not need the vector to be full or to contain propos from all 
non-faulti processes, we simpli appli the result of the binari consensu instanc a a bitmask to the vector. 

To conclude, our algorithm do not need a leader, make it harder to delay termination. In addition, while 
our algorithm be base on a rotat coordin it do not requir t+ 1 round to termin if good condit 
be met, in which case non-faulti process can decid even in round coordin by faulti processes. 

unrestrict blockchain origin blockchain system like bitcoin [56] and ethereum [66] target a peer-to- 
peer model where the number of process be frequent chang and be not know by processes. their con- 
sensu algorithm reli on process to gener a computationally-intens proof-of-work to limit the power of 
malici process when tri to reach consensus. the drawback be that they usual solv consensu prob- 
abilist [27]. To improv the scalabl of bitcoin, bitcoin-ng [22] solv a variant of consensu with 
probabilist termin and probabilist agreement by reli on a leader. elastico [44] reach a variant 
of consensu whose propos valu satisfi a specif predic function among subcommitte of c process 
each, but requir the commun to be synchronous. 

privat and consortium blockchain with the advent of privat and consortium blockchains, where the 
particip be restrict to n processes, new blockchain system suggest the use of classic byzantin fault 
toler algorithm (e.g., [16]) when n > 3t. after the semin pbft approach, sever implement be 
propos to reduc latenc when n > 5t (e.g., [46]), simplifi the develop (e.g., [1]) or trade fault-toler 
for perform (e.g., [43]). tendermint consensu us a variant of pbft with a rotat leader elect [38]. 
ripple’ consensu algorithm reli on uniqu node list that defin a quorum system where suffici node 
be control by the rippl compani [63]. stellar us adapt quorum system to implement consensu [47]. 
R3 have just releas corda that may use a byzantin fault toler algorithm or a crash-toler consensu 
algorithm with strong assumpt [30]. hyperledg fabric [12] us pbft but should provid support to a 
variant of apach kafka in the near future. A recent implement [48] suggest to reach consensu with a 
probabilist termination. 

7 conclus 

thi paper have present a new multivalu byzantin consensu algorithm tailor for consortium blockchains. 
It be asymptot time optim and resili optim and do not reli on a leader, random or sig- 
natures. It combin a reduct from multivalu to binari consensu that appli a bitmask to an array of 
propos and a binari consensu to build thi bitmask. By spawn binari consensu instanc in parallel, 
our reduct be a far a we know the first to decid a non-predefin valu in a sequenc of o(1) binari 
consensu instances. 

despit the larg interest in blockchain (and cryptocurr applications), there be rel few result 
on the formal of thi problem. our paper tri to address thi limit by formal the blockchain 
consensu a a gener variant of byzantin consensus. the result algorithm decoupl the problem of 
valid a block from the problem of decid on a block; it build upon the number n of consortium member 
to avoid sybil attacks; and it be indulg in that safeti be not affect when commun be delayed. 

17 



acknowledg 

tyler crain and vincent gramoli be support by the australian research council’ discoveri project fund- 
ing scheme (project number 160104801). vincent gramoli be the recipi of the australian research council 
discoveri intern award. mikel larrea be support by the spanish research council, grant tin2016- 
79897-p, and the basqu countri research council, grant it980-16 and mv_2016_1_0031. michel raynal 
be support by the french anr project descart (grant 16-ce40-0023-03) devot to distribut soft- 
ware engineering. 

refer 
[1] aublin p.-l., guerraoui r., knezev n., quema v., and vukolić m., the next 700 bft protocols. acm transact on 

comput systems, 32(4), articl 12, 45 page (2015) 

[2] aspn j., random protocol for asynchron consensus. distribut computing, 16(2-3):165-175 (2003) 

[3] berman P. and garay j.a., clotur voting: n/4-resili distribut consensu in t + 1 rounds. mathemat system theory, 
26(1):3-19 (1993) 

[4] ben-or m., anoth advantag of free choice: complet asynchron agreement protocols. proc. 2nd annual acm sympo- 
sium on principl of distribut comput (podc’83), acm press, pp. 27-30 (1983) 

[5] ben-or m., kelmer b., and rabin t., asynchron secur comput with optim resilience. proc. annual acm sympo- 
sium on principl pp. 183-192 (1994) 

[6] bonomi s., del pozzo a., potop-butucaru m., and tixeuil s., approxim agreement under mobil byzantin faults. proc. 
36th ieee intern confer on distribut comput system (icdcs’16), pp. 727-728 (2016) 

[7] borran f., hutl M. and schiper a., time analysi of leader-bas and decentr byzantin consensu algorithms. proc. 
5th latin-american symposium on depend comput (ladc’11), ieee press, pp.166-175 (2011) 

[8] bouzid z., mostéfaoui a., and raynal m., minim synchroni for byzantin consensus. proc. 34th annual acm symposium on 
principl of distribut comput (podc’15), acm press, pp. 461-470 (2015) 

[9] bracha g., asynchron byzantin agreement protocols. inform & computation, 75(2):130-143 (1987) 

[10] bracha G. and toueg s., asynchron consensu and broadcast protocols. journal of the acm, 32(4):824-840 (1985) 

[11] buterin v., ethereum: platform review, opportunit and challeng for privat and consortium blockchain (2016) 

[12] cachin c., blockchain - from the anarchi of cryptocurr to the enterprise. keynot present at 20th int’l confer 
on principl of distribut system (opodis’16) (2016) 

[13] cachin c., guerraoui r., and rodrigu l., reliabl and secur distribut programming, springer, 367 page (2011) isbn 
978-3-642-15259-7 

[14] cachin c., kursaw k., petzold f., and shoup v., secur and effici asynchron broadcast protocol proc. 21st annual 
intern cryptolog confer (crypto), pp.524-541, 2001 

[15] cachin c., kursaw k., and shoup v., random oracl in constantinople: practic asynchron byzantin agreement use 
cryptography. journal of cryptology,18(3):219-246 (2005, first version: podc 2000) 

[16] castro M. and liskov b., practic byzantin fault toler and proactiv recovery. acm transact on comput systems, 
20(4):398-461 (2002) 

[17] chandra t., hadzilaco v., and toueg s., the weak failur detector for solv consensus. journal of the acm, 43(4):685-722 
(1996) 

[18] chandra T. and toueg s., unreli failur detector for reliabl distribut systems. journal of the acm, 43(2):225-267 (1996) 

[19] correia m., ferreira neve n., and verissimo p., from consensu to atom broadcast: time-fre byzantine-resist protocol 
without signatures. the comput journal, 49(1):82-96 (2006) 

[20] dolev d., dwork C. and stockmey l., On the minim synchron need for distribut consensus. journal of the acm, 
34(1):77-97 (1987) 

[21] dwork c., lynch n., and stockmey l., consensu in the presenc of partial synchrony. journal of the acm, 35(2):288-323 
(1988) 

i 



[22] eyal i., gencer a.e., sirer e.g., and van reness r., bitcoin-ng: a scalabl blockchain protocol. proc. 13th usenix confer 
on network system design and implement (nsdi’16), pp.45-59 (2016) 

[23] fischer m.j. and lynch n.a., A low bound for the time to assur interact consistency. inform process letters, 
14(4):183-186 (1982) 

[24] fischer m.j., lynch n.a., and paterson m.s., imposs of distribut consensu with one faulti process. journal of the 
acm, 32(2):374-382 (1985) 

[25] friedman r., mostéfaoui a., rajsbaum s., and raynal m., distribut agreement problem and their connect with error- 
correct codes. ieee transact on computers, 56(7):865-875 (2007) 

[26] friedman r., mostéfaoui a., and raynal m., simpl and effici oracle-bas consensu protocol for asynchron byzantin 
systems. ieee transact on depend and secur computing, 2(1):46-56 (2005) 

[27] garay j., kiayia a., and leonardos, N. the bitcoin backbon protocol: analysi and applications. advanc in cryptolog - 
eurocrypt, pp. 281-310. (2015) 

[28] guerraoui r., indulg algorithms. proc. 19th annual acm symposium on principl of distribut comput (podc’00), 
acm press. pp. 289-297. (2000) 

[29] hadzilaco V. and toueg s., On determinist abort objects. proc. 32th annual acm symposium on principl of distribut 
comput (podc’13), acm press, pp.4-12 (2013) 

[30] hearn m., corda: a distribut ledger. version 0.5 (2016) 

[31] herlihi m., distribut comput and blockchains. keynot present at 18th int’l symposium on stabilization, safety, and 
secur of distribut system (sss’16) (2016) 

[32] herlihi m.p. and wing j.m, linearizability: a correct condit for concurr objects. acm transact on program 
languag and systems, 12(3):463-492 (1990) 

[33] imb D. and raynal m., trade t-resili for effici in asynchron byzantin reliabl broadcast. parallel process 
letters, 26(4), 8 page (2017) 

[34] kihlstrom k.p., moser l.e., and melliar-smith p.m., byzantin fault detector for solv consensus. the comput journal, 
46(1):16-35 (2003) 

[35] king V. and saia j., byzantin agreement in expect polynomi time. journal of the acm, 63(2), articl 13, 21 page (2016) 

[36] kotla r., alvisi l., dahlin m., clement a., and wong e.l., zyzzyva: specul byzantin fault tolerance. acm transact 
on comput systems, 27(4):7:1-7:39 (2009) 

[37] kursaw k., optimist asynchron byzantin agreement. manuscript (2000) 

[38] kwong j., tendermint: consensu without mining. v.0.7 (2016) 

[39] lamport l., time, clocks, and the order of event in a distribut system. commun of the acm, 21(7):558-565 (1978) 

[40] lamport l., leaderless byzantin consensus. unit state patent, microsoft corporation, redmond, WA (usa) (2010) 

[41] lamport l., leaderless byzantin paxos. proc. 25th intern simposium on distribut computing. (disc’11), pp.141-142 
(2011) 

[42] lamport l., shostack r., and peas m., the byzantin gener problem. acm transact on program languag and 
systems, 4(3)-382-401 (1982) 

[43] liu s., viotti p., cachin c., quéma v., and vukolić m., xft: practic fault toler beyond crashes. proc. 12th usenix 
symposium on oper system design and implement (osdi’16), acm press, pp. 485-500 (2016) 

[44] luu l., narayanan v., zheng c., baweja k., gilbert S. and saxena p., A secur shard protocol for open blockchains. acm 
confer on comput and commun secur (ccs’16), acm press, pp. 17-30 (2016) 

[45] lynch n.a., distribut algorithms. morgan kaufmann pub., san francisco (ca), 872 page (1996) isbn 1-55860-384-4 

[46] martin j.-ph. and alvisi l., fast byzantin consensus. ieee transact on depend and secur computing, 3(3):202-215 
(2006) 

[47] mazier d., the stellar consensu protocol: A feder model for internet-level consensus. (2015) 

[48] , miller a., xia y., croman k., shi e., and song d., the honey badger of bft protocol proc. of the 2016 acm sigsac 
confer on comput and commun security, p.31-42 (2016) 

ii 



[49] mostéfaoui a., moumen h., and raynal m., signature-fre asynchron binari byzantin consensu with t < n/3, o(n2) 
messages, and o(1) expect time. journal of acm, 62(4), articl 31, 21 page (2015) 

[50] mostéfaoui a., mourgaya e., and raynal m., asynchron implement of failur detectors. int’l ieee confer on 
depend system and network (dsn’03), ieee comput press, pp. 351-360 (2003) 

[51] mostéfaoui a., rajsbaum s., and raynal m., condit on input vector for consensu solvabl in asynchron distribut 
systems. journal of the acm, 50(6):922-954 (2003) 

[52] mostéfaoui A. and raynal m., k-set agreement and limit accuraci failur detectors. proc. 19th acm sigact-sigop int’l 
symposium on principl of distribut comput (podc’00), acm press, pp. 143-152 (2000) 

[53] mostéfaoui A. and raynal m., intrusion-toler broadcast and agreement abstract in the presenc of byzantin processes. 
ieee transact on parallel and distribut systems, 27(4):1085-1098 (2016) 

[54] mostéfaoui A. and raynal m., signature-fre asynchron byzantin systems: from multivalu to binari consensu with 
t < n/3, o(n2) messages, and constant time. acta informatica, doi 10.1007/s00236-016-0269-y, 20 page (2016) 

[55] mostéfaoui a., tronel f., and raynal m., from binari consensu to multivalu consensu in asynchron message-pass 
systems. inform process letters, 73:207-213 (2000) 

[56] nakamoto s., bitcoin: a peer-to-p electron cash system. http://www.bitcoin.org (2008) 

[57] natoli C. and gramoli v., the balanc attack against proof-of-work blockchains: the R3 testb a an example. arxiv, technic 
report 1612.09426 (2016) 

[58] natoli C. and gramoli v., the blockchain anomaly. proc. 5th ieee int’l symposium on network comput and applic 
(nca’16), ieee computerpress, pp. 310-317 (2016) 

[59] peas m., R. shostak r., and lamport l., reach agreement in the presenc of faults. journal of the acm, 27:228-234 (1980) 

[60] rabin m., random byzantin generals. proc. 24th ieee symposium on foundat of comput scienc (focs’83), ieee 
comput societi press, pp. 116-124(1983) 

[61] raynal m., commun and agreement abstract for fault-toler asynchron distribut systems. morgan & clay- 
pool, 251 page (2010) isbn 978-1-60845-293-4 

[62] schneider f.b., implement fault-toler servic use the state machin approach. acm comput surveys, 22(4):299-319 
(1990) 

[63] schwartz a.b.d. and young n., the rippl protocol consensu algorithm. rippl lab inc. (2014) 

[64] stolz D. and wattenhof r., byzantin agreement with median validity. proc. 19th intern confer on principl of 
distribut system (opodis’15), pp. 22:1-22:14 (2015) 

[65] turpin R. and coan b.a., extend binari byzantin agreement to multivalu byzantin agreement. inform process 
letters, 18:73-76 (1984) 

[66] wood g., ethereum: A secur decentr gener transact ledger. white paper (2015) 

[67] zhang J. and chen w., bound cost algorithm for multivalu consensu use binari consensu instances. inform pro- 
cess letters, 109:10056-1009 (2009) 

A A bv-broadcast algorithm 

A simpl self-explanatori algorithm implement the bv-broadcast abstract in the system modelbampn,t[t < 
n/3] be describ in figur 4. A proof of it can be found in [49] where bv-broadcast be use in the context 
of random consensus. 

B correct proof of the 3synch algorithm with byzantin toler dis- 
tribut clock 

It be possibl to replac the timeout use in the algorithm in figur 3 and to relax the assumpt that process 
time be null with the byzantin fault toler distribut clock of [21] to decid when process can move 
forward in rounds. We have then the follow lemma, which be then use instead of lemma 12 in the proof of 
theorem 3. 

lemma 15. let u consid the algorithm of figur 3 with the addit of byzantin fault toler distribut 
clock from [21]. eventu the non-faulti process attain a round from which they behav synchronously. 

iii 



oper bv_broadcast msg(vi) be 
(01) broadcast b_val(vi). 

when b_val(v) be receiv 
(02) if 

( 
b_val(v) receiv from (t+ 1) differ process and b_val(v) not yet broadcast 

) 
(03) then broadcast b_val(v) // a process echo a valu onli onc 
(04) end if; 
(05) if 

( 
b_val(v) receiv from (2t+ 1) differ process 

) 
(06) then bin_valuesi ← bin_valuesi ∪ {v} // local deliveri of a valu 
(07) end if. 

figur 4: An algorithm implement bv-broadcast in bampn,t[t < n/3] (from [49]) 

C correct proof of the 3synch algorithm with a catch-up mechan 

from asynchroni to synchroni here a catch-up mechan be provid a a modif to the algorithm 
in figur 3 that ensur process eventu execut synchron round where non-faulti process may 
observ time at differ rate and process time be non-negligible. 

lemma 12 ensur that all non-faulti process eventu particip in synchron round in a system 
where eventu the non-faulti processor run at the same speed and comput time be negligible. As 
thi time assumpt cannot be ensur in all systems, thi section extend the algorithm with a catch-up 
mechanism, which guarante progress in system where the differ in process speed be bound by some 
unknown constant. 

As we have seen, in order to guarante a decision, after the assum 3synch assumpt holds, it be need 
that eventu all non-faulti process execut round synchronously. observ that, due to initi asynchrony, 
non-faulti process can start the consensu algorithm at differ instants. moreover, due to the potenti 
particip of byzantin processes, some non-faulti process can advanc round –without deciding– while 
other non-faulti process be still execut previou rounds. 

befor describ the catch-up mechan the mini-round notat will be defined. each round r be split 
into two mini-rounds, with the first mini-round repres line 03 to (new4) and the second repres 
line m-06 to 12. like rounds, mini-round can be identifi by a number with the first mini-round start at 
0 and increas by one. for exampl round 3 be make up of mini-round 6 and 7. 

catch-up mechan the mechan that allow non-faulti process to catch up reli on the follow 
two chang to the algorithm10: 
• first, the timer be start onli when the condit of line m-05 and m-07 be satisfied, i.e., on line 

m-05 onli onc bin_valu i[ri] 6= ∅ be true, be the timer started. similarli on line m-07 the timer be onli 
start when n − t aux[ri]() messag satisfi the condit be received. let the timeout start at 0 
on mini-round 0 and grow by 1 each mini-round. 
• second, when a process be in a mini-round ρ and receiv messag correspond to anoth mini-round 
ρ′ > ρ from (t+ 1) differ process (i.e., from at least one non-faulti process), the process no longer 
wait for timer in mini-round ρ, .., (ρ′ − 1). It still complet these mini-rounds, but do it without 
wait for timer expiration. 

the idea of these mechan be to allow late or slow non-faulti process to catch up to the most advanc 
non-faulti process (a measur by their mini-round number). 

We assum that each process have a local clock that allow it to measur time units. time unit will be 
give in integers. A process us it local clock to measur the amount of time it wait for a timeout (where 
a timeout of 1 be 1 time unit). the notat t with a subscript (for exampl tfirst0) will be use to repres 
a time measur that be give by the number of time unit that have pass sinc the algorithm started, a 
measur by an omnisci global observ G. By 3synch , process be abl to observ time at differ 
rates, but within an unknown fix bound. for simplic assum that the fast process observ time at a rate 
no faster than observ by the global observ G and all other process observ time at thi rate or slower. 

notat similarli to previou sections, the follow notat and definit be use in the following. 
• δ be a fixed, but unknown bound on messag transfer delay a ensur by 3synch and measur in time 

unit a observ by G. 
10similar mechan be use by pbft [16]. 

iv 



• tfirstρ be the time, a measur by G, at which the first non-faulti process pfirstρ reach mini-round ρ 
(tfirst0 be the time at which the first non-faulti process start the consensus). 
• tlastρ be the time, a measur by G, at which the last non-faulti process plastρ reach mini-round ρ 

(tlast0 be the time at which the last non-faulti process start the consensus). 
• θfast (resp. θslow) be the minimum (resp. maximum) amount of time, a observ by G, for ani process 

to perform the comput of ani mini-round (a unknown bound differ between θfast and θslow 
be ensur by 3synch). 
• γfastρ be the minimum amount of time, a observ by G, in a mini-round ρ that ani process wait on 

line m-05 or m-07 befor start it timer for that mini-round. 
• mini-round ρδ be the first mini-round where timeout > δ. 

lemma 16. consid the algorithm of figur 3 enrich with the previou catch-up mechanism. there be a 
mini-round ρt such that in ρt and all follow mini-round all non-faulti process must wait for at least part 
of the timeout, i.e., they do not receiv t+ 1 messag from a round larg than ρt until after they start wait 
at the timeout of round ρt. 

proof let u onli consid mini-round where ρt > ρδ. for all non-faulti process to wait at a timeout in 
a mini-round ρt the last non-faulti process to arriv at that mini-round must arriv befor it could receiv a 
messag from some other non-faulti process that be execut a late mini-round (note that give ρt > ρδ, thi 
can onli be ensur when the process be no more than 1 mini-round apart), i.e., the follow must hold: 

tlastρt < tfirstρt+1 . (4) 

let u now find when thi can be satisfied. By definition, a process can spend no less time than (γfastρ′ + 
θfast + timeout) in a mini-round ρ′. given that the timeout start at 0 on mini-round 0 and grow by 1 in each 
mini-round, timeout can be replac with ρ for ani mini-round ρ. We then have: 

tfirstρ′ ≥ tfirstρδ + 

ρ′−1∑ 
x=ρδ 

γfastx + θfast + x 

 . 
notic that from the compon 

∑ρ′−1 
x=ρδ 

x (i.e., the timeout), the valu of tfirstρ′ be quadrat in the number of 
mini-rounds. 

now consid the slowest non-faulti process start from mini-round ρδ that do not wait at a timeout. 
thi process can spend no more time in a mini-round ρ′ than 2 messag delay plu the process time for 
the mini-round, i.e., 2 × δ + θslow. the reason for thi be a follows: To complet the mini-round the process 
must satisfi the condit on line m-05 or m-07. keep in mind that, give that the process do not wait at a 
timeout, it must have receiv t + 1 messag from a late mini-round, mean that some non-faulti process 
have alreadi complet ρ′. line m-05 requir (bin_valu i[ri] 6= ⊥). It be know that a non-faulti process 
have complet thi round and that process have therefor alreadi satisfi thi condition, and that all non-faulti 
process have execut line 04 (given that thi be the slowest process). with this, and the bv-uniform 
properti of the bv_broadcast() operation, all non-faulti process will have a valu in bin_valu i[ri] after 
at most 2 messag delay after the slowest process execut the bv_broadcast(). similarly, on line m-07 all 
non-faulti process will receiv the n − t aux messag need to satisfi the condit in 1 messag delay 
after the slowest non-faulti process broadcast it aux message, but may need to wait anoth messag delay 
in case a non-faulti process have a valu enter it bin_valu i[ri] immedi befor broadcast it aux 
message. We then have: 

tlastρ′ ≤ tlastρδ + 

ρ′−1∑ 
x=ρδ 

2× δ + θslow 

 . 
notic that the valu of tlastρ′ be linear in the number of mini-rounds. 

now give tfirstρ′ be quadrat while tlastρ′ be linear, inequ (4) must eventu be satisfied, thu there 
will be a mini-round where all non-faulti process wait for at least part of their timeout. 

It will now be show by induct that after timeout > (2×δ+θslow) inequ (4) hold for all follow 
mini-rounds. consid tlastρt < tfirstρt+1 be satisfied, let u now show that tlastρt+1 < tfirstρt+2 be satisfi 
a well. for thi to not hold, the slowest non-faulti process must spend more time on round ρt than the fast 

v 



non-faulti process spend on round (ρt + 1). given that ρt > ρδ, process plastρt must receiv (t+ 1) messag 
from round (ρt + 1) befor process pfirstρt+1 complet round (ρt + 1). onc these messag be receiv we 
have alreadi show that thi process will take no more than 2 × δ + θslow time to complet the round. thus, 
a long a timeout > (2 × δ + θslow), which will eventu be true give 3synch and the grow timeout, 
process plastρt will reach round (ρt + 1) befor pfirstρt+1 reach round (ρt + 2). 2lemma 16 

lemma 17. consid the algorithm of figur 3 enrich with the previou catch-up mechanism. eventu 
the non-faulti process attain a mini-round from which they behav synchronously. 

proof By lemma 16 it be know that there exist a mini-round ρt where all non-faulti process wait for at 
least part of their timeout. thi be ensur after round where timeout > (2× δ + θslow). consid we be in 
such rounds. now for a mini-round to be synchronous, all non-faulti process need to arriv at that mini-round 
with enough time to broadcast it messag to all non-faulti process befor ani non-faulti process move 
onto the next mini-round. In the case that the last non-faulti process to arriv at the round be the coordinator, it 
may take up to 3 messag delay befor it coord_value[r]() messag be receiv by all non-faulti process 
(thi includ up to 2 messag delay until a valu enter it bin_values[r] and an addit messag delay to 
broadcast coord_value[r]()). notic that befor a non-faulti process start it timer for a mini-round it must 
wait until the condit on line m-05 or m-07 be satisfied. thus, for a mini-round ρ′t to by synchron where 
ρ′t ≥ ρt, the follow need to be ensured: 

tlastρ′t 
+ (3× δ) + θslow ≤ tfirstρ′t + γfastρ′t + timeout. (5) 

By time (tfirstρ′t 
+ γfastρ′t 

+ θfast) at least one process have satisfi the condit on line m-05 or m-07 (thi 

be give by the definit of γ). As a result all process will receiv (t + 1) messag from mini-round ρ′t by 
time (tfirstρ′t 

+ γfastρ′t 
+ θfast + δ). now give lemma 16 and that (ρ′t − 1) > δ, it be know that that the 

slowest process be no further behind than wait at the timeout of mini-round (ρ′t − 1). after get these 
(t + 1) messag from mini-round ρ′t the slow process will then skip the timeout of mini-round (ρ 

′ 
t − 1) and 

reach the follow mini-round in at most 2 addit messag delay (2 messag delay be need for the 
same reason give in lemma 16 to satisfi the condit line m-05 or m-07) plu ani process time, i.e.: 

tlastρ′t 
≤ tfirstρ′t + γfastρ′t + θfast + θslow + (3× δ). 

now plug thi into inequ (5) lead to timeout ≥ (7× δ) + (2× θslow) + θfast (note that 2× θslow be 
includ to account for possibl process time in both round (ρ′t − 1) and ρ′t). but give that the timeout 
grow in each mini-round and that δ, θfast, and θslow be bound by 3synch there will eventu be a mini- 
round where thi hold true. 

finally, notic that a long a the timeout be thi larg (i.e. timeout ≥ (7 × δ) + (2 × θslow) + θfast) 
and lemma 16 hold then the abov argument be valid for ani round. now give that timeout ≥ (7 × δ) + 
(2 × θslow) + θfast be larg than the timeout need for lemma 16 to hold for everi follow round, onc 
inequ (5), i.e. synchrony, it true for one round, it will also hold for everi follow round. 2lemma 17 

vi 


introduct 
basic byzantin comput model and reliabl broadcast 
base comput model 
reliabl broadcast in byzantin system 

blockchain byzantin consensu 
multivalu byzantin consensu with predicate-bas valid 
binari byzantin consensu 

from multivalu to binari consensu in a byzantin system 
the reduct 
correct proof 

binari consensu in eventu synchron byzantin system 
the bv-broadcast all-to-al commun abstract 
A safe binari byzantin consensu algorithm in bampn,t[t<n/3] 
safeti proof 
eventu synchroni assumpt 
A binari byzantin consensu algorithm in bampn,t[t<n/3,synch] 
proof of the synch-bas algorithm 

relat work 
conclus 
A bv-broadcast algorithm 
correct proof of the synch algorithm with byzantin toler distribut clock 
correct proof of the synch algorithm with a catch-up mechan 

